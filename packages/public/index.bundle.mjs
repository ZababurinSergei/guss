var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// virtual-css:virtual:css
var virtual_css_exports = {};
__export(virtual_css_exports, {
  default: () => virtual_css_default,
  getAllCSS: () => getAllCSS,
  getCSSByPath: () => getCSSByPath,
  getCSSForComponent: () => getCSSForComponent,
  getCSSPaths: () => getCSSPaths,
  getComponentCSSMap: () => getComponentCSSMap,
  getMultipleCSS: () => getMultipleCSS,
  injectCSS: () => injectCSS
});
function getCSSByPath(filePath) {
  const normalizedPath = filePath.replace(/\\/g, "/");
  const entry = cssPaths.find((path) => path.replace(/\\/g, "/").includes(normalizedPath));
  if (entry) {
    const startMarker = "/* " + entry + " */";
    const startIndex = cssContent.indexOf(startMarker) + startMarker.length;
    let endIndex = cssContent.length;
    for (let i2 = cssPaths.indexOf(entry) + 1; i2 < cssPaths.length; i2++) {
      const nextMarker = "/* " + cssPaths[i2] + " */";
      const nextIndex = cssContent.indexOf(nextMarker);
      if (nextIndex !== -1) {
        endIndex = nextIndex;
        break;
      }
    }
    return cssContent.substring(startIndex, endIndex).trim();
  }
  return null;
}
function getCSSForComponent(componentName) {
  const componentPaths = componentCSSMap[componentName];
  if (!componentPaths) return null;
  return componentPaths.map((path) => getCSSByPath(path)).filter(Boolean).join("\n");
}
function getAllCSS() {
  return cssContent;
}
function injectCSS() {
  if (typeof document !== "undefined") {
    const style = document.createElement("style");
    style.textContent = cssContent;
    document.head.appendChild(style);
  }
}
function getCSSPaths() {
  return cssPaths;
}
function getMultipleCSS(paths) {
  return paths.map((path) => getCSSByPath(path)).filter(Boolean).join("\n");
}
function getComponentCSSMap() {
  return componentCSSMap;
}
var cssContent, cssPaths, componentCSSMap, virtual_css_default;
var init_virtual_css = __esm({
  "virtual-css:virtual:css"() {
    cssContent = `/* CSS Bundle - Generated by esbuild */

/* components/api-service/css/index.css */
/* components/api-service/css/index.css */
.api-service {
    display: none; /* \u0421\u043A\u0440\u044B\u0432\u0430\u0435\u043C \u0441\u0435\u0440\u0432\u0438\u0441\u043D\u044B\u0439 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 */
}

/* \u0421\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439 \u043E\u0431 \u043E\u0448\u0438\u0431\u043A\u0430\u0445 API */
.api-error {
    background: var(--danger-50);
    color: var(--danger-dark);
    padding: var(--space);
    border-radius: var(--radius);
    margin-bottom: var(--space-lg);
    border: 1px solid var(--danger);
    font-size: 14px;
    text-align: center;
}

.api-error button {
    background: var(--danger);
    color: white;
    border: none;
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius-sm);
    margin-top: var(--space-sm);
    cursor: pointer;
    font-size: 12px;
}

.api-error button:hover {
    background: var(--danger-dark);
}

/* \u0418\u043D\u0434\u0438\u043A\u0430\u0442\u043E\u0440 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 */
.api-loading {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid var(--primary);
    border-radius: 50%;
    animation: api-spin 1s linear infinite;
    margin-right: var(--space-sm);
}

@keyframes api-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u044F \u0434\u043B\u044F \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 */
.loading-disabled {
    opacity: 0.6;
    pointer-events: none;
    cursor: not-allowed;
}

/* \u0423\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F \u043E\u0431 \u0443\u0441\u043F\u0435\u0448\u043D\u044B\u0445 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u044F\u0445 */
.api-success {
    background: var(--success-50);
    color: var(--success-dark);
    padding: var(--space);
    border-radius: var(--radius);
    margin-bottom: var(--space-lg);
    border: 1px solid var(--success);
    font-size: 14px;
    text-align: center;
}

/* \u0410\u0434\u0430\u043F\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C \u0434\u043B\u044F API \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439 */
@media (max-width: 768px) {
    .api-error,
    .api-success {
        margin: var(--space);
        font-size: 13px;
    }
}

/* \u0410\u043D\u0438\u043C\u0430\u0446\u0438\u0438 \u0434\u043B\u044F API \u0432\u0437\u0430\u0438\u043C\u043E\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 */
@keyframes api-fade-in {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.api-notification {
    animation: api-fade-in 0.3s ease-out;
}

/* \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u044F \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043E\u043A API */
.api-button:disabled {
    background: var(--surface-300) !important;
    color: var(--text-tertiary) !important;
    cursor: not-allowed !important;
    transform: none !important;
}

.api-button.loading {
    position: relative;
    color: transparent;
}

.api-button.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: api-spin 1s linear infinite;
}

/* components/login-page/css/index.css */
/* components/login-page/css/index.css */
:host {
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    margin: 0;
    box-sizing: border-box;
    align-self: anchor-center;
    width: 100%;
    min-width: 100dvw;
}

div, input {
    box-sizing: border-box;
}

#root {
    display: flex;
    width: 100%;
}

.login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background:
            radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.2) 0%, transparent 50%),
            radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.25) 0%, transparent 50%),
            linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
    padding: var(--space-md);
    position: relative;
    overflow: hidden;
    width: inherit;
    box-sizing: border-box;
}

/* \u041A\u043E\u0441\u043C\u0438\u0447\u0435\u0441\u043A\u0438\u0435 \u0447\u0430\u0441\u0442\u0438\u0446\u044B */
.login-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image:
            radial-gradient(2px 2px at 20% 30%, rgba(255, 255, 255, 0.8) 50%, transparent 50%),
            radial-gradient(2px 2px at 40% 70%, rgba(255, 255, 255, 0.6) 50%, transparent 50%),
            radial-gradient(1px 1px at 60% 20%, rgba(255, 255, 255, 0.7) 50%, transparent 50%),
            radial-gradient(1px 1px at 80% 50%, rgba(255, 255, 255, 0.5) 50%, transparent 50%),
            radial-gradient(2px 2px at 30% 80%, rgba(255, 255, 255, 0.6) 50%, transparent 50%);
    background-repeat: repeat;
    animation: twinkle 4s ease-in-out infinite alternate;
}

@keyframes twinkle {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.8; }
}

.login-card {
    background: rgba(15, 23, 42, 0.8);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
    padding: var(--space-xl);
    width: 100%;
    max-width: 440px;
    box-shadow:
            0 25px 50px -12px rgba(0, 0, 0, 0.5),
            0 0 0 1px rgba(255, 255, 255, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-sizing: border-box;
}

.login-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
            90deg,
            transparent,
            rgba(255, 255, 255, 0.1),
            transparent
    );
    transition: left 0.6s ease;
}

.login-card:hover::before {
    left: 100%;
}

.login-card:hover {
    transform: translateY(-8px);
    box-shadow:
            0 35px 60px -12px rgba(0, 0, 0, 0.6),
            0 0 0 1px rgba(120, 119, 198, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
}

.login-card h2 {
    text-align: center;
    margin-bottom: var(--space-xl);
    color: rgba(255, 255, 255, 0.95);
    font-weight: 700;
    font-size: 2rem;
    letter-spacing: -0.025em;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.form-group {
    margin-bottom: var(--space-xl);
    position: relative;
}

.form-group label {
    display: block;
    margin-bottom: var(--space-sm);
    color: rgba(255, 255, 255, 0.8);
    font-weight: 500;
    font-size: 0.95rem;
    letter-spacing: 0.025em;
}

.form-group input {
    width: 100%;
    padding: var(--space-lg);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    background: rgba(15, 23, 42, 0.6);
    color: rgba(255, 255, 255, 0.95);
    font-size: 1rem;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow:
            inset 0 2px 4px rgba(0, 0, 0, 0.1),
            0 1px 0 rgba(255, 255, 255, 0.05);
}

.form-group input::placeholder {
    color: rgba(255, 255, 255, 0.4);
}

.form-group input:focus {
    border-color: rgba(120, 119, 198, 0.6);
    box-shadow:
            0 0 0 4px rgba(120, 119, 198, 0.1),
            inset 0 2px 4px rgba(0, 0, 0, 0.1),
            0 1px 0 rgba(255, 255, 255, 0.05);
    background: rgba(15, 23, 42, 0.8);
    transform: translateY(-2px);
}

.form-group input:disabled {
    background: rgba(255, 255, 255, 0.05);
    color: rgba(255, 255, 255, 0.4);
    cursor: not-allowed;
    transform: none;
}

.error-message {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(220, 38, 38, 0.1) 100%);
    color: rgba(254, 226, 226, 0.95);
    padding: var(--space-lg);
    border-radius: 16px;
    margin-bottom: var(--space-xl);
    border: 1px solid rgba(239, 68, 68, 0.3);
    font-size: 0.95rem;
    backdrop-filter: blur(10px);
    box-shadow:
            0 4px 12px rgba(239, 68, 68, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.login-btn {
    width: 100%;
    padding: var(--space-lg);
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: rgba(255, 255, 255, 0.95);
    border: none;
    border-radius: 16px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    box-shadow:
            0 8px 25px rgba(102, 126, 234, 0.4),
            0 2px 4px rgba(0, 0, 0, 0.1);
    letter-spacing: 0.025em;
}

.login-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
            90deg,
            transparent,
            rgba(255, 255, 255, 0.2),
            transparent
    );
    transition: left 0.6s ease;
}

.login-btn:hover::before {
    left: 100%;
}

.login-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow:
            0 15px 35px rgba(102, 126, 234, 0.5),
            0 5px 15px rgba(0, 0, 0, 0.1);
    background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
}

.login-btn:active:not(:disabled) {
    transform: translateY(-1px);
    box-shadow:
            0 5px 20px rgba(102, 126, 234, 0.4),
            0 2px 5px rgba(0, 0, 0, 0.1);
}

.login-btn:disabled {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.4);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* \u0410\u043D\u0438\u043C\u0430\u0446\u0438\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043A\u0438 */
.login-btn.loading {
    color: transparent;
}

.login-btn.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

/* \u0410\u0434\u0430\u043F\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C */
@media (max-width: 768px) {
    .login-container {
        padding: var(--space);
    }

    .login-card {
        padding: var(--space-lg);
        border-radius: 20px;
        max-width: 380px;
    }

    .login-card h2 {
        font-size: 1.75rem;
        margin-bottom: var(--space-lg);
    }

    .form-group {
        margin-bottom: var(--space-lg);
    }

    .form-group input {
        padding: var(--space);
    }

    .login-btn {
        padding: var(--space);
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .login-container {
        padding: var(--space-sm);
    }

    .login-card {
        padding: var(--space);
        border-radius: 16px;
        max-width: 320px;
    }

    .login-card h2 {
        font-size: 1.5rem;
    }

    .form-group label {
        font-size: 0.9rem;
    }

    .form-group input {
        padding: var(--space);
        font-size: 0.95rem;
    }

    .error-message {
        padding: var(--space);
        font-size: 0.9rem;
    }

    .login-btn {
        padding: var(--space);
        font-size: 0.95rem;
    }
}

/* \u0422\u0435\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E */
@media (prefers-color-scheme: dark) {
    .login-card {
        background: rgba(15, 23, 42, 0.9);
    }
}

/* \u0410\u043D\u0438\u043C\u0430\u0446\u0438\u0438 */
@keyframes spin {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg); }
}

/* \u041F\u043B\u0430\u0432\u043D\u043E\u0435 \u043F\u043E\u044F\u0432\u043B\u0435\u043D\u0438\u0435 */
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.login-card {
    animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

/* components/navigation-manager/css/index.css */
/* components/navigation-manager/css/index.css */
:host {
    display: flex;
    flex-direction: column;
    min-height: 100dvh;
}

navigation-manager {
    display: flex;
    min-height: 100vh;
    /*background:*/
    /*        radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),*/
    /*        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.2) 0%, transparent 50%),*/
    /*        radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.25) 0%, transparent 50%),*/
    /*        linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);*/
    position: relative;
}

/* \u041A\u043E\u0441\u043C\u0438\u0447\u0435\u0441\u043A\u0438\u0435 \u0447\u0430\u0441\u0442\u0438\u0446\u044B */
navigation-manager::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image:
            radial-gradient(2px 2px at 10% 20%, rgba(255, 255, 255, 0.8) 50%, transparent 50%),
            radial-gradient(2px 2px at 30% 60%, rgba(255, 255, 255, 0.6) 50%, transparent 50%),
            radial-gradient(1px 1px at 50% 10%, rgba(255, 255, 255, 0.7) 50%, transparent 50%),
            radial-gradient(1px 1px at 70% 40%, rgba(255, 255, 255, 0.5) 50%, transparent 50%),
            radial-gradient(2px 2px at 90% 70%, rgba(255, 255, 255, 0.6) 50%, transparent 50%),
            radial-gradient(1px 1px at 20% 90%, rgba(255, 255, 255, 0.4) 50%, transparent 50%);
    background-repeat: repeat;
    animation: cosmic-float 6s ease-in-out infinite alternate;
}

@keyframes cosmic-float {
    0%, 100% {
        opacity: 0.3;
        transform: translateY(0px);
    }
    50% {
        opacity: 0.8;
        transform: translateY(-10px);
    }
}

/* \u041A\u043E\u043D\u0442\u0435\u0439\u043D\u0435\u0440 \u043F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u044F */
#app-container {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 1;
}

/* \u0425\u0435\u0434\u0435\u0440 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F */
.user-header {
    position: sticky;
    top: 0;
    background: rgba(15, 23, 42, 0.8);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding: var(--space-lg) var(--space-xl);
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow:
            0 4px 20px rgba(0, 0, 0, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.05);
    z-index: 2;
}

.user-header::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
            90deg,
            transparent,
            rgba(120, 119, 198, 0.1),
            transparent
    );
    /*transition: left 0.8s ease;*/
}

.user-header::after {
    content: '';
    position: absolute;
    top: 0;
    right: -12px;
    height: 100%;
    background: #0b97c4;
}

.user-header:hover::before {
    left: 100%;
}

.username {
    color: rgba(255, 255, 255, 0.95);
    /*font-weight: 600;*/
    /*font-size: 1.1rem;*/
    /*!*background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);*!*/
    /*-webkit-background-clip: text;*/
    /*-webkit-text-fill-color: transparent;*/
    /*background-clip: text;*/
    /*text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);*/
    /*padding: var(--space-sm) var(--space);*/
    /*border-radius: 12px;*/
    /*!*background: rgba(255, 255, 255, 0.05);*!*/
    /*!*backdrop-filter: blur(10px);*!*/
    /*border: 1px solid rgba(255, 255, 255, 0.1);*/
}

.logout-btn {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(220, 38, 38, 0.1) 100%);
    color: rgba(254, 226, 226, 0.95);
    border: 1px solid rgba(239, 68, 68, 0.3);
    padding: var(--space-sm) var(--space-lg);
    border-radius: 12px;
    font-weight: 500;
    cursor: pointer;
    /*transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);*/
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
    box-shadow:
            0 4px 12px rgba(239, 68, 68, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.logout-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
            90deg,
            transparent,
            rgba(255, 255, 255, 0.1),
            transparent
    );
    /*transition: left 0.6s ease;*/
}

.logout-btn:hover::before {
    left: 100%;
}

.logout-btn:hover {
    transform: translateY(-2px);
    box-shadow:
            0 8px 25px rgba(239, 68, 68, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.2) 100%);
    border-color: rgba(239, 68, 68, 0.5);
}

.logout-btn:active {
    transform: translateY(0);
    box-shadow:
            0 2px 8px rgba(239, 68, 68, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

/* \u041E\u0441\u043D\u043E\u0432\u043D\u043E\u0439 \u043A\u043E\u043D\u0442\u0435\u043D\u0442 - \u0446\u0435\u043D\u0442\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 */
#app-container > *:not(.user-header) {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    padding: 0;
    position: relative;
}

/* \u041A\u043E\u043D\u0442\u0435\u0439\u043D\u0435\u0440\u044B \u0434\u043B\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446 */
login-page,
rounds-list,
round-page {
    width: 100%;
    max-width: 1200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

/* \u0410\u043D\u0438\u043C\u0430\u0446\u0438\u0438 \u043F\u043E\u044F\u0432\u043B\u0435\u043D\u0438\u044F */
@keyframes slideInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fadeInScale {
    from {
        opacity: 0;
        transform: scale(0.95);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

/* \u041F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u0435 \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0439 \u043A \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430\u043C */
login-page,
rounds-list,
round-page {
    animation: slideInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.user-role {
    color: white;
}

/* \u0421\u043F\u0435\u0446\u0438\u0444\u0438\u0447\u043D\u044B\u0435 \u0441\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u0446\u0435\u043D\u0442\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u0444\u043E\u0440\u043C */
login-page {
    min-height: 80vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* \u0423\u043B\u0443\u0447\u0448\u0435\u043D\u043D\u044B\u0435 \u0441\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u043A\u043E\u043D\u0442\u0435\u0439\u043D\u0435\u0440\u043E\u0432 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432 */
.login-container,
.rounds-list-container,
.round-page-container {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: fadeInScale 0.5s ease-out;
}

/* \u0410\u0434\u0430\u043F\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C */
@media (max-width: 768px) {
    navigation-manager {
        min-height: 100vh;
    }

    .user-header {
        padding: var(--space) var(--space-lg);
        flex-direction: column;
        gap: var(--space);
        text-align: center;
    }

    .username {
        font-size: 1rem;
        padding: var(--space-sm);
    }

    .logout-btn {
        padding: var(--space-sm) var(--space);
        font-size: 0.9rem;
    }

    #app-container > *:not(.user-header) {
        padding: var(--space-lg);
    }
}

@media (max-width: 480px) {
    .user-header {
        padding: var(--space);
    }

    .username {
        font-size: 0.95rem;
    }

    .logout-btn {
        padding: var(--space-xs) var(--space-sm);
        font-size: 0.85rem;
    }

    #app-container > *:not(.user-header) {
        padding: var(--space);
    }
}

/* \u0422\u0435\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E */
@media (prefers-color-scheme: dark) {
    /*navigation-manager {*/
    /*    background:*/
    /*            radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.25) 0%, transparent 50%),*/
    /*            radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.15) 0%, transparent 50%),*/
    /*            radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.2) 0%, transparent 50%),*/
    /*            linear-gradient(135deg, #0a081f 0%, #252247 50%, #1c1b2e 100%);*/
    /*}*/
}

/* \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 */
.loading-state {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 60vh;
    color: rgba(255, 255, 255, 0.7);
    font-size: 1.1rem;
}

.loading-state::after {
    content: '';
    width: 24px;
    height: 24px;
    border: 2px solid transparent;
    border-top: 2px solid rgba(120, 119, 198, 0.8);
    border-radius: 50%;
    margin-left: var(--space);
    animation: spin 1s linear infinite;
}

/* \u0423\u043B\u0443\u0447\u0448\u0435\u043D\u043D\u0430\u044F \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u044F \u0432\u0440\u0430\u0449\u0435\u043D\u0438\u044F */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* \u041F\u043B\u0430\u0432\u043D\u044B\u0435 \u043F\u0435\u0440\u0435\u0445\u043E\u0434\u044B \u043C\u0435\u0436\u0434\u0443 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430\u043C\u0438 */
navigation-manager {
    /*view-transition-name: navigation-manager;*/
}

::view-transition-old(navigation-manager),
::view-transition-new(navigation-manager) {
    animation-duration: 0.5s;
}

/* \u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438 */
.user-header,
.username,
.logout-btn {
    will-change: transform, opacity;
}

/* \u0423\u043B\u0443\u0447\u0448\u0435\u043D\u043D\u0430\u044F \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0441\u0442\u044C */
@media (prefers-reduced-motion: reduce) {
    navigation-manager::before,
    .user-header::before,
    .logout-btn::before {
        animation: none;
        transition: none;
    }

    login-page,
    rounds-list,
    round-page,
    .login-container,
    .rounds-list-container,
    .round-page-container {
        animation: none;
    }
}

/* \u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430 \u0444\u043E\u043A\u0443\u0441\u0430 \u0434\u043B\u044F \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0441\u0442\u0438 */
.logout-btn:focus-visible {
    outline: 2px solid rgba(120, 119, 198, 0.8);
    outline-offset: 2px;
    box-shadow:
            0 0 0 4px rgba(120, 119, 198, 0.3),
            0 8px 25px rgba(239, 68, 68, 0.3);
}

/* components/round-page/css/index.css */
/* components/round-page/css/index.css */
:host {
    margin: auto;
    position: relative;
}

.round-page-container {
    width: inherit;
    margin: 0 auto;
    padding: var(--space-xl);
    min-width: 22dvw;
}

.page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
}

.page-header h1 {
    margin: 0;
    color: var(--text);
    font-size: 1.5rem;
}

.user-info {
    background: var(--primary);
    color: white;
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius);
    font-weight: 500;
}

.back-btn {
    background: var(--surface-100);
    color: var(--text);
    border: 1px solid var(--border);
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius);
    margin-bottom: var(--space-xl);
    cursor: pointer;
    transition: var(--transition);
}

.back-btn:hover {
    background: var(--surface-200);
    border-color: var(--border-dark);
}

.game-area {
    text-align: center;
    background: var(--surface);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
    box-shadow: var(--shadow);
    border: 1px solid var(--border);
}

.goose-container {
    margin-bottom: var(--space-xl);
    font-size: 0.33dvw;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.goose-image {
    display: inline-block;
    padding: var(--space);
    border-radius: var(--radius-lg);
    transition: var(--transition);
    background: aqua;
}

.goose-image.clickable {
    cursor: pointer;
}

.goose-image.clickable:hover {
    transform: scale(1.05);
}

.goose-image.clickable:active {
    transform: scale(0.95);
}

/* \u0421\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u0440\u0438\u0441\u0443\u043D\u043A\u0430 \u0433\u0443\u0441\u044F */
.goose-art {
    position: relative;
    width: 200px;
    height: auto;
    margin: 0 auto;
    padding: 1dvw;
    border-radius: 8px;
    background: aqua;
}



.goose-body {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 120px;
    height: 80px;
    background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
    border-radius: 50% 40% 40% 50%;
    box-shadow:
            inset -5px -5px 10px rgba(0,0,0,0.1),
            inset 5px 5px 10px rgba(255,255,255,0.5);
}

.goose-neck {
    position: absolute;
    top: -30px;
    left: 80px;
    width: 30px;
    height: 60px;
    background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
    border-radius: 15px;
    transform: rotate(-20deg);
}

.goose-head {
    position: absolute;
    top: -70px;
    left: 95px;
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
    border-radius: 50%;
}

.goose-head::before {
    content: '';
    position: absolute;
    top: 15px;
    left: -5px;
    width: 15px;
    height: 8px;
    background: #ff6b6b;
    border-radius: 4px;
}

.goose-wings {
    position: absolute;
    top: 20px;
    left: -20px;
    width: 80px;
    height: 40px;
    background: linear-gradient(135deg, #e0e0e0 0%, #d0d0d0 100%);
    border-radius: 40% 50% 50% 40%;
    transform: rotate(10deg);
    animation: wingFlap 2s ease-in-out infinite;
}

@keyframes wingFlap {
    0%, 100% { transform: rotate(10deg) translateY(0); }
    50% { transform: rotate(15deg) translateY(-5px); }
}

.status-message {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: var(--space);
    padding: var(--space);
    border-radius: var(--radius);
}

.status-message.cooldown {
    background: var(--warning-50);
    color: var(--warning-dark);
    border: 1px solid var(--warning);
}

.status-message.active {
    background: var(--success-50);
    color: var(--success-dark);
    border: 1px solid var(--success);
}

.timer {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: var(--space);
    font-family: var(--font-mono);
}

.user-score {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--primary);
    background: var(--primary-50);
    padding: var(--space);
    border-radius: var(--radius);
    border: 1px solid var(--primary-100);
}

.round-stats {
    margin-top: var(--space-lg);
}

.stats-divider {
    height: 2px;
    background: var(--border);
    margin: var(--space-lg) 0;
}

.stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--space-sm) 0;
    border-bottom: 1px solid var(--border-subtle);
}

.stat-row:last-child {
    border-bottom: none;
}

.stat-row span:first-child {
    color: var(--text-secondary);
}

.stat-row span:last-child {
    font-weight: 600;
    color: var(--text);
}

.loading {
    text-align: center;
    padding: var(--space-xl);
    color: var(--text-secondary);
    font-style: italic;
}

/* \u0422\u0435\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430 \u0434\u043B\u044F \u0433\u0443\u0441\u044F */
[data-theme="dark"] .goose-body,
[data-theme="dark"] .goose-neck,
[data-theme="dark"] .goose-head {
    background: linear-gradient(135deg, #a0a0a0 0%, #808080 100%);
}

[data-theme="dark"] .goose-wings {
    background: linear-gradient(135deg, #808080 0%, #606060 100%);
}

/* components/rounds-list/css/01.css */
/* /11/public/components/rounds-list/css/index.css */
.rounds-list-container {
    max-width: 900px;
    margin: 0 auto;
    padding: var(--space-xl);
}

.page-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space);
    border-bottom: 2px solid var(--border);
}

.header-content h1 {
    margin: 0 0 var(--space-sm) 0;
    color: var(--text);
    font-size: 1.75rem;
}

.last-update {
    font-size: 0.875rem;
    color: var(--text-secondary);
    font-style: italic;
}

.user-info {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: var(--space-xs);
}

.username {
    font-weight: 600;
    color: var(--text);
}

.user-role {
    font-size: 0.875rem;
    color: var(--text-secondary);
    background: var(--surface-100);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-sm);
}

.actions-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xl);
    padding: var(--space);
    background: var(--surface-50);
    border-radius: var(--radius);
    border: 1px solid var(--border);
}

.create-round-btn {
    background: var(--accent);
    color: white;
    padding: var(--space) var(--space-xl);
    border: none;
    border-radius: var(--radius);
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
}

.create-round-btn:hover {
    background: var(--accent-dark);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.polling-status {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    transition: var(--transition);
}

.status-indicator.active {
    background: var(--success);
    animation: pulse 2s infinite;
}

.status-indicator.paused {
    background: var(--warning);
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.rounds-grid {
    display: grid;
    gap: var(--space-lg);
}

.round-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    cursor: pointer;
    transition: var(--transition);
    box-shadow: var(--shadow);
    position: relative;
}

.round-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
    border-color: var(--primary);
}

.round-card[data-is-active="true"] {
    border-left: 4px solid var(--success);
}

.round-card[data-is-upcoming="true"] {
    border-left: 4px solid var(--warning);
}

.round-card[data-is-finished="true"] {
    border-left: 4px solid var(--surface-300);
    opacity: 0.8;
}

.round-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space);
}

.round-id {
    font-family: var(--font-mono);
    font-size: 14px;
    color: var(--text);
    font-weight: 500;
}

.round-duration {
    font-size: 0.875rem;
    color: var(--text-secondary);
    background: var(--surface-100);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-sm);
}

.round-dates {
    margin-bottom: var(--space);
}

.date-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: var(--space-xs);
    font-size: 14px;
}

.date-label {
    color: var(--text-secondary);
    font-weight: 500;
}

.date-value {
    color: var(--text);
    font-family: var(--font-mono);
    font-size: 0.875rem;
}

.round-divider {
    height: 1px;
    background: var(--border);
    margin: var(--space) 0;
}

.round-stats {
    margin-bottom: var(--space);
}

.stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xs);
    font-size: 14px;
}

.stat-label {
    color: var(--text-secondary);
}

.stat-value {
    font-weight: 600;
    color: var(--text);
}

.countdown {
    color: var(--warning-dark);
    font-weight: 600;
}

.round-status {
    font-weight: 600;
    text-align: center;
    padding: var(--space-sm);
    border-radius: var(--radius);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-xs);
}

.status-cooldown {
    background: var(--warning-50);
    color: var(--warning-dark);
    border: 1px solid var(--warning);
}

.status-active {
    background: var(--success-50);
    color: var(--success-dark);
    border: 1px solid var(--success);
}

.status-finished {
    background: var(--surface-100);
    color: var(--text-secondary);
    border: 1px solid var(--border);
}

/* \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0438 \u043E\u0448\u0438\u0431\u043E\u043A */
.loading-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space);
    padding: var(--space-xl);
    color: var(--text-secondary);
}

.spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--surface-200);
    border-top: 3px solid var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.error-state {
    text-align: center;
    padding: var(--space-xl);
    background: var(--danger-50);
    border: 1px solid var(--danger);
    border-radius: var(--radius);
}

.error-icon {
    font-size: 2rem;
    margin-bottom: var(--space);
}

.retry-btn {
    background: var(--danger);
    color: white;
    border: none;
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius);
    cursor: pointer;
    margin-top: var(--space);
}

.empty-state {
    text-align: center;
    padding: var(--space-xl);
    color: var(--text-secondary);
    background: var(--surface-50);
    border-radius: var(--radius);
    border: 1px dashed var(--border);
}

.empty-icon {
    font-size: 3rem;
    margin-bottom: var(--space);
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* \u0410\u0434\u0430\u043F\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C */
@media (max-width: 768px) {
    .rounds-list-container {
        padding: var(--space);
    }

    .page-header {
        flex-direction: column;
        gap: var(--space);
    }

    .user-info {
        align-items: flex-start;
    }

    .actions-bar {
        flex-direction: column;
        gap: var(--space);
        align-items: stretch;
    }

    .round-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-xs);
    }

    .date-row {
        flex-direction: column;
        gap: var(--space-xs);
    }
}


.user-info {
    background: var(--primary);
    color: white;
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius);
    font-weight: 500;
    width: max-content;
    display: flex;
    flex-direction: row;
    gap: 12px;
}

/* components/rounds-list/css/index.css */
/* /11/public/components/rounds-list/css/index.css */
.rounds-list-container {
    max-width: 900px;
    margin: 0 auto;
    padding: var(--space-xl);
}

.page-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space);
    border-bottom: 2px solid var(--border);
}

.header-content h1 {
    margin: 0 0 var(--space-sm) 0;
    color: var(--text);
    font-size: 1.75rem;
}

.last-update {
    font-size: 0.875rem;
    color: var(--text-secondary);
    font-style: italic;
}

.user-info {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: var(--space-xs);
}

.username {
    font-weight: 600;
    color: var(--text);
}

.user-role {
    font-size: 0.875rem;
    color: var(--text-secondary);
    background: var(--surface-100);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-sm);
}

.actions-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xl);
    padding: var(--space);
    background: var(--surface-50);
    border-radius: var(--radius);
    border: 1px solid var(--border);
}

.create-round-btn {
    background: var(--accent);
    color: white;
    padding: var(--space) var(--space-xl);
    border: none;
    border-radius: var(--radius);
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
}

.create-round-btn:hover {
    background: var(--accent-dark);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.polling-status {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    transition: var(--transition);
}

.status-indicator.active {
    background: var(--success);
    animation: pulse 2s infinite;
}

.status-indicator.paused {
    background: var(--warning);
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.rounds-grid {
    display: grid;
    gap: var(--space-lg);
}

.round-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    cursor: pointer;
    transition: var(--transition);
    box-shadow: var(--shadow);
    position: relative;
}

.round-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
    border-color: var(--primary);
}

.round-card[data-is-active="true"] {
    border-left: 4px solid var(--success);
}

.round-card[data-is-upcoming="true"] {
    border-left: 4px solid var(--warning);
}

.round-card[data-is-finished="true"] {
    border-left: 4px solid var(--surface-300);
    opacity: 0.8;
}

.round-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space);
}

.round-id {
    font-family: var(--font-mono);
    font-size: 14px;
    color: var(--text);
    font-weight: 500;
}

.round-duration {
    font-size: 0.875rem;
    color: var(--text-secondary);
    background: var(--surface-100);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-sm);
}

.round-dates {
    margin-bottom: var(--space);
}

.date-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: var(--space-xs);
    font-size: 14px;
}

.date-label {
    color: var(--text-secondary);
    font-weight: 500;
}

.date-value {
    color: var(--text);
    font-family: var(--font-mono);
    font-size: 0.875rem;
}

.round-divider {
    height: 1px;
    background: var(--border);
    margin: var(--space) 0;
}

.round-stats {
    margin-bottom: var(--space);
}

.stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xs);
    font-size: 14px;
}

.stat-label {
    color: var(--text-secondary);
}

.stat-value {
    font-weight: 600;
    color: var(--text);
}

.countdown {
    color: var(--warning-dark);
    font-weight: 600;
}

.round-status {
    font-weight: 600;
    text-align: center;
    padding: var(--space-sm);
    border-radius: var(--radius);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-xs);
}

.status-cooldown {
    background: var(--warning-50);
    color: var(--warning-dark);
    border: 1px solid var(--warning);
}

.status-active {
    background: var(--success-50);
    color: var(--success-dark);
    border: 1px solid var(--success);
}

.status-finished {
    background: var(--surface-100);
    color: var(--text-secondary);
    border: 1px solid var(--border);
}

/* \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0438 \u043E\u0448\u0438\u0431\u043E\u043A */
.loading-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space);
    padding: var(--space-xl);
    color: var(--text-secondary);
}

.spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--surface-200);
    border-top: 3px solid var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.error-state {
    text-align: center;
    padding: var(--space-xl);
    background: var(--danger-50);
    border: 1px solid var(--danger);
    border-radius: var(--radius);
}

.error-icon {
    font-size: 2rem;
    margin-bottom: var(--space);
}

.retry-btn {
    background: var(--danger);
    color: white;
    border: none;
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius);
    cursor: pointer;
    margin-top: var(--space);
}

.empty-state {
    text-align: center;
    padding: var(--space-xl);
    color: var(--text-secondary);
    background: var(--surface-50);
    border-radius: var(--radius);
    border: 1px dashed var(--border);
}

.empty-icon {
    font-size: 3rem;
    margin-bottom: var(--space);
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* \u0410\u0434\u0430\u043F\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C */
@media (max-width: 768px) {
    .rounds-list-container {
        padding: var(--space);
    }

    .page-header {
        flex-direction: column;
        gap: var(--space);
    }

    .user-info {
        align-items: flex-start;
    }

    .actions-bar {
        flex-direction: column;
        gap: var(--space);
        align-items: stretch;
    }

    .round-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-xs);
    }

    .date-row {
        flex-direction: column;
        gap: var(--space-xs);
    }
}


.user-info {
    background: var(--primary);
    color: white;
    padding: var(--space-sm) var(--space);
    border-radius: var(--radius);
    font-weight: 500;
    width: max-content;
    display: flex;
    flex-direction: row;
    gap: 12px;
}

:host {
    margin: auto;
}

#root {
    width: inherit;
}


.rounds-list-container {
    max-width: 800px;
    margin: 0 auto;
    padding: var(--space-xl);
}

.page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space);
    border-bottom: 2px solid var(--border);
}

.page-header h1 {
    margin: 0;
    color: var(--text);
    font-size: 1.75rem;
}


.actions-bar {
    margin-bottom: var(--space-xl);
    text-align: center;
}

.create-round-btn {
    background: var(--accent);
    color: white;
    padding: var(--space) var(--space-xl);
    border: none;
    border-radius: var(--radius);
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
}

.create-round-btn:hover {
    background: var(--accent-dark);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.rounds-grid {
    display: grid;
    gap: var(--space-lg);
}

.round-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    cursor: pointer;
    transition: var(--transition);
    box-shadow: var(--shadow);
}

.round-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
    border-color: var(--primary);
}

.round-header {
    margin-bottom: var(--space);
}

.round-id {
    font-family: var(--font-mono);
    font-size: 14px;
    color: var(--text);
    font-weight: 500;
}

.round-dates {
    margin-bottom: var(--space);
}

.date-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: var(--space-xs);
    font-size: 14px;
}

.date-label {
    color: var(--text-secondary);
    font-weight: 500;
}

.date-value {
    color: var(--text);
    font-family: var(--font-mono);
}

.round-divider {
    height: 1px;
    background: var(--border);
    margin: var(--space) 0;
}

.round-status {
    font-weight: 600;
    text-align: center;
    padding: var(--space-sm);
    border-radius: var(--radius);
}

.status-cooldown {
    background: var(--warning-50);
    color: var(--warning-dark);
    border: 1px solid var(--warning);
}

.status-active {
    background: var(--success-50);
    color: var(--success-dark);
    border: 1px solid var(--success);
}

.status-finished {
    background: var(--surface-100);
    color: var(--text-secondary);
    border: 1px solid var(--border);
}

.loading {
    text-align: center;
    padding: var(--space-xl);
    color: var(--text-secondary);
    font-style: italic;
}

.empty-state {
    text-align: center;
    padding: var(--space-xl);
    color: var(--text-secondary);
    background: var(--surface-50);
    border-radius: var(--radius);
    border: 1px dashed var(--border);
}

/* components/state-manager/css/index.css */
/* components/state-manager/css/index.css */
.state-manager {
    display: none;
}

.state-manager.debug {
    display: block;
    position: fixed;
    top: 10px;
    right: 10px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: var(--space);
    max-width: 300px;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: var(--shadow-lg);
    z-index: 10000;
    font-size: 12px;
    font-family: var(--font-mono);
}

.state-manager.debug h3 {
    margin: 0 0 var(--space-sm) 0;
    color: var(--primary);
    font-size: 14px;
    border-bottom: 1px solid var(--border);
    padding-bottom: var(--space-xs);
}

.state-manager.debug .state-section {
    margin-bottom: var(--space);
}

.state-manager.debug .state-section h4 {
    margin: 0 0 var(--space-xs) 0;
    color: var(--text);
    font-size: 12px;
    font-weight: 600;
}

.state-manager.debug .state-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 2px;
    padding: 2px 4px;
    border-radius: 2px;
}

.state-manager.debug .state-item:hover {
    background: var(--surface-100);
}

.state-manager.debug .state-key {
    color: var(--text-secondary);
    font-weight: 500;
}

.state-manager.debug .state-value {
    color: var(--text);
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.state-manager.debug .state-actions {
    margin-top: var(--space);
    display: flex;
    gap: var(--space-xs);
}

.state-manager.debug .state-btn {
    padding: 4px 8px;
    font-size: 10px;
    background: var(--surface-200);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: var(--transition);
}

.state-manager.debug .state-btn:hover {
    background: var(--surface-300);
}

.state-manager.debug .state-btn.primary {
    background: var(--primary);
    color: white;
    border-color: var(--primary-dark);
}

.state-manager.debug .state-btn.primary:hover {
    background: var(--primary-dark);
}

.state-manager.debug .state-btn.danger {
    background: var(--danger);
    color: white;
    border-color: var(--danger-dark);
}

.state-manager.debug .state-btn.danger:hover {
    background: var(--danger-dark);
}

/* \u0422\u0435\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430 */
[data-theme="dark"] .state-manager.debug {
    background: var(--surface);
    border-color: var(--border-dark);
}

[data-theme="dark"] .state-manager.debug .state-item:hover {
    background: var(--surface-100);
}

/* \u0410\u0434\u0430\u043F\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C */
@media (max-width: 768px) {
    .state-manager.debug {
        max-width: 250px;
        font-size: 11px;
    }

    .state-manager.debug .state-value {
        max-width: 120px;
    }
}

@media (max-width: 480px) {
    .state-manager.debug {
        max-width: 200px;
        font-size: 10px;
    }

    .state-manager.debug .state-value {
        max-width: 80px;
    }
}

/* components/tests/src/modules/mocha/mocha.css */


/* components/tests/src/modules/mocha/old/mocha.css */


/* index.css */
/* \u0421\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u0441\u043A\u0440\u043E\u043B\u043B\u0431\u0430\u0440\u0430 */
:root {
    --scrollbar-opacity: 0;
    --scrollbar-visibility: hidden;
    --scrollbar-transition: opacity 0.3s ease, visibility 0.3s ease;
    --background: white;
}

/* \u0414\u043B\u044F Firefox - \u0434\u0435\u043B\u0430\u0435\u043C \u0442\u0440\u0435\u043A \u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u044B\u043C */
html {
    scrollbar-width: thin;
    /*scrollbar-color: rgba(100, 116, 139, 0) transparent;*/
    /*transition: scrollbar-color 0.3s ease;*/
    background: var(--background);
    scrollbar-color: transparent rgba(15, 23, 42, 0.8); /* \u0414\u043B\u044F Firefox */
    scrollbar-width: thin; /* \u0414\u043B\u044F Firefox */
}



/* \u0414\u043B\u044F \u0432\u0435\u0431\u043A\u0438\u0442 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043E\u0432 */
::-webkit-scrollbar {
    width: 12px;
    opacity: var(--scrollbar-opacity);
    visibility: var(--scrollbar-visibility);
    transition: var(--scrollbar-transition);
}


/* \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0435 \u043F\u0440\u0438 \u043F\u0440\u043E\u043A\u0440\u0443\u0442\u043A\u0435 */
html.scrolling {
    --scrollbar-opacity: 1;
    --scrollbar-visibility: visible;
}

html.scrolling::-webkit-scrollbar {
    opacity: 1;
    visibility: visible;
}

html.scrolling::-webkit-scrollbar-thumb {
    opacity: 1;
}

html.scrolling {
    scrollbar-color: rgba(100, 116, 139, 0.8) transparent;
}


html:not(.loaded) {
    --scrollbar-transition: none !important;
}

html:not(.loaded)::-webkit-scrollbar {
    transition: none !important;
}

html.no-transitions {
    --scrollbar-transition: none !important;
}

html.no-transitions * {
    transition: none !important;
    animation: none !important;
}

html.no-transitions::-webkit-scrollbar {
    transition: none !important;
}

body {
    margin: 0;
    padding: 0;
    background: white; /* \u0423\u0431\u0438\u0440\u0430\u0435\u043C \u0444\u043E\u043D \u0443 body, \u043E\u0441\u0442\u0430\u0432\u043B\u044F\u044F \u0442\u043E\u043B\u044C\u043A\u043E \u0443 html */
}

html {
    visibility: hidden;
}

.visible {
    visibility: visible;
}

:root {
    /* \u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435 \u0446\u0432\u0435\u0442\u0430 - \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043D\u0430\u044F \u043F\u0430\u043B\u0438\u0442\u0440\u0430 */
    --primary: #4e54c8;
    --primary-dark: #3f43a5;
    --primary-darker: #323583;
    --primary-50: #f0f2ff;
    --primary-100: #e0e7ff;

    --secondary: #8f94fb;
    --secondary-dark: #767ae9;

    --accent: #ff6b6b;
    --accent-dark: #ff5252;
    --accent-darker: #e04848;

    /* \u0422\u0435\u043A\u0441\u0442 */
    --text: #2d3748;
    --text-secondary: #718096;
    --text-tertiary: #a0aec0;

    /* \u041F\u043E\u0432\u0435\u0440\u0445\u043D\u043E\u0441\u0442\u0438 */
    --background: #f7fafc;
    --surface: #ffffff;
    --surface-50: #f8fafc;
    --surface-100: #f1f5f9;
    --surface-200: #e2e8f0;
    --surface-300: #cbd5e1;

    /* \u0413\u0440\u0430\u043D\u0438\u0446\u044B */
    --border: #e2e8f0;
    --border-subtle: #f1f5f9;
    --border-dark: #cbd5e1;

    /* \u0421\u0435\u043C\u0430\u043D\u0442\u0438\u0447\u0435\u0441\u043A\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 */
    --success: #48bb78;
    --success-dark: #38a169;
    --success-50: #f0fff4;
    --success-100: #c6f6d5;

    --warning: #ed8936;
    --warning-dark: #dd6b20;
    --warning-50: #fffaf0;
    --warning-100: #feebc8;

    --info: #4299e1;
    --info-dark: #3182ce;
    --info-50: #ebf8ff;
    --info-100: #bee3f8;

    --danger: #f56565;
    --danger-dark: #e53e3e;
    --danger-50: #fff5f5;
    --danger-100: #fed7d7;

    /* \u0422\u0435\u043D\u0438 */
    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);

    /* \u0410\u043D\u0438\u043C\u0430\u0446\u0438\u0438 */
    --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    --transition-slow: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);

    /* \u0428\u0440\u0438\u0444\u0442\u044B */
    --font-main: 'Rubik', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;

    /* \u0420\u0430\u0434\u0438\u0443\u0441\u044B */
    --radius-sm: 4px;
    --radius: 6px;
    --radius-md: 8px;
    --radius-lg: 12px;

    /* \u041E\u0442\u0441\u0442\u0443\u043F\u044B */
    --space-xs: 4px;
    --space-sm: 8px;
    --space: 12px;
    --space-md: 16px;
    --space-lg: 20px;
    --space-xl: 24px;
}

/* \u0422\u0435\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430 */
[data-theme="dark"] {
    --primary: #6366f1;
    --primary-dark: #4f46e5;
    --primary-darker: #4338ca;
    --primary-50: #1e1b4b;
    --primary-100: #312e81;

    --secondary: #818cf8;
    --secondary-dark: #6366f1;

    --accent: #f87171;
    --accent-dark: #ef4444;
    --accent-darker: #dc2626;

    --text: #f1f5f9;
    --text-secondary: #cbd5e1;
    --text-tertiary: #94a3b8;

    --background: #0f172a;
    --surface: #1e293b;
    --surface-50: #1e293b;
    --surface-100: #334155;
    --surface-200: #475569;
    --surface-300: #64748b;

    --border: #334155;
    --border-subtle: #1e293b;
    --border-dark: #475569;

    --success: #34d399;
    --success-dark: #10b981;
    --success-50: #064e3b;
    --success-100: #065f46;

    --warning: #fbbf24;
    --warning-dark: #f59e0b;
    --warning-50: #78350f;
    --warning-100: #92400e;

    --info: #60a5fa;
    --info-dark: #3b82f6;
    --info-50: #1e3a8a;
    --info-100: #1e40af;

    --danger: #f87171;
    --danger-dark: #ef4444;
    --danger-50: #7f1d1d;
    --danger-100: #991b1b;

    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
}

/* \u0411\u0430\u0437\u043E\u0432\u044B\u0435 \u0441\u0442\u0438\u043B\u0438 */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: var(--font-main);
    /*background-color: var(--background);*/
    color: var(--text);
    line-height: 1.6;
    transition: var(--transition-slow);
    overflow-y: scroll;
}

/* \u0422\u0438\u043F\u043E\u0433\u0440\u0430\u0444\u0438\u044F */
h1, h2, h3, h4, h5, h6 {
    color: var(--text);
    font-weight: 600;
    line-height: 1.3;
    margin-bottom: var(--space);
}

h1 { font-size: 2rem; }
h2 { font-size: 1.75rem; }
h3 { font-size: 1.5rem; }
h4 { font-size: 1.25rem; }
h5 { font-size: 1.125rem; }
h6 { font-size: 1rem; }

p {
    margin-bottom: var(--space);
    color: var(--text-secondary);
}

/* \u041A\u043D\u043E\u043F\u043A\u0438 */
button {
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    border: none;
    border-radius: var(--radius);
    cursor: pointer;
    transition: var(--transition);
    outline: none;
    position: relative;
    overflow: hidden;
}

button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

/* \u0424\u043E\u0440\u043C\u044B */
input, textarea, select {
    font-family: inherit;
    font-size: 14px;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background-color: var(--surface);
    color: var(--text);
    transition: var(--transition);
    outline: none;
}

input:focus, textarea:focus, select:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent);
}

/* \u0423\u0442\u0438\u043B\u0438\u0442\u044B */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 var(--space-md);
}

.card {
    background: var(--surface);
    border-radius: var(--radius-md);
    box-shadow: var(--shadow);
    border: 1px solid var(--border);
    transition: var(--transition);
}

.card:hover {
    box-shadow: var(--shadow-md);
}

/* \u0410\u043D\u0438\u043C\u0430\u0446\u0438\u0438 */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
    from { transform: translateX(-100%); }
    to { transform: translateX(0); }
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* \u041C\u043E\u0434\u0430\u043B\u044C\u043D\u044B\u0435 \u043E\u043A\u043D\u0430 */
.yato-modal-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    animation: fadeIn 0.2s ease-out;
}

.yato-modal-wrapper {
    background: var(--surface);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg);
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow: hidden;
    animation: fadeIn 0.3s ease-out;
}

.yato-modal-content {
    padding: var(--space-xl);
}

.yato-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
    padding-bottom: var(--space);
    border-bottom: 1px solid var(--border);
}

.yato-modal-title {
    margin: 0;
    color: var(--text);
    font-size: 1.25rem;
}

.yato-modal-close-button {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: var(--text-tertiary);
    cursor: pointer;
    padding: var(--space-xs);
    border-radius: var(--radius);
    transition: var(--transition);
}

.yato-modal-close-button:hover {
    background-color: var(--surface-100);
    color: var(--text);
}

.yato-modal-body {
    margin-bottom: var(--space-lg);
    color: var(--text-secondary);
}

.yato-modal-footer {
    display: flex;
    gap: var(--space);
    justify-content: flex-end;
    padding-top: var(--space);
    border-top: 1px solid var(--border);
}

.yato-button {
    padding: var(--space) var(--space-lg);
    border-radius: var(--radius);
    font-weight: 500;
    transition: var(--transition);
    border: none;
    cursor: pointer;
}

.yato-button.primary {
    background-color: var(--primary);
    color: white;
}

.yato-button.primary:hover {
    background-color: var(--primary-dark);
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

.yato-button.secondary {
    background-color: var(--surface-100);
    color: var(--text);
    border: 1px solid var(--border);
}

.yato-button.secondary:hover {
    background-color: var(--surface-200);
    border-color: var(--border-dark);
}

/* \u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 */
.loading-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

/* \u0410\u0434\u0430\u043F\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C */
@media (max-width: 768px) {
    :root {
        --space-xl: 20px;
        --space-lg: 16px;
        --space-md: 12px;
        --space: 10px;
    }

    .container {
        padding: 0 var(--space);
    }

    h1 { font-size: 1.75rem; }
    h2 { font-size: 1.5rem; }
    h3 { font-size: 1.25rem; }
}

@media (max-width: 480px) {
    .yato-modal-content {
        padding: var(--space-lg);
    }

    .yato-modal-footer {
        flex-direction: column;
    }

    .yato-button {
        width: 100%;
    }
}

/* \u0414\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0441\u0442\u044C */
@media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* \u0424\u043E\u043A\u0443\u0441 \u0434\u043B\u044F \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0441\u0442\u0438 */
button:focus-visible,
input:focus-visible,
textarea:focus-visible,
select:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
}

/* \u0412\u044B\u0441\u043E\u043A\u0438\u0439 \u043A\u043E\u043D\u0442\u0440\u0430\u0441\u0442 */
@media (prefers-contrast: high) {
    :root {
        --border: #000000;
        --shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    [data-theme="dark"] {
        --border: #ffffff;
    }
}

/* \u0428\u0440\u0438\u0444\u0442\u044B */
@font-face {
    font-family: 'Rubik';
    src: local('Rubik'), url('./fonts/Rubik-Regular.ttf');
    font-weight: 400;
    font-style: normal;
    font-display: swap;
}

@font-face {
    font-family: 'Rubik';
    src: local('Rubik-Bold'), url('./fonts/Rubik-Bold.ttf');
    font-weight: 700;
    font-style: normal;
    font-display: swap;
}

@font-face {
    font-family: 'Rubik';
    src: local('Rubik-Medium'), url('./fonts/Rubik-Medium.ttf');
    font-weight: 500;
    font-style: normal;
    font-display: swap;
}

/* scroll.css */
/* \u0421\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u0441\u043A\u0440\u043E\u043B\u043B\u0431\u0430\u0440\u0430 */
:root {
    --scrollbar-opacity: 0;
    --scrollbar-visibility: hidden;
    --scrollbar-transition: opacity 0.3s ease, visibility 0.3s ease;
    --background: white;
}

/* \u0414\u043B\u044F Firefox - \u0434\u0435\u043B\u0430\u0435\u043C \u0442\u0440\u0435\u043A \u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u044B\u043C */
html {
    scrollbar-width: thin;
    /*scrollbar-color: rgba(100, 116, 139, 0) transparent;*/
    /*transition: scrollbar-color 0.3s ease;*/
    background: var(--background);
    scrollbar-color: transparent rgba(15, 23, 42, 0.8); /* \u0414\u043B\u044F Firefox */
    scrollbar-width: thin; /* \u0414\u043B\u044F Firefox */
}



/* \u0414\u043B\u044F \u0432\u0435\u0431\u043A\u0438\u0442 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043E\u0432 */
::-webkit-scrollbar {
    width: 12px;
    opacity: var(--scrollbar-opacity);
    visibility: var(--scrollbar-visibility);
    transition: var(--scrollbar-transition);
}


/* \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0435 \u043F\u0440\u0438 \u043F\u0440\u043E\u043A\u0440\u0443\u0442\u043A\u0435 */
html.scrolling {
    --scrollbar-opacity: 1;
    --scrollbar-visibility: visible;
}

html.scrolling::-webkit-scrollbar {
    opacity: 1;
    visibility: visible;
}

html.scrolling::-webkit-scrollbar-thumb {
    opacity: 1;
}

html.scrolling {
    scrollbar-color: rgba(100, 116, 139, 0.8) transparent;
}

`;
    cssPaths = ["components/api-service/css/index.css", "components/login-page/css/index.css", "components/navigation-manager/css/index.css", "components/round-page/css/index.css", "components/rounds-list/css/01.css", "components/rounds-list/css/index.css", "components/state-manager/css/index.css", "components/tests/src/modules/mocha/mocha.css", "components/tests/src/modules/mocha/old/mocha.css", "index.css", "scroll.css"];
    componentCSSMap = { "api-service": ["components/api-service/css/index.css"], "login-page": ["components/login-page/css/index.css"], "navigation-manager": ["components/navigation-manager/css/index.css"], "round-page": ["components/round-page/css/index.css"], "rounds-list": ["components/rounds-list/css/01.css", "components/rounds-list/css/index.css"], "state-manager": ["components/state-manager/css/index.css"] };
    __name(getCSSByPath, "getCSSByPath");
    __name(getCSSForComponent, "getCSSForComponent");
    __name(getAllCSS, "getAllCSS");
    __name(injectCSS, "injectCSS");
    __name(getCSSPaths, "getCSSPaths");
    __name(getMultipleCSS, "getMultipleCSS");
    __name(getComponentCSSMap, "getComponentCSSMap");
    virtual_css_default = cssContent;
  }
});

// node_modules/multiformats/dist/src/bytes.js
var empty = new Uint8Array(0);
function coerce(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
    return o2;
  }
  if (o2 instanceof ArrayBuffer) {
    return new Uint8Array(o2);
  }
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce, "coerce");

// node_modules/multiformats/dist/src/vendor/base-x.js
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode2, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode2(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  __name(decode2, "decode");
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
__name(base, "base");
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/multiformats/dist/src/bases/base.js
var Encoder = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or, "or");
var Codec = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from({ name, prefix, encode: encode2, decode: decode2 }) {
  return new Codec(name, prefix, encode2, decode2);
}
__name(from, "from");
function baseX({ name, prefix, alphabet }) {
  const { encode: encode2, decode: decode2 } = base_x_default(alphabet, name);
  return from({
    prefix,
    name,
    encode: encode2,
    decode: /* @__PURE__ */ __name((text) => coerce(decode2(text)), "decode")
  });
}
__name(baseX, "baseX");
function decode(string, alphabetIdx, bitsPerChar, name) {
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = alphabetIdx[string[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode, "decode");
function encode(data, alphabet, bitsPerChar) {
  const pad = alphabet[alphabet.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode, "encode");
function createAlphabetIdx(alphabet) {
  const alphabetIdx = {};
  for (let i2 = 0; i2 < alphabet.length; ++i2) {
    alphabetIdx[alphabet[i2]] = i2;
  }
  return alphabetIdx;
}
__name(createAlphabetIdx, "createAlphabetIdx");
function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
  const alphabetIdx = createAlphabetIdx(alphabet);
  return from({
    prefix,
    name,
    encode(input) {
      return encode(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabetIdx, bitsPerChar, name);
    }
  });
}
__name(rfc4648, "rfc4648");

// node_modules/multiformats/dist/src/bases/base32.js
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/dist/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/dist/src/bases/base64.js
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/weald/node_modules/ms/dist/index.js
var e = 1e3;
var t = e * 60;
var n = t * 60;
var r = n * 24;
var i = r * 7;
var a = r * 365.25;
var o = a / 12;
function s(e2, t2) {
  if (typeof e2 == `string`) return l(e2);
  if (typeof e2 == `number`) return p(e2, t2);
  throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(e2)}`);
}
__name(s, "s");
var c = s;
function l(s2) {
  if (typeof s2 != `string` || s2.length === 0 || s2.length > 100) throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(s2)}`);
  let c2 = /^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(s2);
  if (!c2?.groups) return NaN;
  let { value: l2, unit: u = `ms` } = c2.groups, d2 = parseFloat(l2), f2 = u.toLowerCase();
  switch (f2) {
    case `years`:
    case `year`:
    case `yrs`:
    case `yr`:
    case `y`:
      return d2 * a;
    case `months`:
    case `month`:
    case `mo`:
      return d2 * o;
    case `weeks`:
    case `week`:
    case `w`:
      return d2 * i;
    case `days`:
    case `day`:
    case `d`:
      return d2 * r;
    case `hours`:
    case `hour`:
    case `hrs`:
    case `hr`:
    case `h`:
      return d2 * n;
    case `minutes`:
    case `minute`:
    case `mins`:
    case `min`:
    case `m`:
      return d2 * t;
    case `seconds`:
    case `second`:
    case `secs`:
    case `sec`:
    case `s`:
      return d2 * e;
    case `milliseconds`:
    case `millisecond`:
    case `msecs`:
    case `msec`:
    case `ms`:
      return d2;
    default:
      throw Error(`Unknown unit "${f2}" provided to ms.parse(). value=${JSON.stringify(s2)}`);
  }
}
__name(l, "l");
function d(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? `${Math.round(s2 / a)}y` : c2 >= o ? `${Math.round(s2 / o)}mo` : c2 >= i ? `${Math.round(s2 / i)}w` : c2 >= r ? `${Math.round(s2 / r)}d` : c2 >= n ? `${Math.round(s2 / n)}h` : c2 >= t ? `${Math.round(s2 / t)}m` : c2 >= e ? `${Math.round(s2 / e)}s` : `${s2}ms`;
}
__name(d, "d");
function f(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? m(s2, c2, a, `year`) : c2 >= o ? m(s2, c2, o, `month`) : c2 >= i ? m(s2, c2, i, `week`) : c2 >= r ? m(s2, c2, r, `day`) : c2 >= n ? m(s2, c2, n, `hour`) : c2 >= t ? m(s2, c2, t, `minute`) : c2 >= e ? m(s2, c2, e, `second`) : `${s2} ms`;
}
__name(f, "f");
function p(e2, t2) {
  if (typeof e2 != `number` || !Number.isFinite(e2)) throw Error(`Value provided to ms.format() must be of type number.`);
  return t2?.long ? f(e2) : d(e2);
}
__name(p, "p");
function m(e2, t2, n2, r2) {
  let i2 = t2 >= n2 * 1.5;
  return `${Math.round(e2 / n2)} ${r2}${i2 ? `s` : ``}`;
}
__name(m, "m");

// node_modules/weald/dist/src/common.js
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = c;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  __name(selectColor, "selectColor");
  createDebug.selectColor = selectColor;
  function createDebug(namespace, options) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug(...args) {
      if (!debug.enabled) {
        return;
      }
      const self2 = debug;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      if (options?.onLog != null) {
        options.onLog(...args);
      }
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    __name(debug, "debug");
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy;
    Object.defineProperty(debug, "enabled", {
      enumerable: true,
      configurable: false,
      get: /* @__PURE__ */ __name(() => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      }, "get"),
      set: /* @__PURE__ */ __name((v) => {
        enableOverride = v;
      }, "set")
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug);
    }
    return debug;
  }
  __name(createDebug, "createDebug");
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  __name(extend, "extend");
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  __name(enable, "enable");
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  __name(disable, "disable");
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  __name(enabled, "enabled");
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  __name(toNamespace, "toNamespace");
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  __name(coerce2, "coerce");
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  __name(destroy, "destroy");
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}
__name(setup, "setup");

// node_modules/weald/dist/src/browser.js
var storage = localstorage();
var colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null) {
    return false;
  }
  return typeof document !== "undefined" && document.documentElement?.style?.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
}
__name(useColors, "useColors");
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + c(this.diff);
  if (!this.useColors) {
    return;
  }
  const c2 = "color: " + this.color;
  args.splice(1, 0, c2, "color: inherit");
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index++;
    if (match === "%c") {
      lastC = index;
    }
  });
  args.splice(lastC, 0, c2);
}
__name(formatArgs, "formatArgs");
var log = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage?.setItem("debug", namespaces);
    } else {
      storage?.removeItem("debug");
    }
  } catch (error) {
  }
}
__name(save, "save");
function load() {
  let r2;
  try {
    r2 = storage?.getItem("debug");
  } catch (error) {
  }
  if (!r2 && typeof globalThis.process !== "undefined" && "env" in globalThis.process) {
    r2 = globalThis.process.env.DEBUG;
  }
  return r2;
}
__name(load, "load");
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
__name(localstorage, "localstorage");
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
__name(setupFormatters, "setupFormatters");
var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });

// node_modules/weald/dist/src/index.js
var src_default = browser_default;

// node_modules/@libp2p/logger/dist/src/index.js
src_default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
src_default.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
src_default.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
src_default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function formatError(v, indent = "") {
  const message = notEmpty(v.message);
  const stack = notEmpty(v.stack);
  if (message != null && stack != null) {
    if (stack.includes(message)) {
      return `${stack.split("\n").join(`
${indent}`)}`;
    }
    return `${message}
${indent}${stack.split("\n").join(`
${indent}`)}`;
  }
  if (stack != null) {
    return `${stack.split("\n").join(`
${indent}`)}`;
  }
  if (message != null) {
    return `${message}`;
  }
  return `${v.toString()}`;
}
__name(formatError, "formatError");
function isAggregateError(err) {
  return err instanceof AggregateError || err?.name === "AggregateError" && Array.isArray(err.errors);
}
__name(isAggregateError, "isAggregateError");
function printError(err, indent = "") {
  if (isAggregateError(err)) {
    let output = formatError(err, indent);
    if (err.errors.length > 0) {
      indent = `${indent}    `;
      output += `
${indent}${err.errors.map((err2) => `${printError(err2, `${indent}`)}`).join(`
${indent}`)}`;
    } else {
      output += `
${indent}[Error list was empty]`;
    }
    return output.trim();
  }
  return formatError(err, indent);
}
__name(printError, "printError");
src_default.formatters.e = (v) => {
  if (v == null) {
    return "undefined";
  }
  return printError(v);
};
function createDisabledLogger(namespace) {
  const logger2 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
__name(createDisabledLogger, "createDisabledLogger");
function logger(name, options) {
  let trace = createDisabledLogger(`${name}:trace`);
  if (src_default.enabled(`${name}:trace`) && src_default.names.map((r2) => r2.toString()).find((n2) => n2.includes(":trace")) != null) {
    trace = src_default(`${name}:trace`, options);
  }
  return Object.assign(src_default(name, options), {
    error: src_default(`${name}:error`, options),
    trace,
    newScope: /* @__PURE__ */ __name((scope) => logger(`${name}:${scope}`, options), "newScope")
  });
}
__name(logger, "logger");
function notEmpty(str) {
  if (str == null) {
    return;
  }
  str = str.trim();
  if (str.length === 0) {
    return;
  }
  return str;
}
__name(notEmpty, "notEmpty");

// packages/frontend/src/base/base-component.mjs
var log2 = logger("base-component");
var exclusion = [];
var BaseComponent = class _BaseComponent extends HTMLElement {
  static {
    __name(this, "BaseComponent");
  }
  static pendingRequests = /* @__PURE__ */ new Map();
  static observedAttributes = ["*"];
  static MAX_POLLING_INTERVAL = 100;
  // ms
  static errorStore = [];
  static ERROR_STORE_LIMIT = 10;
  //  
  constructor() {
    super();
    if (new.target === _BaseComponent) {
      throw new Error("\u042F\u0422\u041E-ABS1: \u041D\u0435\u043B\u044C\u0437\u044F \u0438\u043D\u0441\u0442\u0430\u043D\u0446\u0438\u0438\u0440\u043E\u0432\u0430\u0442\u044C BaseComponent \u043D\u0430\u043F\u0440\u044F\u043C\u0443\u044E");
    }
    if (!this.shadowRoot) {
      this.attachShadow({ mode: "open" });
    }
    this.#templateImported = false;
    this.getComponentAsync = _BaseComponent.getComponentAsync;
    this.addError = _BaseComponent.addError;
    this.getErrors = _BaseComponent.getErrors;
    this.clearErrors = _BaseComponent.clearErrors;
    this.getComponent = _BaseComponent.getComponent;
    this.pendingRequests = _BaseComponent.pendingRequests;
    this.#isReady = false;
    this.#isQuantum = false;
    this.entropy = 1;
    this.qubits = 0;
    this.getTemplate = () => "<div>\u0428\u0430\u0431\u043B\u043E\u043D \u043D\u0435 \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D</div>";
    this._id = this.constructor.generateId();
    this._isLoading = false;
    log2(`\u0421\u043E\u0437\u0434\u0430\u043D \u044D\u043A\u0437\u0435\u043C\u043F\u043B\u044F\u0440 ${this.constructor.name} \u0441 ID: ${this._id}`);
  }
  //  
  #templateImported = false;
  #isReady = false;
  #isQuantum = false;
  /**
   *      .
   * @param {Object} errorData -   .
   * @param {string} errorData.componentName -  ,   .
   * @param {string} errorData.source -   (, 'controller', 'actions', 'render').
   * @param {string} errorData.message -   .
   * @param {any} [errorData.details] -   (,  , ).
   * @param {number} [errorData.timestamp] -   .
   */
  static addError(errorData) {
    const errorEntry = {
      timestamp: Date.now(),
      ...errorData
    };
    _BaseComponent.errorStore.unshift(errorEntry);
    if (_BaseComponent.errorStore.length > _BaseComponent.ERROR_STORE_LIMIT) {
      _BaseComponent.errorStore = _BaseComponent.errorStore.slice(0, _BaseComponent.ERROR_STORE_LIMIT);
    }
    console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0430 \u0432 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435. \u0412\u0441\u0435\u0433\u043E \u0437\u0430\u043F\u0438\u0441\u0435\u0439: ${_BaseComponent.errorStore.length}`, errorEntry);
  }
  /**
   *     .
   * @returns {Array}      .
   */
  static getErrors() {
    return [..._BaseComponent.errorStore];
  }
  /**
   *   .
   */
  static clearErrors() {
    _BaseComponent.errorStore = [];
    log2("\u0425\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043E\u0448\u0438\u0431\u043E\u043A \u043E\u0447\u0438\u0449\u0435\u043D\u043E.");
  }
  /**
   *    .
   * @param {Object} options -   .
   * @param {string} options.title -   .
   * @param {string} options.content - HTML-  .
   * @param {Array<Object>} [options.buttons] -   .
   *    : { text: string, type: string (e.g., 'primary', 'secondary'), action: Function }
   * @param {boolean} [options.closeOnBackdropClick=true] -       .
   * @returns {Promise<void>} - Promise,     .
   */
  showModal({ title = "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F", content = "", buttons = [], closeOnBackdropClick = true } = {}) {
    return new Promise((resolve) => {
      const modalBackdrop = document.createElement("div");
      modalBackdrop.className = "yato-modal-backdrop";
      const currentModal = document.body.querySelector(".yato-modal-backdrop");
      if (currentModal) {
        currentModal.remove();
      }
      const closeModal = /* @__PURE__ */ __name(() => {
        if (modalBackdrop.parentNode) {
          modalBackdrop.parentNode.removeChild(modalBackdrop);
        }
        resolve();
      }, "closeModal");
      const modalWrapper = document.createElement("div");
      modalWrapper.className = "yato-modal-wrapper";
      modalWrapper.setAttribute("role", "dialog");
      modalWrapper.setAttribute("aria-modal", "true");
      modalWrapper.setAttribute("aria-labelledby", "yato-modal-title");
      const modalContent = document.createElement("div");
      modalContent.className = "yato-modal-content";
      const modalHeader = document.createElement("div");
      modalHeader.className = "yato-modal-header";
      const modalTitle = document.createElement("h3");
      modalTitle.id = "yato-modal-title";
      modalTitle.className = "yato-modal-title";
      modalTitle.textContent = title;
      const modalCloseButton = document.createElement("button");
      modalCloseButton.type = "button";
      modalCloseButton.className = "yato-modal-close-button";
      modalCloseButton.setAttribute("aria-label", "\u0417\u0430\u043A\u0440\u044B\u0442\u044C");
      modalCloseButton.innerHTML = "&times;";
      const modalBody = document.createElement("div");
      modalBody.className = "yato-modal-body";
      modalBody.innerHTML = content;
      const modalFooter = document.createElement("div");
      modalFooter.className = "yato-modal-footer";
      modalHeader.appendChild(modalTitle);
      modalHeader.appendChild(modalCloseButton);
      modalContent.appendChild(modalHeader);
      modalContent.appendChild(modalBody);
      if (buttons && buttons.length > 0) {
        buttons.forEach((btnConfig) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = `yato-button ${btnConfig.type ? btnConfig.type : "secondary"}`;
          button.textContent = btnConfig.text || "OK";
          button.onclick = () => {
            if (typeof btnConfig.action === "function") {
              try {
                btnConfig.action();
              } catch (e2) {
                console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0432 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0435 \u043A\u043D\u043E\u043F\u043A\u0438 \u043C\u043E\u0434\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u043E\u043A\u043D\u0430:", e2);
              }
            }
            closeModal();
          };
          modalFooter.appendChild(button);
        });
        modalContent.appendChild(modalFooter);
      } else {
        const defaultCloseButton = document.createElement("button");
        defaultCloseButton.type = "button";
        defaultCloseButton.className = "yato-button primary";
        defaultCloseButton.textContent = "\u0417\u0430\u043A\u0440\u044B\u0442\u044C";
        defaultCloseButton.onclick = closeModal;
        modalFooter.appendChild(defaultCloseButton);
        modalContent.appendChild(modalFooter);
      }
      modalWrapper.appendChild(modalContent);
      modalBackdrop.appendChild(modalWrapper);
      modalCloseButton.onclick = closeModal;
      if (closeOnBackdropClick !== false) {
        modalBackdrop.onclick = (event) => {
          if (event.target === modalBackdrop) {
            closeModal();
          }
        };
      }
      const handleKeyDown = /* @__PURE__ */ __name((event) => {
        if (event.key === "Escape") {
          closeModal();
          document.removeEventListener("keydown", handleKeyDown);
        }
      }, "handleKeyDown");
      document.addEventListener("keydown", handleKeyDown);
      document.body.appendChild(modalBackdrop);
    });
  }
  static generateId() {
    return "yato-" + Math.random().toString(36).substr(2, 9);
  }
  /**
   * @private
   */
  async connectedCallback() {
    try {
      log2(`${this.constructor.name} \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u043A DOM.`);
      await this.#initComponent(this.state);
      log2(`${this.constructor.name} \u0433\u043E\u0442\u043E\u0432.`);
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0432 connectedCallback \u0434\u043B\u044F ${this.constructor.name}:`, error);
      await this.#render({ error: error.message });
    }
  }
  /**
   * @private
   */
  async disconnectedCallback() {
    log2(`${this.constructor.name} \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D \u043E\u0442 DOM.`);
    await this._componentDisconnected();
  }
  /**
   * @private
   */
  async adoptedCallback() {
    log2(`${this.constructor.name} \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D \u0432 \u043D\u043E\u0432\u044B\u0439 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442.`);
    await this._componentAdopted();
  }
  /**
   * @private
   */
  async attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;
    if (this.#templateImported) {
      await this._componentAttributeChanged(name, oldValue, newValue);
      log2(`\u0410\u0442\u0440\u0438\u0431\u0443\u0442 ${name} \u0438\u0437\u043C\u0435\u043D\u0438\u043B\u0441\u044F \u0441 '${oldValue}' \u043D\u0430 '${newValue}'.`);
    }
  }
  async #initComponent(state) {
    const type = this.dataset.type;
    if (!exclusion.includes(this.tagName)) {
      this.#templateImported = true;
      if (type !== "server" && !this.hasAttribute("data-no-render")) {
        await this.#loadComponentStyles();
        await this.showSkeleton();
      }
    }
    await this._componentReady();
    await this.#registerComponent();
  }
  async #loadComponentStyles() {
    try {
      const componentTagName2 = this.constructor.tagName || this.tagName.toLowerCase();
      const cssModule = await Promise.resolve().then(() => (init_virtual_css(), virtual_css_exports));
      const componentCSS = cssModule.getCSSForComponent(componentTagName2);
      if (componentCSS) {
        const style = document.createElement("style");
        style.textContent = componentCSS;
        this.shadowRoot.appendChild(style);
        log2(`\u0421\u0442\u0438\u043B\u0438 \u0434\u043B\u044F ${this.constructor.name} \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B \u0438\u0437 \u0431\u0430\u043D\u0434\u043B\u0430`);
      } else {
        console.warn(`CSS \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 ${componentTagName2} \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0432 \u0431\u0430\u043D\u0434\u043B\u0435`);
      }
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0441\u0442\u0438\u043B\u0435\u0439 \u0434\u043B\u044F ${this.constructor.name}:`, error);
      try {
        let cssPath = new URL(`../components/${componentTagName}/css/index.css`, import.meta.url);
        const style = document.createElement("style");
        style.textContent = `@import url('.${cssPath.pathname}');`;
        this.shadowRoot.appendChild(style);
        log2(`\u0421\u0442\u0438\u043B\u0438 \u0434\u043B\u044F ${this.constructor.name} \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B \u0447\u0435\u0440\u0435\u0437 fallback`);
      } catch (fallbackError) {
        console.error(`Fallback \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0441\u0442\u0438\u043B\u0435\u0439 \u0442\u0430\u043A\u0436\u0435 \u043D\u0435 \u0443\u0434\u0430\u043B\u0430\u0441\u044C:`, fallbackError);
      }
    }
  }
  //   showSkeleton :
  async showSkeleton() {
    this._isLoading = true;
    const container = this.shadowRoot.querySelector("#root") || document.createElement("div");
    container.id = "root";
    container.classList.add("skeleton-container");
    if (!this.shadowRoot.querySelector("#skeleton-styles")) {
      const style = document.createElement("style");
      style.id = "skeleton-styles";
      style.textContent = `
                /* \u0423\u043D\u0438\u0432\u0435\u0440\u0441\u0430\u043B\u044C\u043D\u044B\u0435 \u0441\u0442\u0438\u043B\u0438 \u0441\u043A\u0435\u043B\u0435\u0442\u043E\u043D\u0430 \u0434\u043B\u044F \u0432\u0441\u0435\u0445 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u043E\u0432 */
                :host {
                    position: relative;
                }
                .skeleton-container * {
                    pointer-events: none !important;
                    user-select: none !important;
                }
                
                .skeleton-container :not(style, script, link, meta) {
                    color: transparent !important;
                    background-size: 200% 100% !important;
                    animation: skeleton-loading 1.5s infinite !important;
                    border-color: transparent !important;
                    box-shadow: none !important;
                }
                
                .skeleton-container :not(style, script, link, meta)::before {
                    content: "" !important;
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    bottom: 0 !important;
                    background: inherit !important;
                    border-radius: inherit !important;
                    z-index: 1 !important;
                }
                
                @keyframes skeleton-loading {
                    0% { background-position: -200% 0; }
                    100% { background-position: 200% 0; }
                }
                
                /* \u0422\u0435\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430 \u0434\u043B\u044F \u0441\u043A\u0435\u043B\u0435\u0442\u043E\u043D\u0430 */
                [data-theme="dark"] .skeleton-container :not(style, script, link, meta) {
                    background: linear-gradient(90deg, #2d3748 25%, #4a5568 50%, #2d3748 75%) !important;
                }
                
                /* \u0421\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u044B \u0444\u043E\u0440\u043C */
                .skeleton-container form,
                .skeleton-container input,
                .skeleton-container textarea,
                .skeleton-container select,
                .skeleton-container button {
                    opacity: 1 !important;
                    visibility: visible !important;
                    display: block !important;
                }
                
                /* \u041A\u0440\u0443\u0433\u043B\u044B\u0435 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B */
                .skeleton-container img,
                .skeleton-container [class*="avatar"],
                .skeleton-container [class*="circle"] {
                    border-radius: 50% !important;
                }
        `;
      this.shadowRoot.appendChild(style);
    }
  }
  async hideSkeleton() {
    this._isLoading = false;
    const container = this.shadowRoot.querySelector("#root");
    if (container) {
      container.classList.remove("skeleton-container");
    }
  }
  /**
   * ,   -
   * @returns {boolean}
   */
  isLoading() {
    return this._isLoading;
  }
  //   BaseComponent   fullRender
  async fullRender(state = {}) {
    try {
      await this.#render({
        state,
        context: this
      });
      this.#isReady = true;
      log2(`\u041F\u043E\u043B\u043D\u044B\u0439 \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D \u0434\u043B\u044F ${this.constructor.name}`);
      return true;
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u043E\u043B\u043D\u043E\u0433\u043E \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433\u0430:`, error);
      return false;
    }
  }
  /**
   *       
   * @param {Object} options -  
   * @param {string} options.partName -    (  'defaultTemplate')
   * @param {Object} options.state -   
   * @param {string} options.selector - CSS   
   * @param {string} [options.method='innerHTML'] -  : 'innerHTML', 'append', 'prepend', 'before', 'after'
   * @returns {Promise<boolean>}  
   */
  async renderPart({ partName = "defaultTemplate", state = {}, selector, method = "innerHTML" } = {}) {
    try {
      if (!this._templateMethods || !this._templateMethods[partName]) {
        console.error(`\u041C\u0435\u0442\u043E\u0434 \u0448\u0430\u0431\u043B\u043E\u043D\u0430 '${partName}' \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0432 ${this.constructor.name}`);
        return false;
      }
      if (!selector) {
        console.error(`\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D \u0441\u0435\u043B\u0435\u043A\u0442\u043E\u0440 \u0434\u043B\u044F \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433\u0430 \u0447\u0430\u0441\u0442\u0438 '${partName}'`);
        return false;
      }
      const targetElement = this.shadowRoot.querySelector(selector);
      if (!targetElement) {
        console.error(`\u042D\u043B\u0435\u043C\u0435\u043D\u0442 \u0441 \u0441\u0435\u043B\u0435\u043A\u0442\u043E\u0440\u043E\u043C '${selector}' \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D`);
        return false;
      }
      const htmlContent = await this._templateMethods[partName]({
        state,
        context: this
      });
      switch (method) {
        case "innerHTML":
          targetElement.innerHTML = htmlContent;
          break;
        case "append":
          targetElement.insertAdjacentHTML("beforeend", htmlContent);
          break;
        case "prepend":
          targetElement.insertAdjacentHTML("afterbegin", htmlContent);
          break;
        case "before":
          targetElement.insertAdjacentHTML("beforebegin", htmlContent);
          break;
        case "after":
          targetElement.insertAdjacentHTML("afterend", htmlContent);
          break;
        default:
          console.error(`\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u043C\u0435\u0442\u043E\u0434 \u0432\u0441\u0442\u0430\u0432\u043A\u0438: ${method}`);
          return false;
      }
      log2(`\u0427\u0430\u0441\u0442\u044C '${partName}' \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u0440\u0435\u043D\u0434\u0435\u0440\u0435\u043D\u0430 \u0432 '${selector}' \u043C\u0435\u0442\u043E\u0434\u043E\u043C '${method}'`);
      await this.#waitForDOMUpdate();
      await this.#setupEventListeners();
      return true;
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433\u0430 \u0447\u0430\u0441\u0442\u0438 '${partName}':`, error);
      this.addError({
        componentName: this.constructor.name,
        source: "renderPart",
        message: `\u041E\u0448\u0438\u0431\u043A\u0430 \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433\u0430 \u0447\u0430\u0441\u0442\u0438 ${partName}`,
        details: error
      });
      return false;
    }
  }
  /**
   *      
   * @param {Object} options -  
   * @param {string} options.selector - CSS   
   * @param {string|number|boolean} options.value -   
   * @param {string} [options.property='textContent'] -    :
   *   - 'textContent'   
   *   - 'innerHTML'  HTML 
   *   - 'value'  input, textarea, select
   *   - 'checked'  checkbox
   *   - 'src'  
   *   - 'href'  
   *   - 'className'  
   *   - 'style'   ( )
   *   -    
   * @param {string} [options.action='set'] - : 'set', 'append', 'prepend', 'toggle', 'add', 'remove'
   * @returns {Promise<boolean>}  
   */
  async updateElement({ selector, value, property = "textContent", action = "set" } = {}) {
    try {
      if (!selector) {
        console.warn(`[\u041A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442] \u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D \u0441\u0435\u043B\u0435\u043A\u0442\u043E\u0440 \u0434\u043B\u044F \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430`);
        return false;
      }
      const targetElement = this.shadowRoot.querySelector(selector);
      if (!targetElement) {
        console.warn(`[\u041A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442] \u042D\u043B\u0435\u043C\u0435\u043D\u0442 \u0441 \u0441\u0435\u043B\u0435\u043A\u0442\u043E\u0440\u043E\u043C '${selector}' \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D`);
        return false;
      }
      if (selector === ".network-addresses") {
        console.log("--------------------- targetElement ----------------------------", action, targetElement);
      }
      switch (action) {
        case "set":
          if (property === "style" && typeof value === "object") {
            Object.assign(targetElement.style, value);
          } else if (property === "className" && typeof value === "string") {
            targetElement.className = value;
          } else if (property === "dataset.theme" && typeof value === "string") {
            targetElement.dataset.theme = value;
          } else {
            targetElement[property] = value;
          }
          break;
        case "append":
          if (property === "innerHTML" || property === "textContent") {
            targetElement[property] += value;
          } else if (property === "value") {
            targetElement.value += String(value);
          }
          break;
        case "prepend":
          if (property === "innerHTML" || property === "textContent") {
            targetElement[property] = value + targetElement[property];
          } else if (property === "value") {
            targetElement.value = String(value) + targetElement.value;
          }
          break;
        case "toggle":
          if (property === "checked" || property === "disabled" || property === "hidden") {
            targetElement[property] = !targetElement[property];
          } else if (property === "className") {
            targetElement.classList.toggle(String(value));
          }
          break;
        case "add":
          if (property === "className") {
            targetElement.classList.add(String(value));
          }
          break;
        case "remove":
          if (property === "className") {
            targetElement.classList.remove(String(value));
          }
          break;
        default:
          console.warn(`[\u041A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442] \u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435: ${action}`);
          return false;
      }
      return true;
    } catch (error) {
      console.error(`[\u041A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442] \u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430 '${selector}':`, error);
      this.addError({
        componentName: this.constructor.name,
        source: "updateElement",
        message: `\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430 ${selector}`,
        details: error
      });
      return false;
    }
  }
  async #render({ partName = "defaultTemplate", state = {}, selector = "*" } = {}) {
    try {
      if (this._templateMethods) {
        const storedState = this.state || {};
        const mergedState = { ...storedState, ...state };
        const rootContainer = document.createElement("div");
        if (!this._templateMethods[partName]) {
          partName = "default";
        }
        rootContainer.insertAdjacentHTML("beforeend", await this._templateMethods[partName]({
          state: mergedState,
          context: this
        }));
        rootContainer.id = "root";
        if (selector === "*") {
          const rootContainerExist = this.shadowRoot.querySelector("#root");
          if (rootContainerExist) {
            rootContainerExist.remove();
          }
          this.shadowRoot.appendChild(rootContainer);
        } else {
          const rootContainerExist = this.shadowRoot.querySelector(selector);
          rootContainerExist.innerHTML = "";
          rootContainerExist.appendChild(rootContainer);
        }
        await this.#waitForDOMUpdate();
        await this.#setupEventListeners();
        await this.hideSkeleton();
        log2(`${this.constructor.name} \u043E\u0442\u0440\u0435\u043D\u0434\u0435\u0440\u0435\u043D \u0441 \u0441\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0435\u043C:`, mergedState);
      } else {
        console.error(`${this.constructor.name} \u0442\u0435\u043C\u043F\u043B\u0435\u0439\u0442 \u043D\u0435 \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D`);
      }
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433\u0430 \u0434\u043B\u044F ${this.constructor.name}:`, error);
      this.shadowRoot.innerHTML = `<p style="color:red;">\u041E\u0448\u0438\u0431\u043A\u0430 \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433\u0430: ${error.message}</p>`;
    }
  }
  async #waitForDOMUpdate(timeout = 100) {
    return new Promise((resolve) => {
      const rafId = requestAnimationFrame(() => {
        clearTimeout(timeoutId);
        resolve();
      });
      const timeoutId = setTimeout(() => {
        cancelAnimationFrame(rafId);
        resolve();
      }, timeout);
      return () => {
        cancelAnimationFrame(rafId);
        clearTimeout(timeoutId);
      };
    });
  }
  async #setupEventListeners() {
    if (this?._controller?.destroy) {
      this._controller.destroy();
    }
    if (this?._controller?.init) {
      this._controller.init();
    }
    log2(`${this.constructor.name} \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u043E\u0432 \u0441\u043E\u0431\u044B\u0442\u0438\u0439 (\u0431\u0430\u0437\u043E\u0432\u0430\u044F \u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F).`);
  }
  async #registerComponent() {
    try {
      if (!this.id) {
        console.error("\u042F\u0422\u041E-ID1: \u041A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 \u0436\u0435\u043B\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0438\u043C\u0435\u0435\u0442 ID \u0434\u043B\u044F \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438");
        throw new Error("\u042F\u0422\u041E-ID1: \u041A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 \u0442\u0440\u0435\u0431\u0443\u0435\u0442 ID");
        return;
      }
      const key = `${this.tagName.toLowerCase()}:${this.id}`;
      _BaseComponent.pendingRequests.set(key, this);
      if (this.tagName.toLowerCase() === "navigation-manager" || this.tagName.toLowerCase() === "navigation-sections") {
        log2(`${this.constructor.name} \u0441 ID ${this.id} \u0437\u0430\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0438\u0440\u043E\u0432\u0430\u043D.`);
      }
    } catch (e2) {
      console.error(e2.toString(), this.tagName.toLowerCase());
    }
  }
  /**
   *    ,   ,  .
   * @param {string} tagName -  .
   * @param {string} id -  .
   * @param {number} timeout -   .
   * @returns {Promise<BaseComponent|null>}
   * @static
   */
  static async getComponentAsync(tagName, id, timeout = 5e3) {
    const key = `${tagName}:${id}`;
    let component = _BaseComponent.pendingRequests.get(key);
    if (component) {
      return Promise.resolve(component);
    }
    return new Promise((resolve, reject) => {
      let resolved = false;
      const timeoutId = setTimeout(() => {
        if (!resolved) {
          resolved = true;
          console.error(`\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 '${key}'.`);
          resolve(null);
        }
      }, timeout);
      const checkComponent = /* @__PURE__ */ __name(() => {
        if (resolved) return;
        component = _BaseComponent.pendingRequests.get(key);
        if (component) {
          clearTimeout(timeoutId);
          resolved = true;
          log2(`\u0410\u0441\u0438\u043D\u0445\u0440\u043E\u043D\u043D\u043E \u043D\u0430\u0439\u0434\u0435\u043D \u0437\u0430\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 '${key}'.`);
          resolve(component);
        } else {
          setTimeout(checkComponent, _BaseComponent.MAX_POLLING_INTERVAL);
        }
      }, "checkComponent");
      checkComponent();
    });
  }
  async postMessage(event) {
    log2(`\u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u0434\u043B\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 ${this.constructor.name} \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043D\u043E.`);
  }
  async _componentReady() {
    log2(`${this.constructor.name} \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 \u0433\u043E\u0442\u043E\u0432 (\u0431\u0430\u0437\u043E\u0432\u0430\u044F \u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F).`);
  }
  async _componentAttributeChanged() {
    log2(`${this.constructor.name} \u0410\u0442\u0440\u0438\u0431\u0443\u0442\u044B \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u044B (\u0431\u0430\u0437\u043E\u0432\u0430\u044F \u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F).`);
  }
  async _componentAdopted() {
    log2(`${this.constructor.name} \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D (\u0431\u0430\u0437\u043E\u0432\u0430\u044F \u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F).`);
  }
  async _componentDisconnected() {
    log2(`${this.constructor.name} \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D (\u0431\u0430\u0437\u043E\u0432\u0430\u044F \u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F).`);
  }
};

// packages/frontend/src/components/api-service/template/index.mjs
var template_exports = {};
__export(template_exports, {
  defaultTemplate: () => defaultTemplate
});
function defaultTemplate({ state = {} }) {
  return `
        <!-- API Service Component -->
        <div style="display: none;">
            API Service initialized
        </div>
    `;
}
__name(defaultTemplate, "defaultTemplate");

// packages/frontend/src/components/api-service/index.mjs
var ApiService = class extends BaseComponent {
  static {
    __name(this, "ApiService");
  }
  static observedAttributes = [];
  constructor() {
    super();
    this._templateMethods = template_exports;
    this.state = {
      baseURL: "http://localhost:3012/api",
      token: null
    };
  }
  async _componentReady() {
    this.state.token = localStorage.getItem("guss-token");
    return true;
  }
  setToken(token) {
    this.state.token = token;
    localStorage.setItem("guss-token", token);
  }
  removeToken() {
    this.state.token = null;
    localStorage.removeItem("guss-token");
  }
  async request(endpoint, options = {}) {
    const url = `${this.state.baseURL}${endpoint}`;
    const headers = {
      "Content-Type": "application/json",
      ...options.headers
    };
    const config = {
      headers,
      ...options
    };
    if (this.state.token) {
      config.headers.Authorization = `Bearer ${this.state.token}`;
    }
    if (!options.body && options.method === "POST") {
      delete config.headers["Content-Type"];
    }
    try {
      const response = await fetch(url, config);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.error("API request failed:", error);
      throw error;
    }
  }
  //    API endpoints
  async login(username, password) {
    return await this.request("/auth/login", {
      method: "POST",
      body: JSON.stringify({ username, password })
    });
  }
  async logout() {
    try {
      await this.request("/auth/logout", {
        method: "POST",
        body: JSON.stringify({})
        //    null
      });
    } finally {
      this.removeToken();
    }
  }
  async getProfile() {
    return await this.request("/auth/me");
  }
  async getRounds() {
    return await this.request("/rounds");
  }
  async getRound(id) {
    return await this.request(`/rounds/${id}`);
  }
  async createRound() {
    return await this.request("/rounds", {
      method: "POST"
    });
  }
  async tapRound(roundId) {
    return await this.request(`/rounds/${roundId}/tap`, {
      method: "POST"
    });
  }
};
if (!customElements.get("api-service")) {
  customElements.define("api-service", ApiService);
}

// packages/frontend/src/components/navigation-manager/template/index.mjs
var template_exports2 = {};
__export(template_exports2, {
  defaultTemplate: () => defaultTemplate2
});
function defaultTemplate2({ state = {} }) {
  const pages = {
    "login": '<login-page id="login-page"></login-page>',
    "rounds-list": '<rounds-list id="rounds-list"></rounds-list>',
    "round-page": '<round-page id="round-page"></round-page>'
  };
  console.log("Navigation Manager State:", state);
  return `
        <div id="app-container">
            ${state.user ? `
                <div class="user-header">
                    <div class="user-info">
                        <span class="username">\u{1F464} ${state.user.username}</span>
                        <span class="user-role">(${state.user.role})</span>
                    </div>
                    <button class="logout-btn" title="\u0412\u044B\u0439\u0442\u0438 (Escape)">
                        \u{1F6AA} \u0412\u044B\u0439\u0442\u0438
                    </button>
                </div>
            ` : ""}
            ${pages[state.currentPage] || pages.login}
        </div>
    `;
}
__name(defaultTemplate2, "defaultTemplate");

// packages/frontend/src/components/navigation-manager/controller/index.mjs
var controller = /* @__PURE__ */ __name((context2) => {
  let eventListeners = [];
  const addEventListener = /* @__PURE__ */ __name((element, event, handler) => {
    element.addEventListener(event, handler);
    eventListeners.push({ element, event, handler });
  }, "addEventListener");
  return {
    async init() {
      addEventListener(context2.shadowRoot, "click", (e2) => {
        if (e2.target.classList.contains("logout-btn")) {
          context2._actions.handleLogout();
        }
      });
      addEventListener(context2.shadowRoot, "component-navigate", (e2) => {
        const { page } = e2.detail;
        context2.navigateTo(page);
      });
      addEventListener(context2.shadowRoot, "user-updated", (e2) => {
        const { user } = e2.detail;
        context2.setUser(user);
      });
      addEventListener(window, "storage", (e2) => {
        if (e2.key === "guss-user") {
          context2._actions.handleStorageChange(e2);
        }
      });
      addEventListener(context2, "post-message", (e2) => {
        context2._actions.handlePostMessage(e2.detail);
      });
      addEventListener(document, "keydown", (e2) => {
        if (e2.key === "Escape" && context2.state.user) {
          context2._actions.handleLogout();
        }
      });
      addEventListener(window, "global-logout", () => {
        context2._actions.handleLogout();
      });
    },
    async destroy() {
      eventListeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      eventListeners = [];
    }
  };
}, "controller");

// packages/frontend/src/components/navigation-manager/actions/index.mjs
async function createActions(context2) {
  return {
    handleNavigation: handleNavigation.bind(context2),
    handleUserUpdate: handleUserUpdate.bind(context2),
    handleLogout: handleLogout.bind(context2),
    handleStorageChange: handleStorageChange.bind(context2),
    handlePostMessage: handlePostMessage.bind(context2),
    stopAllComponents: stopAllComponents.bind(context2)
  };
}
__name(createActions, "createActions");
async function handleNavigation(page) {
  this.state.currentPage = page;
  await this.fullRender(this.state);
}
__name(handleNavigation, "handleNavigation");
async function handleUserUpdate(user) {
  this.state.user = user;
  await this.fullRender(this.state);
}
__name(handleUserUpdate, "handleUserUpdate");
async function handleLogout() {
  try {
    console.log("\u{1F504} Initiating logout process...");
    let confirmed = false;
    await this.showModal({
      title: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u0435 \u0432\u044B\u0445\u043E\u0434\u0430",
      content: "\u0412\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0432\u044B\u0439\u0442\u0438 \u0438\u0437 \u0441\u0438\u0441\u0442\u0435\u043C\u044B?",
      buttons: [
        {
          text: "\u041E\u0442\u043C\u0435\u043D\u0430",
          type: "secondary",
          action: /* @__PURE__ */ __name(() => console.log("Logout cancelled"), "action")
        },
        {
          text: "\u0412\u044B\u0439\u0442\u0438",
          type: "primary",
          action: /* @__PURE__ */ __name(() => (console.log("Logout confirmed"), confirmed = true), "action")
        }
      ]
    });
    console.log("--------------------------------", confirmed);
    if (!confirmed) {
      console.log("\u274C Logout cancelled by user");
      return;
    }
    await this.stopAllComponents();
    const stateManager = await this.getComponentAsync("state-manager", "state-manager");
    if (stateManager) {
      console.log("\u{1F510} Calling state manager logout...");
      await stateManager.logout();
      this.state.user = null;
      this.state.currentPage = "login";
      await this.fullRender(this.state);
      console.log("\u2705 Logout completed successfully");
    } else {
      console.error("\u274C State manager not found during logout");
      throw new Error("State manager not available");
    }
  } catch (error) {
    console.error("\u274C Logout error:", error);
    await this.showModal({
      title: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0432\u044B\u0445\u043E\u0434\u0430",
      content: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0432\u044B\u0439\u0442\u0438 \u0438\u0437 \u0441\u0438\u0441\u0442\u0435\u043C\u044B: ${error.message}`,
      buttons: [{
        text: "OK",
        type: "primary"
      }]
    });
  }
}
__name(handleLogout, "handleLogout");
async function handleStorageChange(event) {
  if (event.key === "guss-user" && !event.newValue) {
    console.log("\u{1F504} Storage change detected - logging out");
    await this.handleLogout();
  }
}
__name(handleStorageChange, "handleStorageChange");
async function handlePostMessage(message) {
  console.log("\u{1F4E8} Navigation manager received message:", message);
  if (message.type === "LOGOUT_REQUEST") {
    await this.handleLogout();
  }
  if (message.type === "NAVIGATE_TO") {
    await this.navigateTo(message.payload.page);
  }
  if (message.type === "USER_UPDATED") {
    await this.setUser(message.payload.user);
  }
}
__name(handlePostMessage, "handlePostMessage");
async function stopAllComponents() {
  try {
    const roundsList = await this.getComponentAsync("rounds-list", "rounds-list");
    if (roundsList && roundsList.stopRefreshing) {
      roundsList.stopRefreshing();
      console.log("\u2705 Rounds list refreshing stopped");
    }
    console.log("\u2705 All components stopped");
  } catch (error) {
    console.error("Error stopping components:", error);
  }
}
__name(stopAllComponents, "stopAllComponents");

// packages/frontend/src/components/navigation-manager/index.mjs
var NavigationManager = class extends BaseComponent {
  static {
    __name(this, "NavigationManager");
  }
  static observedAttributes = ["current-page", "user"];
  constructor() {
    super();
    this._templateMethods = template_exports2;
    this.state = {
      currentPage: "login",
      user: null
    };
  }
  async _componentReady() {
    this._controller = await controller(this);
    this._actions = await createActions(this);
    await this.checkAuth();
    await this.fullRender(this.state);
    return true;
  }
  async checkAuth() {
    const stateManager = await this.getComponentAsync("state-manager", "state-manager");
    if (stateManager) {
      const user = await stateManager.getCurrentUser();
      if (user) {
        this.state.user = user;
        this.state.currentPage = "rounds-list";
        console.log("\u2705 User authenticated:", user.username);
      } else {
        console.log("\u{1F510} No authenticated user found");
      }
    }
  }
  async _componentAttributeChanged(name, oldValue, newValue) {
    if (name === "current-page" && newValue !== oldValue) {
      this.state.currentPage = newValue;
      await this.fullRender(this.state);
    }
  }
  async navigateTo(page) {
    if (this.state.currentPage !== page) {
      this.state.currentPage = page;
      await this.fullRender(this.state);
      console.log("\u{1F9ED} Navigated to:", page);
    }
  }
  async setUser(user) {
    this.state.user = user;
    await this.fullRender(this.state);
    console.log("\u{1F464} User updated:", user?.username || "null");
  }
  //     (    )
  async logout() {
    await this._actions.handleLogout();
  }
  //      
  async stopAllComponents() {
    await this._actions.stopAllComponents();
  }
};
if (!customElements.get("navigation-manager")) {
  customElements.define("navigation-manager", NavigationManager);
}

// packages/frontend/src/components/state-manager/template/index.mjs
var template_exports3 = {};
__export(template_exports3, {
  defaultTemplate: () => defaultTemplate3
});
function defaultTemplate3({ state = {} }) {
  return `
        <div class="state-manager">
            <!-- State Manager \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442 \u0432 \u0444\u043E\u043D\u043E\u0432\u043E\u043C \u0440\u0435\u0436\u0438\u043C\u0435 -->
        </div>
    `;
}
__name(defaultTemplate3, "defaultTemplate");

// packages/frontend/src/components/state-manager/index.mjs
var StateManager = class extends BaseComponent {
  static {
    __name(this, "StateManager");
  }
  static observedAttributes = [];
  constructor() {
    super();
    this._templateMethods = template_exports3;
    this.state = {
      currentUser: null,
      rounds: [],
      currentRound: null
    };
  }
  async _componentReady() {
    await this.checkAuth();
    return true;
  }
  async checkAuth() {
    try {
      const apiService = await this.getComponentAsync("api-service", "api-service");
      if (apiService && apiService.state.token) {
        const profile = await apiService.getProfile();
        this.state.currentUser = profile.user;
        return true;
      }
    } catch (error) {
      console.error("Auth check failed:", error);
      this.state.currentUser = null;
    }
    return false;
  }
  async login(username, password) {
    try {
      const apiService = await this.getComponentAsync("api-service", "api-service");
      const result = await apiService.login(username, password);
      apiService.setToken(result.token);
      this.state.currentUser = result.user;
      return { success: true, user: result.user };
    } catch (error) {
      console.error("Login failed:", error);
      return {
        success: false,
        error: error.message || "Login failed"
      };
    }
  }
  async logout() {
    try {
      const apiService = await this.getComponentAsync("api-service", "api-service");
      await apiService.logout();
    } catch (error) {
      console.error("Logout error:", error);
    } finally {
      this.state.currentUser = null;
    }
  }
  async getCurrentUser() {
    return this.state.currentUser;
  }
  async createRound() {
    try {
      const apiService = await this.getComponentAsync("api-service", "api-service");
      const round = await apiService.createRound();
      this.state.rounds.unshift(round);
      return round;
    } catch (error) {
      console.error("Create round failed:", error);
      throw error;
    }
  }
  async getRounds() {
    try {
      const apiService = await this.getComponentAsync("api-service", "api-service");
      const rounds = await apiService.getRounds();
      this.state.rounds = rounds;
      return rounds.map((round) => ({
        ...round,
        status: this.calculateRoundStatus(round)
      }));
    } catch (error) {
      console.error("Get rounds failed:", error);
      throw error;
    }
  }
  async getRound(id) {
    try {
      const apiService = await this.getComponentAsync("api-service", "api-service");
      const round = await apiService.getRound(id);
      round.status = this.calculateRoundStatus(round);
      return round;
    } catch (error) {
      console.error("Get round failed:", error);
      throw error;
    }
  }
  async tapRound(roundId, userId) {
    try {
      const apiService = await this.getComponentAsync("api-service", "api-service");
      const result = await apiService.tapRound(roundId);
      return result;
    } catch (error) {
      console.error("Tap failed:", error);
      throw error;
    }
  }
  calculateRoundStatus(round) {
    const now = /* @__PURE__ */ new Date();
    const start = new Date(round.start_date);
    const end = new Date(round.end_date);
    if (now < start) return "cooldown";
    if (now >= start && now <= end) return "active";
    return "finished";
  }
  generateId() {
    return "id-" + Math.random().toString(36).substr(2, 9);
  }
};
if (!customElements.get("state-manager")) {
  customElements.define("state-manager", StateManager);
}

// packages/frontend/src/components/login-page/template/index.mjs
var template_exports4 = {};
__export(template_exports4, {
  defaultTemplate: () => defaultTemplate4
});
function defaultTemplate4({ state = {} }) {
  return `
        <div class="login-container">
            <div class="login-card">
                <h2>\u0412\u041E\u0419\u0422\u0418</h2>
                <form>
                    <div class="form-group">
                        <label for="username">\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F:</label>
                        <input 
                            type="text" 
                            id="username" 
                            name="username" 
                            required
                            ${state.loading ? "disabled" : ""}
                        >
                    </div>
                    <div class="form-group">
                        <label for="password">\u041F\u0430\u0440\u043E\u043B\u044C:</label>
                        <input 
                            type="password" 
                            id="password" 
                            name="password" 
                            required
                            ${state.loading ? "disabled" : ""}
                        >
                    </div>
                    ${state.error ? `<div class="error-message">${state.error}</div>` : ""}
                    <button type="submit" class="login-btn" ${state.loading ? "disabled" : ""}>
                        ${state.loading ? "\u0412\u0445\u043E\u0434..." : "\u0412\u043E\u0439\u0442\u0438"}
                    </button>
                </form>
            </div>
        </div>
    `;
}
__name(defaultTemplate4, "defaultTemplate");

// packages/frontend/src/components/login-page/controller/index.mjs
var controller2 = /* @__PURE__ */ __name((context2) => {
  let eventListeners = [];
  const addEventListener = /* @__PURE__ */ __name((element, event, handler) => {
    element.addEventListener(event, handler);
    eventListeners.push({ element, event, handler });
  }, "addEventListener");
  return {
    async init() {
      const form = context2.shadowRoot.querySelector("form");
      if (form) {
        addEventListener(form, "submit", (e2) => {
          e2.preventDefault();
          context2._actions.handleSubmit(new FormData(form));
        });
      }
    },
    async destroy() {
      eventListeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      eventListeners = [];
    }
  };
}, "controller");

// packages/frontend/src/components/login-page/actions/index.mjs
async function createActions2(context2) {
  return {
    handleSubmit: handleSubmit.bind(context2)
  };
}
__name(createActions2, "createActions");
async function handleSubmit(formData) {
  const username = formData.get("username");
  const password = formData.get("password");
  if (!username || !password) {
    this.state.error = "\u0417\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u0432\u0441\u0435 \u043F\u043E\u043B\u044F";
    await this.fullRender(this.state);
    return;
  }
  this.state.loading = true;
  this.state.error = null;
  await this.fullRender(this.state);
  try {
    const stateManager = await this.getComponentAsync("state-manager", "state-manager");
    const navigationManager = await this.getComponentAsync("navigation-manager", "navigation-manager");
    if (stateManager && navigationManager) {
      const result = await stateManager.login(username, password);
      if (result.success) {
        await navigationManager.setUser(result.user);
        await navigationManager.navigateTo("rounds-list");
      } else {
        this.state.error = result.error;
        this.state.loading = false;
        await this.fullRender(this.state);
      }
    }
  } catch (error) {
    this.state.error = error.message || "\u041E\u0448\u0438\u0431\u043A\u0430 \u0432\u0445\u043E\u0434\u0430";
    this.state.loading = false;
    await this.fullRender(this.state);
  }
}
__name(handleSubmit, "handleSubmit");

// packages/frontend/src/components/login-page/index.mjs
var LoginPage = class extends BaseComponent {
  static {
    __name(this, "LoginPage");
  }
  static observedAttributes = [];
  constructor() {
    super();
    this._templateMethods = template_exports4;
    this.state = {
      error: null,
      loading: false
    };
  }
  async _componentReady() {
    this._controller = await controller2(this);
    this._actions = await createActions2(this);
    await this.fullRender(this.state);
    return true;
  }
};
if (!customElements.get("login-page")) {
  customElements.define("login-page", LoginPage);
}

// packages/frontend/src/components/rounds-list/template/index.mjs
var template_exports5 = {};
__export(template_exports5, {
  defaultTemplate: () => defaultTemplate5
});
function defaultTemplate5({ state = {} }) {
  return `
        <div class="rounds-list-container">
            <header class="page-header">
                <div class="header-content">
                    <h1>\u0421\u043F\u0438\u0441\u043E\u043A \u0420\u0410\u0423\u041D\u0414\u041E\u0412</h1>
                    ${state.lastUpdate ? `
                        <div class="last-update">
                            \u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E: ${formatTime(state.lastUpdate)}
                        </div>
                    ` : ""}
                </div>
                ${state.user ? `
                    <div class="user-info">
                        <span class="username">${state.user.username}</span>
                        <span class="user-role">(${state.user.role})</span>
                    </div>
                ` : ""}
            </header>

            ${state.user?.role === "admin" ? `
                <div class="actions-bar">
                    <button class="create-round-btn">
                        \u{1F3AF} \u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0440\u0430\u0443\u043D\u0434
                    </button>
                    <div class="polling-status">
                        <span class="status-indicator ${state.pollingEnabled ? "active" : "paused"}"></span>
                        ${state.pollingEnabled ? "\u0410\u0432\u0442\u043E\u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435" : "\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u043F\u0440\u0438\u043E\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u043E"}
                    </div>
                </div>
            ` : ""}

            <div class="rounds-grid" id="rounds-grid">
                ${state.loading ? `
                    <div class="loading-state">
                        <div class="spinner"></div>
                        <span>\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0440\u0430\u0443\u043D\u0434\u043E\u0432...</span>
                    </div>
                ` : state.error ? `
                    <div class="error-state">
                        <div class="error-icon">\u26A0\uFE0F</div>
                        <h3>\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438</h3>
                        <p>${state.error}</p>
                        <button class="retry-btn" onclick="this.getRootNode().host.retryLoading()">
                            \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C
                        </button>
                    </div>
                ` : state.rounds.length === 0 ? `
                    <div class="empty-state">
                        <div class="empty-icon">\u{1F3AF}</div>
                        <h3>\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0445 \u0440\u0430\u0443\u043D\u0434\u043E\u0432</h3>
                        <p>\u0421\u043E\u0437\u0434\u0430\u0439\u0442\u0435 \u043F\u0435\u0440\u0432\u044B\u0439 \u0440\u0430\u0443\u043D\u0434 \u0438\u043B\u0438 \u0434\u043E\u0436\u0434\u0438\u0442\u0435\u0441\u044C \u043D\u0430\u0447\u0430\u043B\u0430 \u043D\u043E\u0432\u043E\u0433\u043E</p>
                    </div>
                ` : state.rounds.map((round) => renderRoundCard(round)).join("")}
            </div>

            ${!state.loading && state.rounds.length > 0 ? `
                <div class="footer-info">
                    <div class="rounds-count">
                        \u0412\u0441\u0435\u0433\u043E \u0440\u0430\u0443\u043D\u0434\u043E\u0432: ${state.rounds.length}
                    </div>
                    <div class="active-rounds-count">
                        \u0410\u043A\u0442\u0438\u0432\u043D\u044B\u0445: ${state.rounds.filter((r2) => r2.status === "active").length}
                    </div>
                </div>
            ` : ""}
        </div>
    `;
}
__name(defaultTemplate5, "defaultTemplate");
function renderRoundCard(round) {
  const startDate = new Date(round.start_date);
  const endDate = new Date(round.end_date);
  return `
        <div class="round-card" 
             data-round-id="${round.id}"
             data-start-timestamp="${round.start_timestamp}"
             data-status="${round.status}"
             data-is-upcoming="${round.is_upcoming}"
             data-is-active="${round.is_active}"
             data-is-finished="${round.is_finished}">
            
            <div class="round-header">
                <span class="round-id">\u25CF Round ID: ${round.id.slice(0, 8)}...</span>
                <span class="round-duration">${round.duration} \u0441\u0435\u043A</span>
            </div>
            
            <div class="round-dates">
                <div class="date-row">
                    <span class="date-label">\u{1F4C5} \u041D\u0430\u0447\u0430\u043B\u043E:</span>
                    <span class="date-value start-date-value">
                        ${formatDateTime(startDate)}
                    </span>
                </div>
                <div class="date-row">
                    <span class="date-label">\u23F0 \u041A\u043E\u043D\u0435\u0446:</span>
                    <span class="date-value end-date-value">
                        ${formatDateTime(endDate)}
                    </span>
                </div>
            </div>
            
            <div class="round-divider"></div>
            
            <div class="round-stats">
                <div class="stat-row">
                    <span class="stat-label">\u041E\u0431\u0449\u0438\u0439 \u0441\u0447\u0435\u0442:</span>
                    <span class="stat-value">${round.total_score || 0}</span>
                </div>
                ${round.time_until_start > 0 ? `
                    <div class="stat-row">
                        <span class="stat-label">\u0414\u043E \u043D\u0430\u0447\u0430\u043B\u0430:</span>
                        <span class="stat-value countdown">
                            ${formatCountdown(round.time_until_start)}
                        </span>
                    </div>
                ` : ""}
                ${round.participants && round.participants.length > 0 ? `
                    <div class="stat-row">
                        <span class="stat-label">\u0423\u0447\u0430\u0441\u0442\u043D\u0438\u043A\u043E\u0432:</span>
                        <span class="stat-value">${round.participants.length}</span>
                    </div>
                ` : ""}
            </div>
            
            <div class="round-status ${getStatusClass(round.status)}">
                ${getStatusIcon(round.status)} ${getStatusText(round.status)}
            </div>

            ${round.winner ? `
                <div class="round-winner">
                    <span class="winner-label">\u{1F3C6} \u041F\u043E\u0431\u0435\u0434\u0438\u0442\u0435\u043B\u044C:</span>
                    <span class="winner-name">${round.winner.username} (${round.winner.score})</span>
                </div>
            ` : ""}
        </div>
    `;
}
__name(renderRoundCard, "renderRoundCard");
function formatDateTime(date) {
  return date.toLocaleDateString("ru-RU") + " " + date.toLocaleTimeString("ru-RU", {
    hour: "2-digit",
    minute: "2-digit"
  });
}
__name(formatDateTime, "formatDateTime");
function formatTime(date) {
  return date.toLocaleTimeString("ru-RU", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  });
}
__name(formatTime, "formatTime");
function formatCountdown(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const secs = seconds % 60;
  if (hours > 0) {
    return `${hours}\u0447 ${minutes.toString().padStart(2, "0")}\u043C`;
  } else if (minutes > 0) {
    return `${minutes}\u043C ${secs.toString().padStart(2, "0")}\u0441`;
  } else {
    return `${secs}\u0441`;
  }
}
__name(formatCountdown, "formatCountdown");
function getStatusText(status) {
  const statusMap = {
    "cooldown": "Cooldown",
    "active": "\u0410\u043A\u0442\u0438\u0432\u0435\u043D",
    "finished": "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D"
  };
  return statusMap[status] || status;
}
__name(getStatusText, "getStatusText");
function getStatusClass(status) {
  const classMap = {
    "cooldown": "status-cooldown",
    "active": "status-active",
    "finished": "status-finished"
  };
  return classMap[status] || "";
}
__name(getStatusClass, "getStatusClass");
function getStatusIcon(status) {
  const iconMap = {
    "cooldown": "\u23F1\uFE0F",
    "active": "\u{1F3AF}",
    "finished": "\u2705"
  };
  return iconMap[status] || "\u25CF";
}
__name(getStatusIcon, "getStatusIcon");

// packages/frontend/src/components/rounds-list/controller/index.mjs
var controller3 = /* @__PURE__ */ __name((context2) => {
  let eventListeners = [];
  let refreshInterval = null;
  let countdownIntervals = /* @__PURE__ */ new Map();
  const addEventListener = /* @__PURE__ */ __name((element, event, handler) => {
    element.addEventListener(event, handler);
    eventListeners.push({ element, event, handler });
  }, "addEventListener");
  const updateCountdowns = /* @__PURE__ */ __name(() => {
    const now = Date.now();
    const countdownElements = context2.shadowRoot.querySelectorAll(".countdown");
    countdownElements.forEach((element) => {
      const roundCard = element.closest(".round-card");
      if (!roundCard) return;
      const startTimestamp = parseInt(roundCard.getAttribute("data-start-timestamp"));
      const timeUntilStart = Math.max(0, startTimestamp - now);
      if (timeUntilStart > 0) {
        const seconds = Math.floor(timeUntilStart / 1e3);
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor(seconds % 3600 / 60);
        const secs = seconds % 60;
        let countdownText = "";
        if (hours > 0) {
          countdownText = `${hours}\u0447 ${minutes.toString().padStart(2, "0")}\u043C`;
        } else if (minutes > 0) {
          countdownText = `${minutes}\u043C ${secs.toString().padStart(2, "0")}\u0441`;
        } else {
          countdownText = `${secs}\u0441`;
        }
        element.textContent = countdownText;
        if (seconds <= 10) {
          element.classList.add("countdown-critical");
        } else {
          element.classList.remove("countdown-critical");
        }
      } else {
        element.textContent = "\u041D\u0430\u0447\u0430\u043B\u0441\u044F!";
        element.classList.add("countdown-finished");
        roundCard.setAttribute("data-is-upcoming", "false");
        roundCard.setAttribute("data-is-active", "true");
        const statusElement = roundCard.querySelector(".round-status");
        if (statusElement) {
          statusElement.className = "round-status status-active";
          statusElement.innerHTML = "\u{1F3AF} \u0410\u043A\u0442\u0438\u0432\u0435\u043D";
        }
      }
    });
  }, "updateCountdowns");
  const startCountdownUpdates = /* @__PURE__ */ __name(() => {
    countdownIntervals.forEach((interval) => clearInterval(interval));
    countdownIntervals.clear();
    const intervalId = setInterval(updateCountdowns, 1e3);
    countdownIntervals.set("main", intervalId);
    updateCountdowns();
  }, "startCountdownUpdates");
  const handleCreateRound2 = /* @__PURE__ */ __name(async (e2) => {
    e2.stopPropagation();
    try {
      await context2._actions.handleCreateRound();
      const notification = document.createElement("div");
      notification.className = "create-round-notification";
      notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">\u2705</span>
                    <span class="notification-text">\u041D\u043E\u0432\u044B\u0439 \u0440\u0430\u0443\u043D\u0434 \u0441\u043E\u0437\u0434\u0430\u043D \u0443\u0441\u043F\u0435\u0448\u043D\u043E!</span>
                </div>
            `;
      context2.shadowRoot.appendChild(notification);
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3e3);
    } catch (error) {
      console.error("Error creating round:", error);
    }
  }, "handleCreateRound");
  const handleRoundCardClick = /* @__PURE__ */ __name(async (e2) => {
    const roundCard = e2.target.closest(".round-card");
    if (!roundCard) return;
    const roundId = roundCard.getAttribute("data-round-id");
    if (!roundId) return;
    roundCard.classList.add("round-card-clicked");
    setTimeout(() => {
      roundCard.classList.remove("round-card-clicked");
    }, 200);
    try {
      await context2._actions.handleRoundClick(roundId);
    } catch (error) {
      console.error("Error navigating to round:", error);
    }
  }, "handleRoundCardClick");
  const handleRetryClick = /* @__PURE__ */ __name(async (e2) => {
    if (e2.target.classList.contains("retry-btn")) {
      e2.stopPropagation();
      const errorState = e2.target.closest(".error-state");
      if (errorState) {
        errorState.innerHTML = `
                    <div class="loading-state">
                        <div class="spinner"></div>
                        <span>\u041F\u043E\u0432\u0442\u043E\u0440\u043D\u0430\u044F \u043F\u043E\u043F\u044B\u0442\u043A\u0430...</span>
                    </div>
                `;
      }
      try {
        await context2.loadData();
      } catch (error) {
        console.error("Retry failed:", error);
      }
    }
  }, "handleRetryClick");
  const handleVisibilityChange = /* @__PURE__ */ __name(() => {
    if (document.hidden) {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
      countdownIntervals.forEach((interval) => clearInterval(interval));
      countdownIntervals.clear();
    } else {
      if (context2.state.pollingEnabled) {
        context2.startPolling();
      }
      startCountdownUpdates();
    }
  }, "handleVisibilityChange");
  const handleKeyPress2 = /* @__PURE__ */ __name((e2) => {
    if (e2.key === "Escape") {
    }
    if (e2.key === "Enter") {
      const activeElement = context2.shadowRoot.activeElement;
      if (activeElement && activeElement.classList.contains("round-card")) {
        handleRoundCardClick({ target: activeElement });
      }
    }
  }, "handleKeyPress");
  return {
    async init() {
      addEventListener(context2.shadowRoot, "click", (e2) => {
        if (e2.target.classList.contains("create-round-btn") || e2.target.closest(".create-round-btn")) {
          handleCreateRound2(e2);
        } else if (e2.target.classList.contains("round-card") || e2.target.closest(".round-card")) {
          handleRoundCardClick(e2);
        } else if (e2.target.classList.contains("retry-btn")) {
          handleRetryClick(e2);
        }
      });
      addEventListener(document, "keydown", handleKeyPress2);
      addEventListener(document, "visibilitychange", handleVisibilityChange);
      addEventListener(window, "online", () => {
        console.log("\u{1F7E2} Online - resuming updates");
        if (context2.state.pollingEnabled) {
          context2.startPolling();
        }
      });
      addEventListener(window, "offline", () => {
        console.log("\u{1F534} Offline - pausing updates");
        context2.stopPolling();
      });
      startCountdownUpdates();
      const style = document.createElement("style");
      style.textContent = `
                .create-round-notification {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: var(--success);
                    color: white;
                    padding: var(--space) var(--space-lg);
                    border-radius: var(--radius);
                    box-shadow: var(--shadow-lg);
                    z-index: 1000;
                    animation: slideInRight 0.3s ease-out;
                }
                
                .notification-content {
                    display: flex;
                    align-items: center;
                    gap: var(--space-sm);
                }
                
                .notification-icon {
                    font-size: 1.2em;
                }
                
                .notification-text {
                    font-weight: 500;
                }
                
                .round-card-clicked {
                    transform: scale(0.98) !important;
                    box-shadow: var(--shadow-sm) !important;
                }
                
                .countdown-critical {
                    color: var(--danger) !important;
                    font-weight: 700;
                    animation: pulse 0.5s infinite alternate;
                }
                
                .countdown-finished {
                    color: var(--success) !important;
                    font-weight: 700;
                }
                
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                @keyframes pulse {
                    from { opacity: 1; }
                    to { opacity: 0.5; }
                }
                
                /* \u0423\u043B\u0443\u0447\u0448\u0435\u043D\u043D\u044B\u0435 \u0441\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u0441\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0439 */
                .round-card[data-is-active="true"] {
                    border-left: 4px solid var(--success);
                    background: linear-gradient(90deg, var(--success-10) 0%, transparent 100%);
                }
                
                .round-card[data-is-upcoming="true"] {
                    border-left: 4px solid var(--warning);
                    background: linear-gradient(90deg, var(--warning-10) 0%, transparent 100%);
                }
                
                .round-card[data-is-finished="true"] {
                    border-left: 4px solid var(--surface-300);
                    background: linear-gradient(90deg, var(--surface-100) 0%, transparent 100%);
                }
            `;
      if (!context2.shadowRoot.querySelector("#dynamic-styles")) {
        style.id = "dynamic-styles";
        context2.shadowRoot.appendChild(style);
      }
      console.log("\u2705 RoundsList controller initialized");
    },
    async destroy() {
      eventListeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      eventListeners = [];
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
      countdownIntervals.forEach((interval) => clearInterval(interval));
      countdownIntervals.clear();
      const dynamicStyles = context2.shadowRoot.querySelector("#dynamic-styles");
      if (dynamicStyles) {
        dynamicStyles.remove();
      }
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("online", handleVisibilityChange);
      window.removeEventListener("offline", handleVisibilityChange);
      document.removeEventListener("keydown", handleKeyPress2);
      console.log("\u2705 RoundsList controller destroyed");
    }
  };
}, "controller");

// packages/frontend/src/components/rounds-list/actions/index.mjs
async function createActions3(context2) {
  return {
    handleCreateRound: handleCreateRound.bind(context2),
    handleRoundClick: handleRoundClick.bind(context2),
    updateRoundCard: updateRoundCard.bind(context2),
    retryLoading: retryLoading.bind(context2)
  };
}
__name(createActions3, "createActions");
async function handleCreateRound() {
  try {
    const [stateManager, navigationManager] = await Promise.all([
      this.getComponentAsync("state-manager", "state-manager"),
      this.getComponentAsync("navigation-manager", "navigation-manager")
    ]);
    if (!stateManager || !navigationManager) {
      throw new Error("Required components not found");
    }
    const round = await stateManager.createRound();
    await this.loadData();
    await navigationManager.navigateTo("round-page");
    const roundPage = await this.getComponentAsync("round-page", "round-page");
    if (roundPage) {
      await roundPage.setRound(round.id);
    }
    console.log("\u2705 Round created successfully:", round.id);
  } catch (error) {
    console.error("\u274C Create round error:", error);
    await this.showModal({
      title: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0440\u0430\u0443\u043D\u0434\u0430",
      content: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0437\u0434\u0430\u0442\u044C \u0440\u0430\u0443\u043D\u0434: ${error.message}`,
      buttons: [{ text: "OK", type: "primary" }]
    });
    this.addError({
      componentName: this.constructor.name,
      source: "handleCreateRound",
      message: "Failed to create round",
      details: error
    });
  }
}
__name(handleCreateRound, "handleCreateRound");
async function handleRoundClick(roundId, roundElement) {
  try {
    const roundStatus = roundElement?.getAttribute("data-status");
    const isFinished = roundElement?.getAttribute("data-is-finished") === "true";
    if (roundStatus === "finished" || isFinished) {
      console.log(`\u2139\uFE0F Round ${roundId} is finished, navigation blocked`);
      return;
    }
    const navigationManager = await this.getComponentAsync("navigation-manager", "navigation-manager");
    if (!navigationManager) {
      throw new Error("Navigation manager not found");
    }
    console.log("------------------- round-page --------------------------");
    await navigationManager.navigateTo("round-page");
    const roundPage = await this.getComponentAsync("round-page", "round-page");
    if (!roundPage) {
      throw new Error("Round page component not available");
    }
    await roundPage.setRound(roundId);
    console.log(`\u2705 Navigated to round: ${roundId} (status: ${roundStatus})`);
  } catch (error) {
    console.error("\u274C Navigation error:", error);
    await this.showModal({
      title: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043D\u0430\u0432\u0438\u0433\u0430\u0446\u0438\u0438",
      content: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0440\u0430\u0443\u043D\u0434\u0443: ${error.message}`,
      buttons: [{ text: "OK", type: "primary" }]
    });
    this.addError({
      componentName: this.constructor.name,
      source: "handleRoundClick",
      message: `Failed to navigate to round ${roundId}`,
      details: {
        error: error.message,
        roundId,
        roundStatus: roundElement?.getAttribute("data-status")
      }
    });
  }
}
__name(handleRoundClick, "handleRoundClick");
async function updateRoundCard(roundId, roundData) {
  const roundCard = this.shadowRoot.querySelector(`[data-round-id="${roundId}"]`);
  if (!roundCard) {
    console.warn(`Round card not found for ID: ${roundId}`);
    return false;
  }
  try {
    await this.updateElement({
      selector: `[data-round-id="${roundId}"]`,
      value: roundData.status,
      property: "data-status"
    });
    await this.updateElement({
      selector: `[data-round-id="${roundId}"]`,
      value: roundData.is_upcoming,
      property: "data-is-upcoming"
    });
    await this.updateElement({
      selector: `[data-round-id="${roundId}"]`,
      value: roundData.is_active,
      property: "data-is-active"
    });
    await this.updateElement({
      selector: `[data-round-id="${roundId}"]`,
      value: roundData.is_finished,
      property: "data-is-finished"
    });
    await this.updateElement({
      selector: `[data-round-id="${roundId}"]`,
      value: roundData.start_timestamp,
      property: "data-start-timestamp"
    });
    const statusClass = getStatusClass2(roundData.status);
    const statusText = getStatusText2(roundData.status);
    const statusIcon = getStatusIcon2(roundData.status);
    await this.updateElement({
      selector: `[data-round-id="${roundId}"] .round-status`,
      value: `${statusIcon} ${statusText}`,
      property: "textContent"
    });
    await this.updateElement({
      selector: `[data-round-id="${roundId}"] .round-status`,
      value: `round-status ${statusClass}`,
      property: "className"
    });
    const startDate = new Date(roundData.start_date);
    const endDate = new Date(roundData.end_date);
    await this.updateElement({
      selector: `[data-round-id="${roundId}"] .start-date-value`,
      value: formatDateTime2(startDate),
      property: "textContent"
    });
    await this.updateElement({
      selector: `[data-round-id="${roundId}"] .end-date-value`,
      value: formatDateTime2(endDate),
      property: "textContent"
    });
    await this.updateElement({
      selector: `[data-round-id="${roundId}"] .stat-value`,
      value: roundData.total_score || 0,
      property: "textContent"
    });
    if (roundData.time_until_start > 0) {
      const countdownElement = this.shadowRoot.querySelector(`[data-round-id="${roundId}"] .countdown`);
      if (countdownElement) {
        await this.updateElement({
          selector: `[data-round-id="${roundId}"] .countdown`,
          value: formatCountdown2(roundData.time_until_start),
          property: "textContent"
        });
      }
    }
    await this.updateElement({
      selector: `[data-round-id="${roundId}"] .round-duration`,
      value: `${roundData.duration} \u0441\u0435\u043A`,
      property: "textContent"
    });
    console.log(`\u2705 Round card ${roundId} updated efficiently`);
    return true;
  } catch (error) {
    console.error(`\u274C Error updating round card ${roundId}:`, error);
    this.addError({
      componentName: this.constructor.name,
      source: "updateRoundCard",
      message: `Failed to update round card ${roundId}`,
      details: error
    });
    return false;
  }
}
__name(updateRoundCard, "updateRoundCard");
async function retryLoading() {
  try {
    this.state.loading = true;
    this.state.error = null;
    await this.fullRender(this.state);
    await this.loadData();
    await this.fullRender(this.state);
    console.log("\u2705 Data reloaded successfully");
  } catch (error) {
    console.error("\u274C Retry loading error:", error);
    this.state.error = error.message || "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u043D\u043E\u0439 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0435";
    await this.fullRender(this.state);
    this.addError({
      componentName: this.constructor.name,
      source: "retryLoading",
      message: "Failed to retry loading",
      details: error
    });
  }
}
__name(retryLoading, "retryLoading");
function getStatusText2(status) {
  const statusMap = {
    "cooldown": "Cooldown",
    "active": "\u0410\u043A\u0442\u0438\u0432\u0435\u043D",
    "finished": "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D"
  };
  return statusMap[status] || status;
}
__name(getStatusText2, "getStatusText");
function getStatusClass2(status) {
  const classMap = {
    "cooldown": "status-cooldown",
    "active": "status-active",
    "finished": "status-finished"
  };
  return classMap[status] || "";
}
__name(getStatusClass2, "getStatusClass");
function getStatusIcon2(status) {
  const iconMap = {
    "cooldown": "\u23F1\uFE0F",
    "active": "\u{1F3AF}",
    "finished": "\u2705"
  };
  return iconMap[status] || "\u25CF";
}
__name(getStatusIcon2, "getStatusIcon");
function formatDateTime2(date) {
  return date.toLocaleDateString("ru-RU") + " " + date.toLocaleTimeString("ru-RU", {
    hour: "2-digit",
    minute: "2-digit"
  });
}
__name(formatDateTime2, "formatDateTime");
function formatCountdown2(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const secs = seconds % 60;
  if (hours > 0) {
    return `${hours}\u0447 ${minutes}\u043C`;
  } else if (minutes > 0) {
    return `${minutes}\u043C ${secs}\u0441`;
  } else {
    return `${secs}\u0441`;
  }
}
__name(formatCountdown2, "formatCountdown");

// packages/frontend/src/components/rounds-list/index.mjs
var RoundsList = class extends BaseComponent {
  static {
    __name(this, "RoundsList");
  }
  static observedAttributes = [];
  constructor() {
    super();
    this._templateMethods = template_exports5;
    this.state = {
      rounds: [],
      loading: true,
      user: null,
      error: null,
      lastUpdate: null,
      pollingEnabled: true
    };
    this._pollingInterval = null;
    this._previousRoundsState = /* @__PURE__ */ new Map();
    this._pollingTimeout = 1e4;
    this._maxPollingTimeout = 6e4;
  }
  async _componentReady() {
    this._controller = await controller3(this);
    this._actions = await createActions3(this);
    await this.loadData();
    await this.startPolling();
    await this.fullRender(this.state);
    return true;
  }
  async loadData() {
    try {
      const [stateManager, navigationManager] = await Promise.all([
        this.getComponentAsync("state-manager", "state-manager"),
        this.getComponentAsync("navigation-manager", "navigation-manager")
      ]);
      if (!stateManager || !navigationManager) {
        throw new Error("Required services not available");
      }
      this.state.user = await stateManager.getCurrentUser();
      if (!this.state.user) {
        await navigationManager.navigateTo("login");
        return;
      }
      const rounds = await stateManager.getRounds();
      this._updatePreviousState(rounds);
      this.state.rounds = this._enrichRoundsData(rounds);
      this.state.lastUpdate = /* @__PURE__ */ new Date();
      this.state.error = null;
    } catch (error) {
      console.error("\u274C Data loading error:", error);
      this.state.error = error.message || "\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0440\u0430\u0443\u043D\u0434\u043E\u0432";
      if (error.message.includes("Authentication") || error.message.includes("token")) {
        const navigationManager = await this.getComponentAsync("navigation-manager", "navigation-manager");
        if (navigationManager) {
          await navigationManager.navigateTo("login");
        }
      }
    } finally {
      this.state.loading = false;
    }
  }
  // Long polling   
  async startPolling() {
    if (!this.state.pollingEnabled) return;
    const poll = /* @__PURE__ */ __name(async () => {
      if (!this.state.pollingEnabled || !this.state.user) {
        this.stopPolling();
        return;
      }
      try {
        await this.refreshRounds();
      } catch (error) {
        console.error("\u274C Polling error:", error);
        this._pollingTimeout = Math.min(
          this._pollingTimeout * 1.5,
          this._maxPollingTimeout
        );
      }
      if (this.state.pollingEnabled) {
        this._pollingInterval = setTimeout(poll, this._pollingTimeout);
      }
    }, "poll");
    this._pollingInterval = setTimeout(poll, this._pollingTimeout);
  }
  async refreshRounds() {
    const stateManager = await this.getComponentAsync("state-manager", "state-manager");
    if (!stateManager || !stateManager.state.currentUser) {
      console.log("\u{1F44B} User logged out, stopping polling");
      this.stopPolling();
      return;
    }
    try {
      const rounds = await stateManager.getRounds();
      const enrichedRounds = this._enrichRoundsData(rounds);
      const { newRounds, changedRounds, removedRounds } = this._getAllChanges(enrichedRounds);
      console.log("\u{1F504} Rounds update analysis:", {
        total: enrichedRounds.length,
        new: newRounds.length,
        changed: changedRounds.length,
        removed: removedRounds.length
      });
      let hasChanges = false;
      if (newRounds.length > 0) {
        console.log(`\u{1F195} Adding ${newRounds.length} new rounds`);
        this.state.rounds = [...this.state.rounds, ...newRounds];
        hasChanges = true;
        const upcomingRounds = newRounds.filter((round) => round.is_upcoming);
        if (upcomingRounds.length > 0) {
          console.log(`\u23F0 New upcoming rounds:`, upcomingRounds.map((r2) => ({
            id: r2.id,
            start: r2.start_date,
            status: r2.status
          })));
        }
      }
      if (changedRounds.length > 0) {
        console.log(`\u{1F4DD} Updating ${changedRounds.length} changed rounds`);
        for (const round of changedRounds) {
          await this._actions.updateRoundCard(round.id, round);
          const index = this.state.rounds.findIndex((r2) => r2.id === round.id);
          if (index !== -1) {
            this.state.rounds[index] = round;
          }
        }
        hasChanges = true;
      }
      if (removedRounds.length > 0) {
        console.log(`\u{1F5D1}\uFE0F Removing ${removedRounds.length} rounds`);
        for (const roundId of removedRounds) {
          const roundCard = this.shadowRoot.querySelector(`[data-round-id="${roundId}"]`);
          if (roundCard) {
            roundCard.remove();
          }
        }
        this.state.rounds = this.state.rounds.filter(
          (round) => !removedRounds.includes(round.id)
        );
        hasChanges = true;
      }
      if (hasChanges) {
        this.state.rounds = this._sortRounds(this.state.rounds);
        this.state.lastUpdate = /* @__PURE__ */ new Date();
        if (newRounds.length > 0 || removedRounds.length > 0) {
          console.log("\u{1F3A8} Full re-render due to structural changes");
          await this.fullRender(this.state);
        }
        this._pollingTimeout = Math.max(5e3, this._pollingTimeout * 0.8);
        console.log(`\u23F1\uFE0F Polling timeout decreased to: ${this._pollingTimeout}ms`);
      } else {
        this._pollingTimeout = Math.min(
          this._pollingTimeout * 1.1,
          this._maxPollingTimeout
        );
        console.log(`\u23F1\uFE0F No changes, polling timeout increased to: ${this._pollingTimeout}ms`);
      }
      this._updatePreviousState(enrichedRounds);
    } catch (error) {
      console.error("\u274C Rounds refresh error:", error);
      throw error;
    }
  }
  //       
  _getAllChanges(newRounds) {
    const currentRoundIds = new Set(this.state.rounds.map((r2) => r2.id));
    const newRoundIds = new Set(newRounds.map((r2) => r2.id));
    const newRoundsList = newRounds.filter((round) => !currentRoundIds.has(round.id));
    const removedRounds = Array.from(currentRoundIds).filter((id) => !newRoundIds.has(id));
    const changedRounds = newRounds.filter((newRound) => {
      if (currentRoundIds.has(newRound.id)) {
        const currentRound = this.state.rounds.find((r2) => r2.id === newRound.id);
        return this._hasRoundChanged(currentRound, newRound);
      }
      return false;
    });
    return {
      newRounds: newRoundsList,
      changedRounds,
      removedRounds
    };
  }
  //      
  _hasRoundChanged(oldRound, newRound) {
    if (!oldRound || !newRound) return true;
    return oldRound.status !== newRound.status || oldRound.start_date !== newRound.start_date || oldRound.end_date !== newRound.end_date || oldRound.total_score !== newRound.total_score || JSON.stringify(oldRound.participants) !== JSON.stringify(newRound.participants) || JSON.stringify(oldRound.winner) !== JSON.stringify(newRound.winner);
  }
  //    
  _sortRounds(rounds) {
    return rounds.sort((a2, b) => {
      if (a2.status === "active" && b.status !== "active") return -1;
      if (b.status === "active" && a2.status !== "active") return 1;
      if (a2.status === "cooldown" && b.status !== "cooldown") return -1;
      if (b.status === "cooldown" && a2.status !== "cooldown") return 1;
      return new Date(b.start_date) - new Date(a2.start_date);
    });
  }
  //    
  _enrichRoundsData(rounds) {
    return rounds.map((round) => {
      const startDate = new Date(round.start_date);
      const endDate = new Date(round.end_date);
      const now = /* @__PURE__ */ new Date();
      const startTimestamp = startDate.getTime();
      const endTimestamp = endDate.getTime();
      const duration = Math.round((endTimestamp - startTimestamp) / 1e3);
      const timeUntilStart = Math.max(0, Math.round((startTimestamp - now.getTime()) / 1e3));
      const isUpcoming = startDate > now && round.status === "cooldown";
      const isActive = round.status === "active";
      const isFinished = round.status === "finished";
      return {
        ...round,
        start_timestamp: startTimestamp,
        end_timestamp: endTimestamp,
        duration,
        time_until_start: timeUntilStart,
        is_upcoming: isUpcoming,
        is_active: isActive,
        is_finished: isFinished,
        //  timestamp     
        _last_updated: Date.now()
      };
    });
  }
  //      
  _updatePreviousState(rounds) {
    this._previousRoundsState.clear();
    rounds.forEach((round) => {
      this._previousRoundsState.set(round.id, {
        status: round.status,
        start_date: round.start_date,
        end_date: round.end_date,
        total_score: round.total_score,
        participants: round.participants ? [...round.participants] : [],
        winner: round.winner ? { ...round.winner } : null,
        _hash: this._createRoundHash(round)
        //    
      });
    });
  }
  //      
  _createRoundHash(round) {
    const data = {
      status: round.status,
      start_date: round.start_date,
      end_date: round.end_date,
      total_score: round.total_score,
      participants: round.participants,
      winner: round.winner
    };
    return JSON.stringify(data);
  }
  //  polling
  stopPolling() {
    this.state.pollingEnabled = false;
    if (this._pollingInterval) {
      clearTimeout(this._pollingInterval);
      this._pollingInterval = null;
    }
  }
  resumePolling() {
    if (!this.state.pollingEnabled) {
      this.state.pollingEnabled = true;
      this.startPolling();
    }
  }
  //      
  async retryLoading() {
    this.state.loading = true;
    this.state.error = null;
    await this.fullRender(this.state);
    await this.loadData();
  }
  //     
  async setPollingTimeout(timeout) {
    this._pollingTimeout = Math.min(timeout, this._maxPollingTimeout);
    if (this.state.pollingEnabled) {
      this.stopPolling();
      this.startPolling();
    }
  }
  getPollingStatus() {
    return {
      enabled: this.state.pollingEnabled,
      timeout: this._pollingTimeout,
      lastUpdate: this.state.lastUpdate,
      roundsCount: this.state.rounds.length
    };
  }
  //  
  async disconnectedCallback() {
    this.stopPolling();
    if (this._controller && this._controller.destroy) {
      await this._controller.destroy();
    }
    await super.disconnectedCallback();
  }
};
if (!customElements.get("rounds-list")) {
  customElements.define("rounds-list", RoundsList);
}

// packages/frontend/src/components/round-page/template/index.mjs
var template_exports6 = {};
__export(template_exports6, {
  defaultTemplate: () => defaultTemplate6
});
function defaultTemplate6({ state = {} }) {
  if (!state.round) {
    return `
            <div class="round-page-container">
                <div class="loading">\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0440\u0430\u0443\u043D\u0434\u0430...</div>
            </div>
        `;
  }
  console.log("#################### ROUND TEST ####################", state);
  return `
        <div class="round-page-container">
            <header class="page-header">
                <h1>${getHeaderTitle(state.roundStatus)}</h1>
                ${state.user ? `<div class="user-info">${state.user.username}</div>` : ""}
            </header>

            <button class="back-btn">\u2190 \u041D\u0430\u0437\u0430\u0434 \u043A \u0441\u043F\u0438\u0441\u043A\u0443</button>

            <div class="game-area">
                ${renderGoose(state.roundStatus)}
                
                <div class="game-info">
                    ${renderGameInfo(state)}
                </div>
            </div>
        </div>
    `;
}
__name(defaultTemplate6, "defaultTemplate");
function getHeaderTitle(status) {
  switch (status) {
    case "cooldown":
      return "Cooldown";
    case "active":
      return "\u0420\u0430\u0443\u043D\u0434\u044B";
    case "finished":
      return "\u0420\u0430\u0443\u043D\u0434 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D";
    default:
      return "\u0420\u0430\u0443\u043D\u0434";
  }
}
__name(getHeaderTitle, "getHeaderTitle");
function renderGoose(status) {
  const clickableClass = status === "active" ? "clickable" : "";
  return `
        <div class="goose-container">
            <div class="goose-image ${clickableClass}">
                <div class="goose-art">
                    <div class="art-line">            \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591            </div>
                    <div class="art-line">          \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591\u2591           </div>
                    <div class="art-line">        \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591\u2591         </div>
                    <div class="art-line">        \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591\u2591         </div>
                    <div class="art-line">      \u2591\u2591\u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591\u2591\u2591\u2591       </div>
                    <div class="art-line">    \u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591   </div>
                    <div class="art-line">    \u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591   </div>
                    <div class="art-line">    \u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591   </div>
                    <div class="art-line">      \u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591     </div>
                    <div class="art-line">        \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591     </div>
                </div>
            </div>
        </div>
    `;
}
__name(renderGoose, "renderGoose");
function renderGameInfo(state) {
  const { roundStatus, timeLeft, userStats, round, formatTime: formatTime2 } = state;
  const formatTimeFunc = formatTime2 || ((ms) => {
    const seconds = Math.floor(ms / 1e3);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  });
  switch (roundStatus) {
    case "cooldown":
      return `
                <div class="status-message cooldown">
                    Cooldown
                </div>
                <div class="timer">
                    \u0434\u043E \u043D\u0430\u0447\u0430\u043B\u0430 \u0440\u0430\u0443\u043D\u0434\u0430 ${formatTimeFunc(timeLeft)}
                </div>
            `;
    case "active":
      return `
                <div class="status-message active">
                    \u0420\u0430\u0443\u043D\u0434 \u0430\u043A\u0442\u0438\u0432\u0435\u043D!
                </div>
                <div class="timer">
                    \u0414\u043E \u043A\u043E\u043D\u0446\u0430 \u043E\u0441\u0442\u0430\u043B\u043E\u0441\u044C: ${formatTimeFunc(timeLeft)}
                </div>
                ${userStats ? `
                    <div class="user-score">
                        \u041C\u043E\u0438 \u043E\u0447\u043A\u0438 - ${userStats.score}
                    </div>
                ` : ""}
            `;
    case "finished":
      const winner = round.winner || (round.participants?.length > 0 ? round.participants.reduce(
        (prev, current) => prev.score > current.score ? prev : current
      ) : null);
      return `
                <div class="status-message finished">
                    \u0420\u0430\u0443\u043D\u0434 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D
                </div>
                <div class="round-stats">
                    <div class="stats-divider"></div>
                    <div class="stat-row">
                        <span>\u0412\u0441\u0435\u0433\u043E \u043E\u0447\u043A\u043E\u0432</span>
                        <span>${round.total_score || 0}</span>
                    </div>
                    ${winner ? `
                        <div class="stat-row">
                            <span>\u041F\u043E\u0431\u0435\u0434\u0438\u0442\u0435\u043B\u044C</span>
                            <span>${winner.username} (${winner.score})</span>
                        </div>
                    ` : ""}
                    ${userStats ? `
                        <div class="stat-row">
                            <span>\u041C\u043E\u0438 \u043E\u0447\u043A\u0438</span>
                            <span>${userStats.score}</span>
                        </div>
                        <div class="stat-row">
                            <span>\u041C\u043E\u0438 \u0442\u0430\u043F\u044B</span>
                            <span>${userStats.tap_count || 0}</span>
                        </div>
                    ` : ""}
                </div>
            `;
    default:
      return '<div class="loading">2222 \u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430...</div>';
  }
}
__name(renderGameInfo, "renderGameInfo");

// packages/frontend/src/components/round-page/controller/index.mjs
var controller4 = /* @__PURE__ */ __name((context2) => {
  let eventListeners = [];
  let timerInterval;
  const addEventListener = /* @__PURE__ */ __name((element, event, handler) => {
    element.addEventListener(event, handler);
    eventListeners.push({ element, event, handler });
  }, "addEventListener");
  const startTimer = /* @__PURE__ */ __name(() => {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(async () => {
      if (context2.state.timeLeft > 0) {
        context2.state.timeLeft -= 1e3;
        if (context2.state.timeLeft <= 0) {
          await context2.loadRoundData();
        } else {
          await context2.updateTimerDisplay();
        }
      }
    }, 1e3);
  }, "startTimer");
  return {
    async init() {
      addEventListener(context2.shadowRoot, "click", (e2) => {
        if (e2.target.classList.contains("goose-image") || e2.target.closest(".goose-image")) {
          context2._actions.handleTap();
        }
        if (e2.target.classList.contains("back-btn")) {
          context2._actions.handleBack();
        }
      });
      addEventListener(document, "keydown", (e2) => {
        if (e2.code === "Space" && context2.state.roundStatus === "active") {
          e2.preventDefault();
          context2._actions.handleTap();
        }
      });
      startTimer();
    },
    async destroy() {
      eventListeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      eventListeners = [];
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }
  };
}, "controller");

// packages/frontend/src/components/round-page/actions/index.mjs
async function createActions4(context2) {
  return {
    handleTap: handleTap.bind(context2),
    handleBack: handleBack.bind(context2),
    handleKeyPress: handleKeyPress.bind(context2)
  };
}
__name(createActions4, "createActions");
async function handleTap() {
  if (this.state.roundStatus !== "active" || this.state.isTapping) return;
  this.state.isTapping = true;
  try {
    const stateManager = await this.getComponentAsync("state-manager", "state-manager");
    if (stateManager && this.state.user) {
      const result = await stateManager.tapRound(this.state.roundId, this.state.user.id);
      this.state.userStats = {
        tap_count: result.tap_count,
        score: result.score
      };
      if (this.state.round) {
        this.state.round.total_score = result.total_score;
      }
      await this.showTapFeedback();
      await this.updateElement({
        selector: ".user-score",
        value: `\u041C\u043E\u0438 \u043E\u0447\u043A\u0438 - ${this.state.userStats.score}`,
        property: "textContent"
      });
      if (result.is_special_tap) {
        await this.showSpecialTapNotification();
      }
    }
  } catch (error) {
    console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0442\u0430\u043F\u0430:", error);
    if (error.message.includes("not active")) {
      await this.loadRoundData();
    } else {
      await this.showModal({
        title: "\u041E\u0448\u0438\u0431\u043A\u0430",
        content: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u0442\u044C \u0442\u0430\u043F: ${error.message}`,
        buttons: [{ text: "OK", type: "primary" }]
      });
    }
  } finally {
    this.state.isTapping = false;
  }
}
__name(handleTap, "handleTap");
async function handleBack() {
  const navigationManager = await this.getComponentAsync("navigation-manager", "navigation-manager");
  if (navigationManager) {
    await navigationManager.navigateTo("rounds-list");
  }
}
__name(handleBack, "handleBack");
async function handleKeyPress(event) {
  if (event.code === "Space" && this.state.roundStatus === "active") {
    event.preventDefault();
    await this.handleTap();
  }
  if (event.code === "Escape") {
    await this.handleBack();
  }
}
__name(handleKeyPress, "handleKeyPress");

// packages/frontend/src/modules/index.mjs
var COLORS = {
  WARN: "\x1B[33m",
  // -
  INFO: "\x1B[36m",
  // 
  DEBUG: "\x1B[90m",
  // 
  ERROR: "\x1B[31m",
  // 
  RESET: "\x1B[0m"
  // 
};
function createLogger(prefix) {
  const baseLogger = logger(prefix);
  const enhancedLogger = /* @__PURE__ */ __name((...args) => baseLogger(...args), "enhancedLogger");
  enhancedLogger.trace = baseLogger.trace;
  enhancedLogger.warn = (...args) => {
    baseLogger(`${COLORS.WARN}\u26A0\uFE0F WARN:${COLORS.RESET}`, ...args);
  };
  enhancedLogger.info = (...args) => {
    baseLogger(`${COLORS.INFO}\u2139\uFE0F INFO:${COLORS.RESET}`, ...args);
  };
  enhancedLogger.debug = (...args) => {
    baseLogger(`${COLORS.DEBUG}\u{1F50D} DEBUG:${COLORS.RESET}`, ...args);
  };
  enhancedLogger.error = (...args) => {
    baseLogger(`${COLORS.ERROR}\u274C ERROR:${COLORS.RESET}`, ...args);
  };
  return enhancedLogger;
}
__name(createLogger, "createLogger");

// packages/frontend/src/components/round-page/index.mjs
var log3 = createLogger("round-page");
var RoundPage = class extends BaseComponent {
  static {
    __name(this, "RoundPage");
  }
  static observedAttributes = [];
  constructor() {
    super();
    this._templateMethods = template_exports6;
    this.state = {
      round: null,
      user: null,
      userStats: null,
      timeLeft: 0,
      roundStatus: "loading",
      error: null,
      roundId: null,
      isTapping: false
    };
    this.updateTimerDisplay = this.updateTimerDisplay.bind(this);
    this.getTimerText = this.getTimerText.bind(this);
    this.formatTime = this.formatTime.bind(this);
  }
  async _componentReady() {
    this._controller = await controller4(this);
    this._actions = await createActions4(this);
    const stateManager = await this.getComponentAsync("state-manager", "state-manager");
    if (stateManager) {
      this.state.user = await stateManager.getCurrentUser();
    }
    return true;
  }
  async setRound(roundId) {
    this.state.roundId = roundId;
    await this.loadRoundData();
  }
  async loadRoundData() {
    if (!this.state.roundId) return;
    try {
      const stateManager = await this.getComponentAsync("state-manager", "state-manager");
      if (stateManager) {
        this.state.round = await stateManager.getRound(this.state.roundId);
        await this.updateRoundStatus();
        this.state.error = null;
        await this.fullRender(this.state);
      }
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0440\u0430\u0443\u043D\u0434\u0430:", error);
      this.state.error = error.message || "\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0440\u0430\u0443\u043D\u0434\u0430";
      await this.fullRender(this.state);
    }
  }
  async updateRoundStatus() {
    if (!this.state.round) return;
    const now = /* @__PURE__ */ new Date();
    const start = new Date(this.state.round.start_date);
    const end = new Date(this.state.round.end_date);
    if (now < start) {
      this.state.roundStatus = "cooldown";
      this.state.timeLeft = start - now;
    } else if (now >= start && now <= end) {
      this.state.roundStatus = "active";
      this.state.timeLeft = end - now;
    } else {
      this.state.roundStatus = "finished";
      this.state.timeLeft = 0;
    }
    this.state.userStats = this.state.round.user_stats || { tap_count: 0, score: 0 };
  }
  //      
  async updateTimerDisplay() {
    const timerElement = this.shadowRoot.querySelector(".timer");
    if (timerElement) {
      timerElement.textContent = this.getTimerText();
    }
  }
  //     
  getTimerText() {
    const { roundStatus, timeLeft } = this.state;
    switch (roundStatus) {
      case "cooldown":
        return `\u0434\u043E \u043D\u0430\u0447\u0430\u043B\u0430 \u0440\u0430\u0443\u043D\u0434\u0430 ${this.formatTime(timeLeft)}`;
      case "active":
        return `\u0414\u043E \u043A\u043E\u043D\u0446\u0430 \u043E\u0441\u0442\u0430\u043B\u043E\u0441\u044C: ${this.formatTime(timeLeft)}`;
      default:
        return "";
    }
  }
  async handleTap() {
    if (this.state.roundStatus !== "active" || this.state.isTapping) return;
    this.state.isTapping = true;
    try {
      const stateManager = await this.getComponentAsync("state-manager", "state-manager");
      if (stateManager && this.state.user) {
        const result = await stateManager.tapRound(this.state.roundId, this.state.user.id);
        this.state.userStats = {
          tap_count: result.tap_count,
          score: result.score
        };
        if (this.state.round) {
          this.state.round.total_score = result.total_score;
        }
        await this.showTapFeedback();
        await this.updateElement({
          selector: ".user-score",
          value: `\u041C\u043E\u0438 \u043E\u0447\u043A\u0438 - ${this.state.userStats.score}`,
          property: "textContent"
        });
        if (result.is_special_tap) {
          await this.showSpecialTapNotification();
        }
      }
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0442\u0430\u043F\u0430:", error);
      if (error.message.includes("not active")) {
        await this.loadRoundData();
      } else {
        await this.showModal({
          title: "\u041E\u0448\u0438\u0431\u043A\u0430",
          content: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u0442\u044C \u0442\u0430\u043F: ${error.message}`,
          buttons: [{ text: "OK", type: "primary" }]
        });
      }
    } finally {
      this.state.isTapping = false;
    }
  }
  async showTapFeedback() {
    const gooseImage = this.shadowRoot.querySelector(".goose-image");
    if (gooseImage) {
      gooseImage.style.transform = "scale(0.95)";
      setTimeout(() => {
        gooseImage.style.transform = "";
      }, 100);
    }
  }
  async showSpecialTapNotification() {
    const notification = document.createElement("div");
    notification.style.cssText = `
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            font-weight: bold;
            z-index: 10000;
            animation: fadeInOut 2s ease-in-out;
        `;
    const style = document.createElement("style");
    style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translate(-50%, -60%); }
                20% { opacity: 1; transform: translate(-50%, -50%); }
                80% { opacity: 1; transform: translate(-50%, -50%); }
                100% { opacity: 0; transform: translate(-50%, -40%); }
            }
        `;
    notification.textContent = "\u{1F389} \u0421\u043F\u0435\u0446\u0438\u0430\u043B\u044C\u043D\u044B\u0439 \u0442\u0430\u043F! +10 \u043E\u0447\u043A\u043E\u0432!";
    this.shadowRoot.appendChild(style);
    this.shadowRoot.appendChild(notification);
    setTimeout(() => {
      this.shadowRoot.removeChild(notification);
      this.shadowRoot.removeChild(style);
    }, 2e3);
  }
  formatTime(ms) {
    const seconds = Math.floor(ms / 1e3);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  //    
  stopRefreshing() {
    if (this._controller && this._controller.destroy) {
      this._controller.destroy();
    }
  }
  async disconnectedCallback() {
    this.stopRefreshing();
    await super.disconnectedCallback();
  }
};
if (!customElements.get("round-page")) {
  customElements.define("round-page", RoundPage);
}

// packages/frontend/src/components/tests/src/modules/isEmpty/isEmpty.mjs
var has = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
function isEmpty(val) {
  if (val == null) return true;
  if ("boolean" == typeof val) return false;
  if ("number" == typeof val) return val === 0;
  if ("string" == typeof val) return val.length === 0;
  if ("function" == typeof val) return val.length === 0;
  if (Array.isArray(val)) {
    let object = val instanceof Object;
    if (object) {
      return Object.keys(val).length === 0;
    } else {
      return val.length === 0;
    }
  }
  if (val instanceof Error) return val.message === "";
  if (val.toString == toString) {
    switch (val.toString()) {
      // Maps, Sets, Files and Errors...
      case "[object File]":
      case "[object Map]":
      case "[object Set]": {
        return val.size === 0;
      }
      // Plain objects...
      case "[object Object]": {
        for (var key in val) {
          if (has.call(val, key)) return false;
        }
        return true;
      }
    }
  }
  return false;
}
__name(isEmpty, "isEmpty");
var isEmpty_default = isEmpty;

// packages/frontend/src/components/tests/src/modules/test/index.test.mjs
var index_test_default = `
describe('\u041E\u0441\u0442\u0440\u043E\u0432', async function () {
    this.timeout(10000);
    before(async function () { });
    describe('\u0423 \u043B\u0443\u043A\u043E\u043C\u043E\u0440\u044C\u044F \u0434\u0443\u0431 \u0437\u0435\u043B\u0451\u043D\u044B\u0439;', async function () {
        it('\u041F\u043E\u0441\u0430\u0434\u0438\u0442\u044C \u0434\u0435\u0440\u0435\u0432\u043E', function () {
            return new Promise(async (resolve, reject) => {
                console.log('\u041F\u0440\u0438\u0432\u0435\u0442 \u041C\u0438\u0440', expect)
                resolve(true)
            })
        })
        it('\u043F\u043E\u0434\u043E\u0436\u0430\u0442\u044C 20-30 \u043B\u0435\u0442', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
    })
    describe('\u0417\u043B\u0430\u0442\u0430\u044F \u0446\u0435\u043F\u044C \u043D\u0430 \u0434\u0443\u0431\u0435 \u0442\u043E\u043C:', async function () {
        it('\u041A\u0443\u043F\u0438\u0442\u044C \u043F\u0440\u0438\u0431\u043E\u0440 \u0434\u043B\u044F \u0430\u043D\u0430\u043B\u0438\u0437\u0430 \u0434\u0440\u0430\u0433\u043E\u0446\u0435\u043D\u043D\u044B\u0445 \u043C\u0435\u0442\u0430\u043B\u043B\u043E\u0432', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
        it('\u0421\u043D\u044F\u0442\u044C \u043F\u0440\u043E\u0431\u0443', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
    })
    describe('\u0418 \u0434\u043D\u0451\u043C \u0438 \u043D\u043E\u0447\u044C\u044E \u043A\u043E\u0442 \u0443\u0447\u0451\u043D\u044B\u0439', async function () {
        it('\u0412\u0437\u044F\u0442\u044C \u043A\u043E\u0442\u0430', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
        it('\u0412\u0437\u044F\u0442\u044C \u0443\u0447\u0435\u0431\u043D\u0438\u043A \u043C\u0430\u0442\u0435\u043C\u0430\u0442\u0438\u043A\u0438', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
        it('\u041F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u0443\u0447\u043A\u0431\u043D\u0438\u043A \u043A \u043A\u043E\u0442\u0443', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
    })
    describe('\u0412\u0441\u0451 \u0445\u043E\u0434\u0438\u0442 \u043F\u043E \u0446\u0435\u043F\u0438 \u043A\u0440\u0443\u0433\u043E\u043C;', async function () {
        it('\u041F\u043E\u0441\u043B\u0435\u0434\u0438\u0442\u044C \u043E\u0434\u0438\u043D \u0434\u0435\u043D\u044C', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
        it('\u041F\u043E\u0441\u043B\u0435\u0434\u0438\u0442\u044C \u0435\u0449\u0451 \u043E\u0434\u0438\u043D \u0434\u0435\u043D\u044C', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
        it('\u041F\u043E\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0434 \u043A\u043E\u0442\u043E\u043C \u043F\u0440\u0435\u043F\u044F\u0442\u0441\u0442\u0432\u0438\u0435', function () {
            return new Promise(async (resolve, reject) => {
                resolve(true)
            })
        })
    })
})`;

// packages/frontend/src/components/tests/src/modules/chai/index.mjs
function $parcel$interopDefault(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
__name($parcel$interopDefault, "$parcel$interopDefault");
var $parcel$global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : {};
var $947d894b4a2680e5$exports = {};
(function(global2, factory) {
  $947d894b4a2680e5$exports = factory();
})($947d894b4a2680e5$exports, function() {
  "use strict";
  var global$2 = typeof global$1 !== "undefined" ? global$1 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
  var global$1 = typeof global$2 !== "undefined" ? global$2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
  function defaultSetTimout$1() {
    throw new Error("setTimeout has not been defined");
  }
  __name(defaultSetTimout$1, "defaultSetTimout$1");
  function defaultClearTimeout$1() {
    throw new Error("clearTimeout has not been defined");
  }
  __name(defaultClearTimeout$1, "defaultClearTimeout$1");
  var cachedSetTimeout$1 = defaultSetTimout$1;
  var cachedClearTimeout$1 = defaultClearTimeout$1;
  if (typeof global$1.setTimeout === "function") cachedSetTimeout$1 = setTimeout;
  if (typeof global$1.clearTimeout === "function") cachedClearTimeout$1 = clearTimeout;
  function runTimeout$1(fun) {
    if (cachedSetTimeout$1 === setTimeout)
      return setTimeout(fun, 0);
    if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
      cachedSetTimeout$1 = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout$1(fun, 0);
    } catch (e2) {
      try {
        return cachedSetTimeout$1.call(null, fun, 0);
      } catch (e3) {
        return cachedSetTimeout$1.call(this, fun, 0);
      }
    }
  }
  __name(runTimeout$1, "runTimeout$1");
  function runClearTimeout$1(marker) {
    if (cachedClearTimeout$1 === clearTimeout)
      return clearTimeout(marker);
    if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
      cachedClearTimeout$1 = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout$1(marker);
    } catch (e2) {
      try {
        return cachedClearTimeout$1.call(null, marker);
      } catch (e3) {
        return cachedClearTimeout$1.call(this, marker);
      }
    }
  }
  __name(runClearTimeout$1, "runClearTimeout$1");
  var queue$1 = [];
  var draining$1 = false;
  var currentQueue$1;
  var queueIndex$1 = -1;
  function cleanUpNextTick$1() {
    if (!draining$1 || !currentQueue$1) return;
    draining$1 = false;
    if (currentQueue$1.length) queue$1 = currentQueue$1.concat(queue$1);
    else queueIndex$1 = -1;
    if (queue$1.length) drainQueue$1();
  }
  __name(cleanUpNextTick$1, "cleanUpNextTick$1");
  function drainQueue$1() {
    if (draining$1) return;
    var timeout = runTimeout$1(cleanUpNextTick$1);
    draining$1 = true;
    var len = queue$1.length;
    while (len) {
      currentQueue$1 = queue$1;
      queue$1 = [];
      while (++queueIndex$1 < len) if (currentQueue$1) currentQueue$1[queueIndex$1].run();
      queueIndex$1 = -1;
      len = queue$1.length;
    }
    currentQueue$1 = null;
    draining$1 = false;
    runClearTimeout$1(timeout);
  }
  __name(drainQueue$1, "drainQueue$1");
  function nextTick$1(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var i2 = 1; i2 < arguments.length; i2++) args[i2 - 1] = arguments[i2];
    queue$1.push(new Item$1(fun, args));
    if (queue$1.length === 1 && !draining$1) runTimeout$1(drainQueue$1);
  }
  __name(nextTick$1, "nextTick$1");
  function Item$1(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  __name(Item$1, "Item$1");
  Item$1.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  var title$1 = "browser";
  var platform$1 = "browser";
  var browser$4 = true;
  var env$1 = {};
  var argv$1 = [];
  var version$2 = "";
  var versions$1 = {};
  var release$1 = {};
  var config$1 = {};
  function noop$1() {
  }
  __name(noop$1, "noop$1");
  var on$1 = noop$1;
  var addListener$1 = noop$1;
  var once$1 = noop$1;
  var off$1 = noop$1;
  var removeListener$1 = noop$1;
  var removeAllListeners$1 = noop$1;
  var emit$1 = noop$1;
  function binding$1(name) {
    throw new Error("process.binding is not supported");
  }
  __name(binding$1, "binding$1");
  function cwd$1() {
    return "/";
  }
  __name(cwd$1, "cwd$1");
  function chdir$1(dir) {
    throw new Error("process.chdir is not supported");
  }
  __name(chdir$1, "chdir$1");
  function umask$1() {
    return 0;
  }
  __name(umask$1, "umask$1");
  var performance$1 = global$1.performance || {};
  var performanceNow$1 = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
  function hrtime$1(previousTimestamp) {
    var clocktime = performanceNow$1.call(performance$1) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [
      seconds,
      nanoseconds
    ];
  }
  __name(hrtime$1, "hrtime$1");
  var startTime$1 = /* @__PURE__ */ new Date();
  function uptime$1() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime$1;
    return dif / 1e3;
  }
  __name(uptime$1, "uptime$1");
  var process$1 = {
    nextTick: nextTick$1,
    title: title$1,
    browser: browser$4,
    env: env$1,
    argv: argv$1,
    version: version$2,
    versions: versions$1,
    on: on$1,
    addListener: addListener$1,
    once: once$1,
    off: off$1,
    removeListener: removeListener$1,
    removeAllListeners: removeAllListeners$1,
    emit: emit$1,
    binding: binding$1,
    cwd: cwd$1,
    chdir: chdir$1,
    umask: umask$1,
    hrtime: hrtime$1,
    platform: platform$1,
    release: release$1,
    config: config$1,
    uptime: uptime$1
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof $parcel$global !== "undefined" ? $parcel$global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: /* @__PURE__ */ __name(function(path, base2) {
        return commonjsRequire(path, base2 === void 0 || base2 === null ? module.path : base2);
      }, "require")
    }, fn(module, module.exports), module.exports;
  }
  __name(createCommonjsModule, "createCommonjsModule");
  function getCjsExportFromNamespace(n2) {
    return n2 && n2["default"] || n2;
  }
  __name(getCjsExportFromNamespace, "getCjsExportFromNamespace");
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  __name(commonjsRequire, "commonjsRequire");
  var domain1;
  function EventHandlers() {
  }
  __name(EventHandlers, "EventHandlers");
  EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
  function EventEmitter$2() {
    EventEmitter$2.init.call(this);
  }
  __name(EventEmitter$2, "EventEmitter$2");
  EventEmitter$2.EventEmitter = EventEmitter$2;
  EventEmitter$2.usingDomains = false;
  EventEmitter$2.prototype.domain = void 0;
  EventEmitter$2.prototype._events = void 0;
  EventEmitter$2.prototype._maxListeners = void 0;
  EventEmitter$2.defaultMaxListeners = 10;
  EventEmitter$2.init = function() {
    this.domain = null;
    if (EventEmitter$2.usingDomains) domain1.active;
    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter$2.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners(n2) {
    if (typeof n2 !== "number" || n2 < 0 || isNaN(n2)) throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n2;
    return this;
  }, "setMaxListeners");
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0) return EventEmitter$2.defaultMaxListeners;
    return that._maxListeners;
  }
  __name($getMaxListeners, "$getMaxListeners");
  EventEmitter$2.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners() {
    return $getMaxListeners(this);
  }, "getMaxListeners");
  function emitNone(handler, isFn, self2) {
    if (isFn) handler.call(self2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2) listeners[i2].call(self2);
    }
  }
  __name(emitNone, "emitNone");
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn) handler.call(self2, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2) listeners[i2].call(self2, arg1);
    }
  }
  __name(emitOne, "emitOne");
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn) handler.call(self2, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2) listeners[i2].call(self2, arg1, arg2);
    }
  }
  __name(emitTwo, "emitTwo");
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn) handler.call(self2, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2) listeners[i2].call(self2, arg1, arg2, arg3);
    }
  }
  __name(emitThree, "emitThree");
  function emitMany(handler, isFn, self2, args) {
    if (isFn) handler.apply(self2, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2) listeners[i2].apply(self2, args);
    }
  }
  __name(emitMany, "emitMany");
  EventEmitter$2.prototype.emit = /* @__PURE__ */ __name(function emit2(type) {
    var er, handler, len, args, i2, events, domain;
    var doError = type === "error";
    events = this._events;
    if (events) doError = doError && events.error == null;
    else if (!doError) return false;
    domain = this.domain;
    if (doError) {
      er = arguments[1];
      if (domain) {
        if (!er) er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit("error", er);
      } else if (er instanceof Error) throw er;
      else {
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
        err.context = er;
        throw err;
      }
      return false;
    }
    handler = events[type];
    if (!handler) return false;
    var isFn = typeof handler === "function";
    len = arguments.length;
    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower
      default:
        args = new Array(len - 1);
        for (i2 = 1; i2 < len; i2++) args[i2 - 1] = arguments[i2];
        emitMany(handler, isFn, this, args);
    }
    return true;
  }, "emit");
  function _addListener(target, type, listener, prepend) {
    var m2;
    var events;
    var existing;
    if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events.newListener) {
        target.emit("newListener", type, listener.listener ? listener.listener : listener);
        events = target._events;
      }
      existing = events[type];
    }
    if (!existing) {
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function")
        existing = events[type] = prepend ? [
          listener,
          existing
        ] : [
          existing,
          listener
        ];
      else if (prepend) existing.unshift(listener);
      else existing.push(listener);
      if (!existing.warned) {
        m2 = $getMaxListeners(target);
        if (m2 && m2 > 0 && existing.length > m2) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning$1(w);
        }
      }
    }
    return target;
  }
  __name(_addListener, "_addListener");
  function emitWarning$1(e2) {
    typeof console.warn === "function" ? console.warn(e2) : console.log(e2);
  }
  __name(emitWarning$1, "emitWarning$1");
  EventEmitter$2.prototype.addListener = /* @__PURE__ */ __name(function addListener2(type, listener) {
    return _addListener(this, type, listener, false);
  }, "addListener");
  EventEmitter$2.prototype.on = EventEmitter$2.prototype.addListener;
  EventEmitter$2.prototype.prependListener = /* @__PURE__ */ __name(function prependListener2(type, listener) {
    return _addListener(this, type, listener, true);
  }, "prependListener");
  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    __name(g, "g");
    g.listener = listener;
    return g;
  }
  __name(_onceWrap, "_onceWrap");
  EventEmitter$2.prototype.once = /* @__PURE__ */ __name(function once2(type, listener) {
    if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  }, "once");
  EventEmitter$2.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener(type, listener) {
    if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  }, "prependOnceListener");
  EventEmitter$2.prototype.removeListener = /* @__PURE__ */ __name(function removeListener2(type, listener) {
    var list, events, position, i2, originalListener;
    if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
    events = this._events;
    if (!events) return this;
    list = events[type];
    if (!list) return this;
    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();
      else {
        delete events[type];
        if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i2 = list.length; i2-- > 0; ) if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
      if (position < 0) return this;
      if (list.length === 1) {
        list[0] = void 0;
        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else delete events[type];
      } else spliceOne(list, position);
      if (events.removeListener) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  }, "removeListener");
  EventEmitter$2.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners2(type) {
    var listeners, events;
    events = this._events;
    if (!events) return this;
    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0) this._events = new EventHandlers();
        else delete events[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events);
      for (var i2 = 0, key; i2 < keys.length; ++i2) {
        key = keys[i2];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners)
      do
        this.removeListener(type, listeners[listeners.length - 1]);
      while (listeners[0]);
    return this;
  }, "removeAllListeners");
  EventEmitter$2.prototype.listeners = /* @__PURE__ */ __name(function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;
    if (!events) ret = [];
    else {
      evlistener = events[type];
      if (!evlistener) ret = [];
      else if (typeof evlistener === "function") ret = [
        evlistener.listener || evlistener
      ];
      else ret = unwrapListeners(evlistener);
    }
    return ret;
  }, "listeners");
  EventEmitter$2.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount$1.call(emitter, type);
  };
  EventEmitter$2.prototype.listenerCount = listenerCount$1;
  function listenerCount$1(type) {
    var events = this._events;
    if (events) {
      var evlistener = events[type];
      if (typeof evlistener === "function") return 1;
      else if (evlistener) return evlistener.length;
    }
    return 0;
  }
  __name(listenerCount$1, "listenerCount$1");
  EventEmitter$2.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  }, "eventNames");
  function spliceOne(list, index) {
    for (var i2 = index, k = i2 + 1, n2 = list.length; k < n2; i2 += 1, k += 1) list[i2] = list[k];
    list.pop();
  }
  __name(spliceOne, "spliceOne");
  function arrayClone(arr, i2) {
    var copy = new Array(i2);
    while (i2--) copy[i2] = arr[i2];
    return copy;
  }
  __name(arrayClone, "arrayClone");
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i2 = 0; i2 < ret.length; ++i2) ret[i2] = arr[i2].listener || arr[i2];
    return ret;
  }
  __name(unwrapListeners, "unwrapListeners");
  var lookup$1 = [];
  var revLookup$1 = [];
  var Arr$1 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var inited$1 = false;
  function init$1() {
    inited$1 = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup$1[i2] = code[i2];
      revLookup$1[code.charCodeAt(i2)] = i2;
    }
    revLookup$1["-".charCodeAt(0)] = 62;
    revLookup$1["_".charCodeAt(0)] = 63;
  }
  __name(init$1, "init$1");
  function toByteArray$1(b64) {
    if (!inited$1) init$1();
    var i2, j, l2, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr$1(len * 3 / 4 - placeHolders);
    l2 = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i2 = 0, j = 0; i2 < l2; i2 += 4, j += 3) {
      tmp = revLookup$1[b64.charCodeAt(i2)] << 18 | revLookup$1[b64.charCodeAt(i2 + 1)] << 12 | revLookup$1[b64.charCodeAt(i2 + 2)] << 6 | revLookup$1[b64.charCodeAt(i2 + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup$1[b64.charCodeAt(i2)] << 2 | revLookup$1[b64.charCodeAt(i2 + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup$1[b64.charCodeAt(i2)] << 10 | revLookup$1[b64.charCodeAt(i2 + 1)] << 4 | revLookup$1[b64.charCodeAt(i2 + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  __name(toByteArray$1, "toByteArray$1");
  function tripletToBase64$1(num) {
    return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
  }
  __name(tripletToBase64$1, "tripletToBase64$1");
  function encodeChunk$1(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
      output.push(tripletToBase64$1(tmp));
    }
    return output.join("");
  }
  __name(encodeChunk$1, "encodeChunk$1");
  function fromByteArray$1(uint8) {
    if (!inited$1) init$1();
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) parts.push(encodeChunk$1(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup$1[tmp >> 2];
      output += lookup$1[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup$1[tmp >> 10];
      output += lookup$1[tmp >> 4 & 63];
      output += lookup$1[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  __name(fromByteArray$1, "fromByteArray$1");
  function read$1(buffer, offset, isLE, mLen, nBytes) {
    var e2, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s2 = buffer[offset + i2];
    i2 += d2;
    e2 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) ;
    m2 = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) ;
    if (e2 === 0) e2 = 1 - eBias;
    else if (e2 === eMax) return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    else {
      m2 = m2 + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
  }
  __name(read$1, "read$1");
  function write$1(buffer, value, offset, isLE, mLen, nBytes) {
    var e2, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e2)) < 1) {
        e2--;
        c2 *= 2;
      }
      if (e2 + eBias >= 1) value += rt / c2;
      else value += rt * Math.pow(2, 1 - eBias);
      if (value * c2 >= 2) {
        e2++;
        c2 /= 2;
      }
      if (e2 + eBias >= eMax) {
        m2 = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) ;
    e2 = e2 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) ;
    buffer[offset + i2 - d2] |= s2 * 128;
  }
  __name(write$1, "write$1");
  var toString$2 = {}.toString;
  var isArray$2 = Array.isArray || function(arr) {
    return toString$2.call(arr) == "[object Array]";
  };
  var INSPECT_MAX_BYTES$1 = 50;
  Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
  function kMaxLength$1() {
    return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  __name(kMaxLength$1, "kMaxLength$1");
  function createBuffer$1(that, length) {
    if (kMaxLength$1() < length) throw new RangeError("Invalid typed array length");
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      if (that === null) that = new Buffer$1(length);
      that.length = length;
    }
    return that;
  }
  __name(createBuffer$1, "createBuffer$1");
  function Buffer$1(arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) return new Buffer$1(arg, encodingOrOffset, length);
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") throw new Error("If encoding is specified then the first argument must be a string");
      return allocUnsafe$1(this, arg);
    }
    return from$1(this, arg, encodingOrOffset, length);
  }
  __name(Buffer$1, "Buffer$1");
  Buffer$1.poolSize = 8192;
  Buffer$1._augment = function(arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr;
  };
  function from$1(that, value, encodingOrOffset, length) {
    if (typeof value === "number") throw new TypeError('"value" argument must not be a number');
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) return fromArrayBuffer$1(that, value, encodingOrOffset, length);
    if (typeof value === "string") return fromString$1(that, value, encodingOrOffset);
    return fromObject$1(that, value);
  }
  __name(from$1, "from$1");
  Buffer$1.from = function(value, encodingOrOffset, length) {
    return from$1(null, value, encodingOrOffset, length);
  };
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
  }
  function assertSize$1(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be a number');
    else if (size < 0) throw new RangeError('"size" argument must not be negative');
  }
  __name(assertSize$1, "assertSize$1");
  function alloc$1(that, size, fill, encoding) {
    assertSize$1(size);
    if (size <= 0) return createBuffer$1(that, size);
    if (fill !== void 0)
      return typeof encoding === "string" ? createBuffer$1(that, size).fill(fill, encoding) : createBuffer$1(that, size).fill(fill);
    return createBuffer$1(that, size);
  }
  __name(alloc$1, "alloc$1");
  Buffer$1.alloc = function(size, fill, encoding) {
    return alloc$1(null, size, fill, encoding);
  };
  function allocUnsafe$1(that, size) {
    assertSize$1(size);
    that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) for (var i2 = 0; i2 < size; ++i2) that[i2] = 0;
    return that;
  }
  __name(allocUnsafe$1, "allocUnsafe$1");
  Buffer$1.allocUnsafe = function(size) {
    return allocUnsafe$1(null, size);
  };
  Buffer$1.allocUnsafeSlow = function(size) {
    return allocUnsafe$1(null, size);
  };
  function fromString$1(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer$1.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
    var length = byteLength$1(string, encoding) | 0;
    that = createBuffer$1(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length)
      that = that.slice(0, actual);
    return that;
  }
  __name(fromString$1, "fromString$1");
  function fromArrayLike$1(that, array) {
    var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
    that = createBuffer$1(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) that[i2] = array[i2] & 255;
    return that;
  }
  __name(fromArrayLike$1, "fromArrayLike$1");
  function fromArrayBuffer$1(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError("'offset' is out of bounds");
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError("'length' is out of bounds");
    if (byteOffset === void 0 && length === void 0) array = new Uint8Array(array);
    else if (length === void 0) array = new Uint8Array(array, byteOffset);
    else array = new Uint8Array(array, byteOffset, length);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer$1.prototype;
    } else
      that = fromArrayLike$1(that, array);
    return that;
  }
  __name(fromArrayBuffer$1, "fromArrayBuffer$1");
  function fromObject$1(that, obj) {
    if (internalIsBuffer$1(obj)) {
      var len = checked$1(obj.length) | 0;
      that = createBuffer$1(that, len);
      if (that.length === 0) return that;
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan$1(obj.length)) return createBuffer$1(that, 0);
        return fromArrayLike$1(that, obj);
      }
      if (obj.type === "Buffer" && isArray$2(obj.data)) return fromArrayLike$1(that, obj.data);
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  __name(fromObject$1, "fromObject$1");
  function checked$1(length) {
    if (length >= kMaxLength$1()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength$1().toString(16) + " bytes");
    return length | 0;
  }
  __name(checked$1, "checked$1");
  Buffer$1.isBuffer = isBuffer$2;
  function internalIsBuffer$1(b) {
    return !!(b != null && b._isBuffer);
  }
  __name(internalIsBuffer$1, "internalIsBuffer$1");
  Buffer$1.compare = /* @__PURE__ */ __name(function compare(a2, b) {
    if (!internalIsBuffer$1(a2) || !internalIsBuffer$1(b)) throw new TypeError("Arguments must be Buffers");
    if (a2 === b) return 0;
    var x = a2.length;
    var y = b.length;
    for (var i2 = 0, len = Math.min(x, y); i2 < len; ++i2) if (a2[i2] !== b[i2]) {
      x = a2[i2];
      y = b[i2];
      break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }, "compare");
  Buffer$1.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  Buffer$1.concat = /* @__PURE__ */ __name(function concat(list, length) {
    if (!isArray$2(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer$1.alloc(0);
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) length += list[i2].length;
    }
    var buffer = Buffer$1.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (!internalIsBuffer$1(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  }, "concat");
  function byteLength$1(string, encoding) {
    if (internalIsBuffer$1(string)) return string.length;
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") string = "" + string;
    var len = string.length;
    if (len === 0) return 0;
    var loweredCase = false;
    for (; ; ) switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes$1(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes$1(string).length;
      default:
        if (loweredCase) return utf8ToBytes$1(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
  __name(byteLength$1, "byteLength$1");
  Buffer$1.byteLength = byteLength$1;
  function slowToString$1(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) start = 0;
    if (start > this.length) return "";
    if (end === void 0 || end > this.length) end = this.length;
    if (end <= 0) return "";
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while (true) switch (encoding) {
      case "hex":
        return hexSlice$1(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice$1(this, start, end);
      case "ascii":
        return asciiSlice$1(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice$1(this, start, end);
      case "base64":
        return base64Slice$1(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice$1(this, start, end);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
  __name(slowToString$1, "slowToString$1");
  Buffer$1.prototype._isBuffer = true;
  function swap$1(b, n2, m2) {
    var i2 = b[n2];
    b[n2] = b[m2];
    b[m2] = i2;
  }
  __name(swap$1, "swap$1");
  Buffer$1.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var i2 = 0; i2 < len; i2 += 2) swap$1(this, i2, i2 + 1);
    return this;
  }, "swap16");
  Buffer$1.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var i2 = 0; i2 < len; i2 += 4) {
      swap$1(this, i2, i2 + 3);
      swap$1(this, i2 + 1, i2 + 2);
    }
    return this;
  }, "swap32");
  Buffer$1.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var i2 = 0; i2 < len; i2 += 8) {
      swap$1(this, i2, i2 + 7);
      swap$1(this, i2 + 1, i2 + 6);
      swap$1(this, i2 + 2, i2 + 5);
      swap$1(this, i2 + 3, i2 + 4);
    }
    return this;
  }, "swap64");
  Buffer$1.prototype.toString = /* @__PURE__ */ __name(function toString3() {
    var length = this.length | 0;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice$1(this, 0, length);
    return slowToString$1.apply(this, arguments);
  }, "toString");
  Buffer$1.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
    if (!internalIsBuffer$1(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer$1.compare(this, b) === 0;
  }, "equals");
  Buffer$1.prototype.inspect = /* @__PURE__ */ __name(function inspect2() {
    var str = "";
    var max = INSPECT_MAX_BYTES$1;
    if (this.length > 0) {
      str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
      if (this.length > max) str += " ... ";
    }
    return "<Buffer " + str + ">";
  }, "inspect");
  Buffer$1.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer$1(target)) throw new TypeError("Argument must be a Buffer");
    if (start === void 0) start = 0;
    if (end === void 0) end = target ? target.length : 0;
    if (thisStart === void 0) thisStart = 0;
    if (thisEnd === void 0) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len; ++i2) if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y = targetCopy[i2];
      break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }, "compare");
  function bidirectionalIndexOf$1(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset;
    if (isNaN(byteOffset))
      byteOffset = dir ? 0 : buffer.length - 1;
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") val = Buffer$1.from(val, encoding);
    if (internalIsBuffer$1(val)) {
      if (val.length === 0) return -1;
      return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
      return arrayIndexOf$1(buffer, [
        val
      ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  __name(bidirectionalIndexOf$1, "bidirectionalIndexOf$1");
  function arrayIndexOf$1(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) return -1;
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) return buf[i2];
      else return buf.readUInt16BE(i2 * indexSize);
    }
    __name(read, "read");
    var i1;
    if (dir) {
      var foundIndex = -1;
      for (i1 = byteOffset; i1 < arrLength; i1++) if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i1;
        if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i1 -= i1 - foundIndex;
        foundIndex = -1;
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i1 = byteOffset; i1 >= 0; i1--) {
        var found = true;
        for (var j = 0; j < valLength; j++) if (read(arr, i1 + j) !== read(val, j)) {
          found = false;
          break;
        }
        if (found) return i1;
      }
    }
    return -1;
  }
  __name(arrayIndexOf$1, "arrayIndexOf$1");
  Buffer$1.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  }, "includes");
  Buffer$1.prototype.indexOf = /* @__PURE__ */ __name(function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true);
  }, "indexOf");
  Buffer$1.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false);
  }, "lastIndexOf");
  function hexWrite$1(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
      length = Number(length);
      if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
    if (length > strLen / 2) length = strLen / 2;
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (isNaN(parsed)) return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  __name(hexWrite$1, "hexWrite$1");
  function utf8Write$1(buf, string, offset, length) {
    return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length);
  }
  __name(utf8Write$1, "utf8Write$1");
  function asciiWrite$1(buf, string, offset, length) {
    return blitBuffer$1(asciiToBytes$1(string), buf, offset, length);
  }
  __name(asciiWrite$1, "asciiWrite$1");
  function latin1Write$1(buf, string, offset, length) {
    return asciiWrite$1(buf, string, offset, length);
  }
  __name(latin1Write$1, "latin1Write$1");
  function base64Write$1(buf, string, offset, length) {
    return blitBuffer$1(base64ToBytes$1(string), buf, offset, length);
  }
  __name(base64Write$1, "base64Write$1");
  function ucs2Write$1(buf, string, offset, length) {
    return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length);
  }
  __name(ucs2Write$1, "ucs2Write$1");
  Buffer$1.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for (; ; ) switch (encoding) {
      case "hex":
        return hexWrite$1(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write$1(this, string, offset, length);
      case "ascii":
        return asciiWrite$1(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write$1(this, string, offset, length);
      case "base64":
        return base64Write$1(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write$1(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }, "write");
  Buffer$1.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  }, "toJSON");
  function base64Slice$1(buf, start, end) {
    if (start === 0 && end === buf.length) return fromByteArray$1(buf);
    else return fromByteArray$1(buf.slice(start, end));
  }
  __name(base64Slice$1, "base64Slice$1");
  function utf8Slice$1(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) codePoint = firstByte;
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) codePoint = tempCodePoint;
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray$1(res);
  }
  __name(utf8Slice$1, "utf8Slice$1");
  var MAX_ARGUMENTS_LENGTH$1 = 4096;
  function decodeCodePointsArray$1(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH$1) return String.fromCharCode.apply(String, codePoints);
    var res = "";
    var i2 = 0;
    while (i2 < len) res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH$1));
    return res;
  }
  __name(decodeCodePointsArray$1, "decodeCodePointsArray$1");
  function asciiSlice$1(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) ret += String.fromCharCode(buf[i2] & 127);
    return ret;
  }
  __name(asciiSlice$1, "asciiSlice$1");
  function latin1Slice$1(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) ret += String.fromCharCode(buf[i2]);
    return ret;
  }
  __name(latin1Slice$1, "latin1Slice$1");
  function hexSlice$1(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) out += toHex$1(buf[i2]);
    return out;
  }
  __name(hexSlice$1, "hexSlice$1");
  function utf16leSlice$1(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    return res;
  }
  __name(utf16leSlice$1, "utf16leSlice$1");
  Buffer$1.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, void 0);
      for (var i2 = 0; i2 < sliceLen; ++i2) newBuf[i2] = this[i2 + start];
    }
    return newBuf;
  }, "slice");
  function checkOffset$1(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  __name(checkOffset$1, "checkOffset$1");
  Buffer$1.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset$1(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength && (mul *= 256)) val += this[offset + i2] * mul;
    return val;
  }, "readUIntLE");
  Buffer$1.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset$1(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 256)) val += this[offset + --byteLength] * mul;
    return val;
  }, "readUIntBE");
  Buffer$1.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 1, this.length);
    return this[offset];
  }, "readUInt8");
  Buffer$1.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  }, "readUInt16LE");
  Buffer$1.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  }, "readUInt16BE");
  Buffer$1.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  }, "readUInt32LE");
  Buffer$1.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  }, "readUInt32BE");
  Buffer$1.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset$1(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength && (mul *= 256)) val += this[offset + i2] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  }, "readIntLE");
  Buffer$1.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset$1(offset, byteLength, this.length);
    var i2 = byteLength;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) val += this[offset + --i2] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  }, "readIntBE");
  Buffer$1.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  }, "readInt8");
  Buffer$1.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  }, "readInt16LE");
  Buffer$1.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  }, "readInt16BE");
  Buffer$1.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  }, "readInt32LE");
  Buffer$1.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  }, "readInt32BE");
  Buffer$1.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return read$1(this, offset, true, 23, 4);
  }, "readFloatLE");
  Buffer$1.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return read$1(this, offset, false, 23, 4);
  }, "readFloatBE");
  Buffer$1.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 8, this.length);
    return read$1(this, offset, true, 52, 8);
  }, "readDoubleLE");
  Buffer$1.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 8, this.length);
    return read$1(this, offset, false, 52, 8);
  }, "readDoubleBE");
  function checkInt$1(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  __name(checkInt$1, "checkInt$1");
  Buffer$1.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt$1(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength && (mul *= 256)) this[offset + i2] = value / mul & 255;
    return offset + byteLength;
  }, "writeUIntLE");
  Buffer$1.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt$1(this, value, offset, byteLength, maxBytes, 0);
    }
    var i2 = byteLength - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) this[offset + i2] = value / mul & 255;
    return offset + byteLength;
  }, "writeUIntBE");
  Buffer$1.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 1, 255, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  }, "writeUInt8");
  function objectWriteUInt16$1(buf, value, offset, littleEndian) {
    if (value < 0) value = 65535 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
  __name(objectWriteUInt16$1, "objectWriteUInt16$1");
  Buffer$1.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 65535, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else objectWriteUInt16$1(this, value, offset, true);
    return offset + 2;
  }, "writeUInt16LE");
  Buffer$1.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 65535, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else objectWriteUInt16$1(this, value, offset, false);
    return offset + 2;
  }, "writeUInt16BE");
  function objectWriteUInt32$1(buf, value, offset, littleEndian) {
    if (value < 0) value = 4294967295 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
  __name(objectWriteUInt32$1, "objectWriteUInt32$1");
  Buffer$1.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 4294967295, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else objectWriteUInt32$1(this, value, offset, true);
    return offset + 4;
  }, "writeUInt32LE");
  Buffer$1.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 4294967295, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else objectWriteUInt32$1(this, value, offset, false);
    return offset + 4;
  }, "writeUInt32BE");
  Buffer$1.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) sub = 1;
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
  }, "writeIntLE");
  Buffer$1.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i2 = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) sub = 1;
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
  }, "writeIntBE");
  Buffer$1.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 1, 127, -128);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  }, "writeInt8");
  Buffer$1.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 32767, -32768);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else objectWriteUInt16$1(this, value, offset, true);
    return offset + 2;
  }, "writeInt16LE");
  Buffer$1.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 32767, -32768);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else objectWriteUInt16$1(this, value, offset, false);
    return offset + 2;
  }, "writeInt16BE");
  Buffer$1.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else objectWriteUInt32$1(this, value, offset, true);
    return offset + 4;
  }, "writeInt32LE");
  Buffer$1.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else objectWriteUInt32$1(this, value, offset, false);
    return offset + 4;
  }, "writeInt32BE");
  function checkIEEE754$1(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  __name(checkIEEE754$1, "checkIEEE754$1");
  function writeFloat$1(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) checkIEEE754$1(buf, value, offset, 4);
    write$1(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  __name(writeFloat$1, "writeFloat$1");
  Buffer$1.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
    return writeFloat$1(this, value, offset, true, noAssert);
  }, "writeFloatLE");
  Buffer$1.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
    return writeFloat$1(this, value, offset, false, noAssert);
  }, "writeFloatBE");
  function writeDouble$1(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) checkIEEE754$1(buf, value, offset, 8);
    write$1(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  __name(writeDouble$1, "writeDouble$1");
  Buffer$1.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
    return writeDouble$1(this, value, offset, true, noAssert);
  }, "writeDoubleLE");
  Buffer$1.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
    return writeDouble$1(this, value, offset, false, noAssert);
  }, "writeDoubleBE");
  Buffer$1.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    var i2;
    if (this === target && start < targetStart && targetStart < end)
      for (i2 = len - 1; i2 >= 0; --i2) target[i2 + targetStart] = this[i2 + start];
    else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT)
      for (i2 = 0; i2 < len; ++i2) target[i2 + targetStart] = this[i2 + start];
    else Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    return len;
  }, "copy");
  Buffer$1.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) val = code;
      }
      if (encoding !== void 0 && typeof encoding !== "string") throw new TypeError("encoding must be a string");
      if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    } else if (typeof val === "number") val = val & 255;
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    var i2;
    if (typeof val === "number") for (i2 = start; i2 < end; ++i2) this[i2] = val;
    else {
      var bytes = internalIsBuffer$1(val) ? val : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
      var len = bytes.length;
      for (i2 = 0; i2 < end - start; ++i2) this[i2 + start] = bytes[i2 % len];
    }
    return this;
  }, "fill");
  var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;
  function base64clean$1(str) {
    str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) str = str + "=";
    return str;
  }
  __name(base64clean$1, "base64clean$1");
  function stringtrim$1(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  __name(stringtrim$1, "stringtrim$1");
  function toHex$1(n2) {
    if (n2 < 16) return "0" + n2.toString(16);
    return n2.toString(16);
  }
  __name(toHex$1, "toHex$1");
  function utf8ToBytes$1(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return bytes;
  }
  __name(utf8ToBytes$1, "utf8ToBytes$1");
  function asciiToBytes$1(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2)
      byteArray.push(str.charCodeAt(i2) & 255);
    return byteArray;
  }
  __name(asciiToBytes$1, "asciiToBytes$1");
  function utf16leToBytes$1(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0) break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  __name(utf16leToBytes$1, "utf16leToBytes$1");
  function base64ToBytes$1(str) {
    return toByteArray$1(base64clean$1(str));
  }
  __name(base64ToBytes$1, "base64ToBytes$1");
  function blitBuffer$1(src2, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length) break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  __name(blitBuffer$1, "blitBuffer$1");
  function isnan$1(val) {
    return val !== val;
  }
  __name(isnan$1, "isnan$1");
  function isBuffer$2(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj));
  }
  __name(isBuffer$2, "isBuffer$2");
  function isFastBuffer$1(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  __name(isFastBuffer$1, "isFastBuffer$1");
  function isSlowBuffer$1(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer$1(obj.slice(0, 0));
  }
  __name(isSlowBuffer$1, "isSlowBuffer$1");
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  __name(defaultSetTimout, "defaultSetTimout");
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  __name(defaultClearTimeout, "defaultClearTimeout");
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === "function") cachedSetTimeout = setTimeout;
  if (typeof global$1.clearTimeout === "function") cachedClearTimeout = clearTimeout;
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout)
      return setTimeout(fun, 0);
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e2) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e3) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  __name(runTimeout, "runTimeout");
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout)
      return clearTimeout(marker);
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e2) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e3) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  __name(runClearTimeout, "runClearTimeout");
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
  }
  __name(cleanUpNextTick, "cleanUpNextTick");
  function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) if (currentQueue) currentQueue[queueIndex].run();
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  __name(drainQueue, "drainQueue");
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var i2 = 1; i2 < arguments.length; i2++) args[i2 - 1] = arguments[i2];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
  }
  __name(nextTick, "nextTick");
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  __name(Item, "Item");
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  var title1 = "browser";
  var platform = "browser";
  var browser$3 = true;
  var env1 = {};
  var argv = [];
  var version$1 = "";
  var versions = {};
  var release = {};
  var config = {};
  function noop() {
  }
  __name(noop, "noop");
  var on1 = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;
  function binding(name) {
    throw new Error("process.binding is not supported");
  }
  __name(binding, "binding");
  function cwd1() {
    return "/";
  }
  __name(cwd1, "cwd1");
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  __name(chdir, "chdir");
  function umask() {
    return 0;
  }
  __name(umask, "umask");
  var performance = global$1.performance || {};
  var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [
      seconds,
      nanoseconds
    ];
  }
  __name(hrtime, "hrtime");
  var startTime = /* @__PURE__ */ new Date();
  function uptime() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  __name(uptime, "uptime");
  var browser$1$1 = {
    nextTick,
    title: title1,
    browser: browser$3,
    env: env1,
    argv,
    version: version$1,
    versions,
    on: on1,
    addListener,
    once,
    off,
    removeListener,
    removeAllListeners,
    emit,
    binding,
    cwd: cwd1,
    chdir,
    umask,
    hrtime,
    platform,
    release,
    config,
    uptime
  };
  var process = browser$1$1;
  var inherits$2;
  if (typeof Object.create === "function") inherits$2 = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }, "inherits");
  else inherits$2 = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = /* @__PURE__ */ __name(function() {
    }, "TempCtor");
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }, "inherits");
  var inherits$3 = inherits$2;
  var formatRegExp = /%[sdj%]/g;
  function format$1(f2) {
    if (!isString$1(f2)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) objects.push(inspect(arguments[i2]));
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f2).replace(formatRegExp, function(x) {
      if (x === "%%") return "%";
      if (i2 >= len) return x;
      switch (x) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x;
      }
    });
    for (var x1 = args[i2]; i2 < len; x1 = args[++i2]) if (isNull(x1) || !isObject(x1)) str += " " + x1;
    else str += " " + inspect(x1);
    return str;
  }
  __name(format$1, "format$1");
  function deprecate$1(fn, msg) {
    if (isUndefined(global$1.process)) return function() {
      return deprecate$1(fn, msg).apply(this, arguments);
    };
    if (process.noDeprecation === true) return fn;
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) throw new Error(msg);
        else if (process.traceDeprecation) console.trace(msg);
        else console.error(msg);
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    __name(deprecated, "deprecated");
    return deprecated;
  }
  __name(deprecate$1, "deprecate$1");
  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || "";
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format$1.apply(null, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else debugs[set] = function() {
      };
    }
    return debugs[set];
  }
  __name(debuglog, "debuglog");
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts))
      ctx.showHidden = opts;
    else if (opts)
      _extend(ctx, opts);
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  __name(inspect, "inspect");
  inspect.colors = {
    "bold": [
      1,
      22
    ],
    "italic": [
      3,
      23
    ],
    "underline": [
      4,
      24
    ],
    "inverse": [
      7,
      27
    ],
    "white": [
      37,
      39
    ],
    "grey": [
      90,
      39
    ],
    "black": [
      30,
      39
    ],
    "blue": [
      34,
      39
    ],
    "cyan": [
      36,
      39
    ],
    "green": [
      32,
      39
    ],
    "magenta": [
      35,
      39
    ],
    "red": [
      31,
      39
    ],
    "yellow": [
      33,
      39
    ]
  };
  inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
    else return str;
  }
  __name(stylizeWithColor, "stylizeWithColor");
  function stylizeNoColor(str, styleType) {
    return str;
  }
  __name(stylizeNoColor, "stylizeNoColor");
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  __name(arrayToHash, "arrayToHash");
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString$1(ret)) ret = formatValue(ctx, ret, recurseTimes);
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) return primitive;
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
    if (isError$1(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError2(value);
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
      if (isError$1(value)) return formatError2(value);
    }
    var base2 = "", array = false, braces = [
      "{",
      "}"
    ];
    if (isArray$1(value)) {
      array = true;
      braces = [
        "[",
        "]"
      ];
    }
    if (isFunction(value)) {
      var n2 = value.name ? ": " + value.name : "";
      base2 = " [Function" + n2 + "]";
    }
    if (isRegExp(value)) base2 = " " + RegExp.prototype.toString.call(value);
    if (isDate(value)) base2 = " " + Date.prototype.toUTCString.call(value);
    if (isError$1(value)) base2 = " " + formatError2(value);
    if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base2 + braces[1];
    if (recurseTimes < 0) {
      if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      else return ctx.stylize("[Object]", "special");
    }
    ctx.seen.push(value);
    var output;
    if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    else output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
    ctx.seen.pop();
    return reduceToSingleString(output, base2, braces);
  }
  __name(formatValue, "formatValue");
  function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
    if (isString$1(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value)) return ctx.stylize("" + value, "number");
    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
    if (isNull(value)) return ctx.stylize("null", "null");
  }
  __name(formatPrimitive, "formatPrimitive");
  function formatError2(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  __name(formatError2, "formatError");
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) if (hasOwnProperty1(value, String(i2))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i2), true));
    else output.push("");
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    });
    return output;
  }
  __name(formatArray, "formatArray");
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
      value: value[key]
    };
    if (desc.get) {
      if (desc.set) str = ctx.stylize("[Getter/Setter]", "special");
      else str = ctx.stylize("[Getter]", "special");
    } else if (desc.set) str = ctx.stylize("[Setter]", "special");
    if (!hasOwnProperty1(visibleKeys, key)) name = "[" + key + "]";
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
        else str = formatValue(ctx, desc.value, recurseTimes - 1);
        if (str.indexOf("\n") > -1) {
          if (array) str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
          else str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      } else str = ctx.stylize("[Circular]", "special");
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) return str;
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  __name(formatProperty, "formatProperty");
  function reduceToSingleString(output, base2, braces) {
    var length = output.reduce(function(prev, cur) {
      cur.indexOf("\n");
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
  }
  __name(reduceToSingleString, "reduceToSingleString");
  function isArray$1(ar) {
    return Array.isArray(ar);
  }
  __name(isArray$1, "isArray$1");
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  __name(isBoolean, "isBoolean");
  function isNull(arg) {
    return arg === null;
  }
  __name(isNull, "isNull");
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  __name(isNullOrUndefined, "isNullOrUndefined");
  function isNumber(arg) {
    return typeof arg === "number";
  }
  __name(isNumber, "isNumber");
  function isString$1(arg) {
    return typeof arg === "string";
  }
  __name(isString$1, "isString$1");
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  __name(isSymbol, "isSymbol");
  function isUndefined(arg) {
    return arg === void 0;
  }
  __name(isUndefined, "isUndefined");
  function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
  }
  __name(isRegExp, "isRegExp");
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  __name(isObject, "isObject");
  function isDate(d2) {
    return isObject(d2) && objectToString(d2) === "[object Date]";
  }
  __name(isDate, "isDate");
  function isError$1(e2) {
    return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
  }
  __name(isError$1, "isError$1");
  function isFunction(arg) {
    return typeof arg === "function";
  }
  __name(isFunction, "isFunction");
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  __name(isPrimitive, "isPrimitive");
  function isBuffer$1(maybeBuf) {
    return isBuffer$2(maybeBuf);
  }
  __name(isBuffer$1, "isBuffer$1");
  function objectToString(o2) {
    return Object.prototype.toString.call(o2);
  }
  __name(objectToString, "objectToString");
  function pad1(n2) {
    return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
  }
  __name(pad1, "pad1");
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp() {
    var d2 = /* @__PURE__ */ new Date();
    var time = [
      pad1(d2.getHours()),
      pad1(d2.getMinutes()),
      pad1(d2.getSeconds())
    ].join(":");
    return [
      d2.getDate(),
      months[d2.getMonth()],
      time
    ].join(" ");
  }
  __name(timestamp, "timestamp");
  function log5() {
    console.log("%s - %s", timestamp(), format$1.apply(null, arguments));
  }
  __name(log5, "log");
  function _extend(origin, add) {
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i2 = keys.length;
    while (i2--) origin[keys[i2]] = add[keys[i2]];
    return origin;
  }
  __name(_extend, "_extend");
  function hasOwnProperty1(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  __name(hasOwnProperty1, "hasOwnProperty1");
  var util = {
    inherits: inherits$3,
    _extend,
    log: log5,
    isBuffer: isBuffer$1,
    isPrimitive,
    isFunction,
    isError: isError$1,
    isDate,
    isObject,
    isRegExp,
    isUndefined,
    isSymbol,
    isString: isString$1,
    isNumber,
    isNullOrUndefined,
    isNull,
    isBoolean,
    isArray: isArray$1,
    inspect,
    deprecate: deprecate$1,
    format: format$1,
    debuglog
  };
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var inited = false;
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  __name(init, "init");
  function toByteArray(b64) {
    if (!inited) init();
    var i2, j, l2, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l2 = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i2 = 0, j = 0; i2 < l2; i2 += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  __name(toByteArray, "toByteArray");
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  __name(tripletToBase64, "tripletToBase64");
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  __name(encodeChunk, "encodeChunk");
  function fromByteArray(uint8) {
    if (!inited) init();
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  __name(fromByteArray, "fromByteArray");
  function read1(buffer, offset, isLE, mLen, nBytes) {
    var e2, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s2 = buffer[offset + i2];
    i2 += d2;
    e2 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) ;
    m2 = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) ;
    if (e2 === 0) e2 = 1 - eBias;
    else if (e2 === eMax) return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    else {
      m2 = m2 + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
  }
  __name(read1, "read1");
  function write1(buffer, value, offset, isLE, mLen, nBytes) {
    var e2, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e2)) < 1) {
        e2--;
        c2 *= 2;
      }
      if (e2 + eBias >= 1) value += rt / c2;
      else value += rt * Math.pow(2, 1 - eBias);
      if (value * c2 >= 2) {
        e2++;
        c2 /= 2;
      }
      if (e2 + eBias >= eMax) {
        m2 = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) ;
    e2 = e2 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) ;
    buffer[offset + i2 - d2] |= s2 * 128;
  }
  __name(write1, "write1");
  var toString$1 = {}.toString;
  var isArray = Array.isArray || function(arr) {
    return toString$1.call(arr) == "[object Array]";
  };
  var INSPECT_MAX_BYTES = 50;
  Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
  function kMaxLength() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  __name(kMaxLength, "kMaxLength");
  function createBuffer(that, length) {
    if (kMaxLength() < length) throw new RangeError("Invalid typed array length");
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) that = new Buffer2(length);
      that.length = length;
    }
    return that;
  }
  __name(createBuffer, "createBuffer");
  function Buffer2(arg, encodingOrOffset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) return new Buffer2(arg, encodingOrOffset, length);
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") throw new Error("If encoding is specified then the first argument must be a string");
      return allocUnsafe(this, arg);
    }
    return from1(this, arg, encodingOrOffset, length);
  }
  __name(Buffer2, "Buffer");
  Buffer2.poolSize = 8192;
  Buffer2._augment = function(arr) {
    arr.__proto__ = Buffer2.prototype;
    return arr;
  };
  function from1(that, value, encodingOrOffset, length) {
    if (typeof value === "number") throw new TypeError('"value" argument must not be a number');
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) return fromArrayBuffer(that, value, encodingOrOffset, length);
    if (typeof value === "string") return fromString(that, value, encodingOrOffset);
    return fromObject(that, value);
  }
  __name(from1, "from1");
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from1(null, value, encodingOrOffset, length);
  };
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    Buffer2.prototype.__proto__ = Uint8Array.prototype;
    Buffer2.__proto__ = Uint8Array;
  }
  function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be a number');
    else if (size < 0) throw new RangeError('"size" argument must not be negative');
  }
  __name(assertSize, "assertSize");
  function alloc(that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(that, size);
    if (fill !== void 0)
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    return createBuffer(that, size);
  }
  __name(alloc, "alloc");
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) for (var i2 = 0; i2 < size; ++i2) that[i2] = 0;
    return that;
  }
  __name(allocUnsafe, "allocUnsafe");
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(null, size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(null, size);
  };
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer2.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
    var length = byteLength1(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length)
      that = that.slice(0, actual);
    return that;
  }
  __name(fromString, "fromString");
  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) that[i2] = array[i2] & 255;
    return that;
  }
  __name(fromArrayLike, "fromArrayLike");
  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError("'offset' is out of bounds");
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError("'length' is out of bounds");
    if (byteOffset === void 0 && length === void 0) array = new Uint8Array(array);
    else if (length === void 0) array = new Uint8Array(array, byteOffset);
    else array = new Uint8Array(array, byteOffset, length);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer2.prototype;
    } else
      that = fromArrayLike(that, array);
    return that;
  }
  __name(fromArrayBuffer, "fromArrayBuffer");
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) return that;
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) return createBuffer(that, 0);
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray(obj.data)) return fromArrayLike(that, obj.data);
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  __name(fromObject, "fromObject");
  function checked(length) {
    if (length >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    return length | 0;
  }
  __name(checked, "checked");
  Buffer2.isBuffer = isBuffer;
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  __name(internalIsBuffer, "internalIsBuffer");
  Buffer2.compare = /* @__PURE__ */ __name(function compare(a2, b) {
    if (!internalIsBuffer(a2) || !internalIsBuffer(b)) throw new TypeError("Arguments must be Buffers");
    if (a2 === b) return 0;
    var x = a2.length;
    var y = b.length;
    for (var i2 = 0, len = Math.min(x, y); i2 < len; ++i2) if (a2[i2] !== b[i2]) {
      x = a2[i2];
      y = b[i2];
      break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }, "compare");
  Buffer2.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  Buffer2.concat = /* @__PURE__ */ __name(function concat(list, length) {
    if (!isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer2.alloc(0);
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) length += list[i2].length;
    }
    var buffer = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (!internalIsBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  }, "concat");
  function byteLength1(string, encoding) {
    if (internalIsBuffer(string)) return string.length;
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") string = "" + string;
    var len = string.length;
    if (len === 0) return 0;
    var loweredCase = false;
    for (; ; ) switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
  __name(byteLength1, "byteLength1");
  Buffer2.byteLength = byteLength1;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) start = 0;
    if (start > this.length) return "";
    if (end === void 0 || end > this.length) end = this.length;
    if (end <= 0) return "";
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while (true) switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
  __name(slowToString, "slowToString");
  Buffer2.prototype._isBuffer = true;
  function swap1(b, n2, m2) {
    var i2 = b[n2];
    b[n2] = b[m2];
    b[m2] = i2;
  }
  __name(swap1, "swap1");
  Buffer2.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var i2 = 0; i2 < len; i2 += 2) swap1(this, i2, i2 + 1);
    return this;
  }, "swap16");
  Buffer2.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var i2 = 0; i2 < len; i2 += 4) {
      swap1(this, i2, i2 + 3);
      swap1(this, i2 + 1, i2 + 2);
    }
    return this;
  }, "swap32");
  Buffer2.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var i2 = 0; i2 < len; i2 += 8) {
      swap1(this, i2, i2 + 7);
      swap1(this, i2 + 1, i2 + 6);
      swap1(this, i2 + 2, i2 + 5);
      swap1(this, i2 + 3, i2 + 4);
    }
    return this;
  }, "swap64");
  Buffer2.prototype.toString = /* @__PURE__ */ __name(function toString3() {
    var length = this.length | 0;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  }, "toString");
  Buffer2.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
    if (!internalIsBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  }, "equals");
  Buffer2.prototype.inspect = /* @__PURE__ */ __name(function inspect2() {
    var str = "";
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
      if (this.length > max) str += " ... ";
    }
    return "<Buffer " + str + ">";
  }, "inspect");
  Buffer2.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) throw new TypeError("Argument must be a Buffer");
    if (start === void 0) start = 0;
    if (end === void 0) end = target ? target.length : 0;
    if (thisStart === void 0) thisStart = 0;
    if (thisEnd === void 0) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len; ++i2) if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y = targetCopy[i2];
      break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }, "compare");
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset;
    if (isNaN(byteOffset))
      byteOffset = dir ? 0 : buffer.length - 1;
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") val = Buffer2.from(val, encoding);
    if (internalIsBuffer(val)) {
      if (val.length === 0) return -1;
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
      return arrayIndexOf(buffer, [
        val
      ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  __name(bidirectionalIndexOf, "bidirectionalIndexOf");
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) return -1;
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) return buf[i3];
      else return buf.readUInt16BE(i3 * indexSize);
    }
    __name(read, "read");
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) if (read(arr, i2 + j) !== read(val, j)) {
          found = false;
          break;
        }
        if (found) return i2;
      }
    }
    return -1;
  }
  __name(arrayIndexOf, "arrayIndexOf");
  Buffer2.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  }, "includes");
  Buffer2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  }, "indexOf");
  Buffer2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  }, "lastIndexOf");
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
      length = Number(length);
      if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
    if (length > strLen / 2) length = strLen / 2;
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (isNaN(parsed)) return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  __name(hexWrite, "hexWrite");
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  __name(utf8Write, "utf8Write");
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  __name(asciiWrite, "asciiWrite");
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  __name(latin1Write, "latin1Write");
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  __name(base64Write, "base64Write");
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  __name(ucs2Write, "ucs2Write");
  Buffer2.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for (; ; ) switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
        return asciiWrite(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }, "write");
  Buffer2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  }, "toJSON");
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return fromByteArray(buf);
    else return fromByteArray(buf.slice(start, end));
  }
  __name(base64Slice, "base64Slice");
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) codePoint = firstByte;
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) codePoint = tempCodePoint;
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  __name(utf8Slice, "utf8Slice");
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
    var res = "";
    var i2 = 0;
    while (i2 < len) res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    return res;
  }
  __name(decodeCodePointsArray, "decodeCodePointsArray");
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) ret += String.fromCharCode(buf[i2] & 127);
    return ret;
  }
  __name(asciiSlice, "asciiSlice");
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) ret += String.fromCharCode(buf[i2]);
    return ret;
  }
  __name(latin1Slice, "latin1Slice");
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) out += toHex(buf[i2]);
    return out;
  }
  __name(hexSlice, "hexSlice");
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    return res;
  }
  __name(utf16leSlice, "utf16leSlice");
  Buffer2.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer2.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer2(sliceLen, void 0);
      for (var i2 = 0; i2 < sliceLen; ++i2) newBuf[i2] = this[i2 + start];
    }
    return newBuf;
  }, "slice");
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  __name(checkOffset, "checkOffset");
  Buffer2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength && (mul *= 256)) val += this[offset + i2] * mul;
    return val;
  }, "readUIntLE");
  Buffer2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 256)) val += this[offset + --byteLength] * mul;
    return val;
  }, "readUIntBE");
  Buffer2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  }, "readUInt8");
  Buffer2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  }, "readUInt16LE");
  Buffer2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  }, "readUInt16BE");
  Buffer2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  }, "readUInt32LE");
  Buffer2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  }, "readUInt32BE");
  Buffer2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength && (mul *= 256)) val += this[offset + i2] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  }, "readIntLE");
  Buffer2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i2 = byteLength;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) val += this[offset + --i2] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  }, "readIntBE");
  Buffer2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  }, "readInt8");
  Buffer2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  }, "readInt16LE");
  Buffer2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  }, "readInt16BE");
  Buffer2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  }, "readInt32LE");
  Buffer2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  }, "readInt32BE");
  Buffer2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read1(this, offset, true, 23, 4);
  }, "readFloatLE");
  Buffer2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read1(this, offset, false, 23, 4);
  }, "readFloatBE");
  Buffer2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read1(this, offset, true, 52, 8);
  }, "readDoubleLE");
  Buffer2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read1(this, offset, false, 52, 8);
  }, "readDoubleBE");
  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  __name(checkInt, "checkInt");
  Buffer2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength && (mul *= 256)) this[offset + i2] = value / mul & 255;
    return offset + byteLength;
  }, "writeUIntLE");
  Buffer2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i2 = byteLength - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) this[offset + i2] = value / mul & 255;
    return offset + byteLength;
  }, "writeUIntBE");
  Buffer2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  }, "writeUInt8");
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 65535 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
  __name(objectWriteUInt16, "objectWriteUInt16");
  Buffer2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else objectWriteUInt16(this, value, offset, true);
    return offset + 2;
  }, "writeUInt16LE");
  Buffer2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else objectWriteUInt16(this, value, offset, false);
    return offset + 2;
  }, "writeUInt16BE");
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 4294967295 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
  __name(objectWriteUInt32, "objectWriteUInt32");
  Buffer2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else objectWriteUInt32(this, value, offset, true);
    return offset + 4;
  }, "writeUInt32LE");
  Buffer2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else objectWriteUInt32(this, value, offset, false);
    return offset + 4;
  }, "writeUInt32BE");
  Buffer2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) sub = 1;
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
  }, "writeIntLE");
  Buffer2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i2 = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) sub = 1;
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
  }, "writeIntBE");
  Buffer2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  }, "writeInt8");
  Buffer2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else objectWriteUInt16(this, value, offset, true);
    return offset + 2;
  }, "writeInt16LE");
  Buffer2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else objectWriteUInt16(this, value, offset, false);
    return offset + 2;
  }, "writeInt16BE");
  Buffer2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else objectWriteUInt32(this, value, offset, true);
    return offset + 4;
  }, "writeInt32LE");
  Buffer2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else objectWriteUInt32(this, value, offset, false);
    return offset + 4;
  }, "writeInt32BE");
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  __name(checkIEEE754, "checkIEEE754");
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) checkIEEE754(buf, value, offset, 4);
    write1(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  __name(writeFloat, "writeFloat");
  Buffer2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  }, "writeFloatLE");
  Buffer2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  }, "writeFloatBE");
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) checkIEEE754(buf, value, offset, 8);
    write1(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  __name(writeDouble, "writeDouble");
  Buffer2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  }, "writeDoubleLE");
  Buffer2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  }, "writeDoubleBE");
  Buffer2.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    var i2;
    if (this === target && start < targetStart && targetStart < end)
      for (i2 = len - 1; i2 >= 0; --i2) target[i2 + targetStart] = this[i2 + start];
    else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT)
      for (i2 = 0; i2 < len; ++i2) target[i2 + targetStart] = this[i2 + start];
    else Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    return len;
  }, "copy");
  Buffer2.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) val = code;
      }
      if (encoding !== void 0 && typeof encoding !== "string") throw new TypeError("encoding must be a string");
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    } else if (typeof val === "number") val = val & 255;
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    var i2;
    if (typeof val === "number") for (i2 = start; i2 < end; ++i2) this[i2] = val;
    else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
      var len = bytes.length;
      for (i2 = 0; i2 < end - start; ++i2) this[i2 + start] = bytes[i2 % len];
    }
    return this;
  }, "fill");
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) str = str + "=";
    return str;
  }
  __name(base64clean, "base64clean");
  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  __name(stringtrim, "stringtrim");
  function toHex(n2) {
    if (n2 < 16) return "0" + n2.toString(16);
    return n2.toString(16);
  }
  __name(toHex, "toHex");
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return bytes;
  }
  __name(utf8ToBytes, "utf8ToBytes");
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2)
      byteArray.push(str.charCodeAt(i2) & 255);
    return byteArray;
  }
  __name(asciiToBytes, "asciiToBytes");
  function utf16leToBytes(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0) break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  __name(utf16leToBytes, "utf16leToBytes");
  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }
  __name(base64ToBytes, "base64ToBytes");
  function blitBuffer(src2, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length) break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  __name(blitBuffer, "blitBuffer");
  function isnan(val) {
    return val !== val;
  }
  __name(isnan, "isnan");
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  __name(isBuffer, "isBuffer");
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  __name(isFastBuffer, "isFastBuffer");
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  __name(isSlowBuffer, "isSlowBuffer");
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  __name(BufferList, "BufferList");
  BufferList.prototype.push = function(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
    ++this.length;
  };
  BufferList.prototype.unshift = function(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };
  BufferList.prototype.shift = function() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;
    else this.head = this.head.next;
    --this.length;
    return ret;
  };
  BufferList.prototype.clear = function() {
    this.head = this.tail = null;
    this.length = 0;
  };
  BufferList.prototype.join = function(s2) {
    if (this.length === 0) return "";
    var p2 = this.head;
    var ret = "" + p2.data;
    while (p2 = p2.next) ret += s2 + p2.data;
    return ret;
  };
  BufferList.prototype.concat = function(n2) {
    if (this.length === 0) return Buffer2.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer2.allocUnsafe(n2 >>> 0);
    var p2 = this.head;
    var i2 = 0;
    while (p2) {
      p2.data.copy(ret, i2);
      i2 += p2.data.length;
      p2 = p2.next;
    }
    return ret;
  };
  var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) throw new Error("Unknown encoding: " + encoding);
  }
  __name(assertEncoding, "assertEncoding");
  function StringDecoder(encoding) {
    this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
    assertEncoding(encoding);
    switch (this.encoding) {
      case "utf8":
        this.surrogateSize = 3;
        break;
      case "ucs2":
      case "utf16le":
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case "base64":
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer2(6);
    this.charReceived = 0;
    this.charLength = 0;
  }
  __name(StringDecoder, "StringDecoder");
  StringDecoder.prototype.write = function(buffer) {
    var charStr = "";
    while (this.charLength) {
      var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
      buffer.copy(this.charBuffer, this.charReceived, 0, available);
      this.charReceived += available;
      if (this.charReceived < this.charLength)
        return "";
      buffer = buffer.slice(available, buffer.length);
      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
      var charCode = charStr.charCodeAt(charStr.length - 1);
      if (charCode >= 55296 && charCode <= 56319) {
        this.charLength += this.surrogateSize;
        charStr = "";
        continue;
      }
      this.charReceived = this.charLength = 0;
      if (buffer.length === 0) return charStr;
      break;
    }
    this.detectIncompleteChar(buffer);
    var end = buffer.length;
    if (this.charLength) {
      buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
      end -= this.charReceived;
    }
    charStr += buffer.toString(this.encoding, 0, end);
    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end);
    if (charCode >= 55296 && charCode <= 56319) {
      var size = this.surrogateSize;
      this.charLength += size;
      this.charReceived += size;
      this.charBuffer.copy(this.charBuffer, size, 0, size);
      buffer.copy(this.charBuffer, 0, 0, size);
      return charStr.substring(0, end);
    }
    return charStr;
  };
  StringDecoder.prototype.detectIncompleteChar = function(buffer) {
    var i2 = buffer.length >= 3 ? 3 : buffer.length;
    for (; i2 > 0; i2--) {
      var c2 = buffer[buffer.length - i2];
      if (i2 == 1 && c2 >> 5 == 6) {
        this.charLength = 2;
        break;
      }
      if (i2 <= 2 && c2 >> 4 == 14) {
        this.charLength = 3;
        break;
      }
      if (i2 <= 3 && c2 >> 3 == 30) {
        this.charLength = 4;
        break;
      }
    }
    this.charReceived = i2;
  };
  StringDecoder.prototype.end = function(buffer) {
    var res = "";
    if (buffer && buffer.length) res = this.write(buffer);
    if (this.charReceived) {
      var cr = this.charReceived;
      var buf = this.charBuffer;
      var enc = this.encoding;
      res += buf.slice(0, cr).toString(enc);
    }
    return res;
  };
  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }
  __name(passThroughWrite, "passThroughWrite");
  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }
  __name(utf16DetectIncompleteChar, "utf16DetectIncompleteChar");
  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }
  __name(base64DetectIncompleteChar, "base64DetectIncompleteChar");
  Readable.ReadableState = ReadableState;
  var debug$2 = debuglog("stream");
  inherits$3(Readable, EventEmitter$2);
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    else {
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [
        fn,
        emitter._events[event]
      ];
    }
  }
  __name(prependListener, "prependListener");
  function listenerCount(emitter, type) {
    return emitter.listeners(type).length;
  }
  __name(listenerCount, "listenerCount");
  function ReadableState(options, stream) {
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16384;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  __name(ReadableState, "ReadableState");
  function Readable(options) {
    if (!(this instanceof Readable)) return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options && typeof options.read === "function") this._read = options.read;
    EventEmitter$2.call(this);
  }
  __name(Readable, "Readable");
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    if (!state.objectMode && typeof chunk === "string") {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer$1.from(chunk, encoding);
        encoding = "";
      }
    }
    return readableAddChunk(this, state, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, "", true);
  };
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) stream.emit("error", er);
    else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e2 = new Error("stream.push() after EOF");
        stream.emit("error", e2);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error("stream.unshift() after end event");
        stream.emit("error", _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }
        if (!addToFront) state.reading = false;
        if (!skipAdd) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);
            else state.buffer.push(chunk);
            if (state.needReadable) emitReadable(stream);
          }
        }
        maybeReadMore(stream, state);
      }
    } else if (!addToFront) state.reading = false;
    return needMoreData(state);
  }
  __name(readableAddChunk, "readableAddChunk");
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  __name(needMoreData, "needMoreData");
  Readable.prototype.setEncoding = function(enc) {
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n2) {
    if (n2 >= MAX_HWM) n2 = MAX_HWM;
    else {
      n2--;
      n2 |= n2 >>> 1;
      n2 |= n2 >>> 2;
      n2 |= n2 >>> 4;
      n2 |= n2 >>> 8;
      n2 |= n2 >>> 16;
      n2++;
    }
    return n2;
  }
  __name(computeNewHighWaterMark, "computeNewHighWaterMark");
  function howMuchToRead(n2, state) {
    if (n2 <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n2 !== n2) {
      if (state.flowing && state.length) return state.buffer.head.data.length;
      else return state.length;
    }
    if (n2 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n2);
    if (n2 <= state.length) return n2;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  __name(howMuchToRead, "howMuchToRead");
  Readable.prototype.read = function(n2) {
    debug$2("read", n2);
    n2 = parseInt(n2, 10);
    var state = this._readableState;
    var nOrig = n2;
    if (n2 !== 0) state.emittedReadable = false;
    if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug$2("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n2 = howMuchToRead(n2, state);
    if (n2 === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug$2("need readable", doRead);
    if (state.length === 0 || state.length - n2 < state.highWaterMark) {
      doRead = true;
      debug$2("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug$2("reading or ended", doRead);
    } else if (doRead) {
      debug$2("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0) state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading) n2 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n2 > 0) ret = fromList(n2, state);
    else ret = null;
    if (ret === null) {
      state.needReadable = true;
      n2 = 0;
    } else state.length -= n2;
    if (state.length === 0) {
      if (!state.ended) state.needReadable = true;
      if (nOrig !== n2 && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function chunkInvalid(state, chunk) {
    var er = null;
    if (!isBuffer$2(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) er = new TypeError("Invalid non-string/buffer chunk");
    return er;
  }
  __name(chunkInvalid, "chunkInvalid");
  function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  __name(onEofChunk, "onEofChunk");
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug$2("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync) nextTick(emitReadable_, stream);
      else emitReadable_(stream);
    }
  }
  __name(emitReadable, "emitReadable");
  function emitReadable_(stream) {
    debug$2("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  __name(emitReadable_, "emitReadable_");
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick(maybeReadMore_, stream, state);
    }
  }
  __name(maybeReadMore, "maybeReadMore");
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug$2("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length) break;
      else len = state.length;
    }
    state.readingMore = false;
  }
  __name(maybeReadMore_, "maybeReadMore_");
  Readable.prototype._read = function(n2) {
    this.emit("error", new Error("not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [
          state.pipes,
          dest
        ];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug$2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = !pipeOpts || pipeOpts.end !== false;
    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted) nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable) {
      debug$2("onunpipe");
      if (readable === src2) cleanup();
    }
    __name(onunpipe, "onunpipe");
    function onend() {
      debug$2("onend");
      dest.end();
    }
    __name(onend, "onend");
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug$2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", cleanup);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    __name(cleanup, "cleanup");
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug$2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug$2("false write response, pause", src2._readableState.awaitDrain);
          src2._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    __name(ondata, "ondata");
    function onerror(er) {
      debug$2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (listenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    __name(onerror, "onerror");
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    __name(onclose, "onclose");
    dest.once("close", onclose);
    function onfinish() {
      debug$2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    __name(onfinish, "onfinish");
    dest.once("finish", onfinish);
    function unpipe() {
      debug$2("unpipe");
      src2.unpipe(dest);
    }
    __name(unpipe, "unpipe");
    dest.emit("pipe", src2);
    if (!state.flowing) {
      debug$2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state = src2._readableState;
      debug$2("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && src2.listeners("data").length) {
        state.flowing = true;
        flow(src2);
      }
    };
  }
  __name(pipeOnDrain, "pipeOnDrain");
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    if (state.pipesCount === 0) return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit("unpipe", this);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var _i = 0; _i < len; _i++) dests[_i].emit("unpipe", this);
      return this;
    }
    var i2 = indexOf(state.pipes, dest);
    if (i2 === -1) return this;
    state.pipes.splice(i2, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = EventEmitter$2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) nextTick(nReadingNextTick, this);
        else if (state.length) emitReadable(this);
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug$2("readable nexttick read 0");
    self2.read(0);
  }
  __name(nReadingNextTick, "nReadingNextTick");
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug$2("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick(resume_, stream, state);
    }
  }
  __name(resume, "resume");
  function resume_(stream, state) {
    if (!state.reading) {
      debug$2("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }
  __name(resume_, "resume_");
  Readable.prototype.pause = function() {
    debug$2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug$2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug$2("flow", state.flowing);
    while (state.flowing && stream.read() !== null) ;
  }
  __name(flow, "flow");
  Readable.prototype.wrap = function(stream) {
    var state = this._readableState;
    var paused = false;
    var self2 = this;
    stream.on("end", function() {
      debug$2("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) self2.push(chunk);
      }
      self2.push(null);
    });
    stream.on("data", function(chunk) {
      debug$2("wrapped data");
      if (state.decoder) chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state.objectMode && (!chunk || !chunk.length)) return;
      var ret = self2.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i2 in stream) if (this[i2] === void 0 && typeof stream[i2] === "function") this[i2] = /* @__PURE__ */ (function(method) {
      return function() {
        return stream[method].apply(stream, arguments);
      };
    })(i2);
    var events = [
      "error",
      "close",
      "destroy",
      "pause",
      "resume"
    ];
    forEach(events, function(ev) {
      stream.on(ev, self2.emit.bind(self2, ev));
    });
    self2._read = function(n2) {
      debug$2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return self2;
  };
  Readable._fromList = fromList;
  function fromList(n2, state) {
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n2 || n2 >= state.length) {
      if (state.decoder) ret = state.buffer.join("");
      else if (state.buffer.length === 1) ret = state.buffer.head.data;
      else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else
      ret = fromListPartial(n2, state.buffer, state.decoder);
    return ret;
  }
  __name(fromList, "fromList");
  function fromListPartial(n2, list, hasStrings) {
    var ret;
    if (n2 < list.head.data.length) {
      ret = list.head.data.slice(0, n2);
      list.head.data = list.head.data.slice(n2);
    } else if (n2 === list.head.data.length)
      ret = list.shift();
    else
      ret = hasStrings ? copyFromBufferString(n2, list) : copyFromBuffer(n2, list);
    return ret;
  }
  __name(fromListPartial, "fromListPartial");
  function copyFromBufferString(n2, list) {
    var p2 = list.head;
    var c2 = 1;
    var ret = p2.data;
    n2 -= ret.length;
    while (p2 = p2.next) {
      var str = p2.data;
      var nb = n2 > str.length ? str.length : n2;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n2);
      n2 -= nb;
      if (n2 === 0) {
        if (nb === str.length) {
          ++c2;
          if (p2.next) list.head = p2.next;
          else list.head = list.tail = null;
        } else {
          list.head = p2;
          p2.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  __name(copyFromBufferString, "copyFromBufferString");
  function copyFromBuffer(n2, list) {
    var ret = Buffer$1.allocUnsafe(n2);
    var p2 = list.head;
    var c2 = 1;
    p2.data.copy(ret);
    n2 -= p2.data.length;
    while (p2 = p2.next) {
      var buf = p2.data;
      var nb = n2 > buf.length ? buf.length : n2;
      buf.copy(ret, ret.length - n2, 0, nb);
      n2 -= nb;
      if (n2 === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p2.next) list.head = p2.next;
          else list.head = list.tail = null;
        } else {
          list.head = p2;
          p2.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  __name(copyFromBuffer, "copyFromBuffer");
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      nextTick(endReadableNT, state, stream);
    }
  }
  __name(endReadable, "endReadable");
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  __name(endReadableNT, "endReadableNT");
  function forEach(xs, f2) {
    for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) f2(xs[i2], i2);
  }
  __name(forEach, "forEach");
  function indexOf(xs, x) {
    for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
      if (xs[i2] === x) return i2;
    }
    return -1;
  }
  __name(indexOf, "indexOf");
  Writable.WritableState = WritableState;
  inherits$3(Writable, EventEmitter$2);
  function nop() {
  }
  __name(nop, "nop");
  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }
  __name(WriteReq, "WriteReq");
  function WritableState(options, stream) {
    Object.defineProperty(this, "buffer", {
      get: deprecate$1(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
    });
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16384;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  __name(WritableState, "WritableState");
  WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  }, "writableStateGetBuffer");
  function Writable(options) {
    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
    }
    EventEmitter$2.call(this);
  }
  __name(Writable, "Writable");
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    nextTick(cb, er);
  }
  __name(writeAfterEnd, "writeAfterEnd");
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) er = new TypeError("May not write null values to stream");
    else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) er = new TypeError("Invalid non-string/buffer chunk");
    if (er) {
      stream.emit("error", er);
      nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  __name(validChunk, "validChunk");
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (Buffer2.isBuffer(chunk)) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ended) writeAfterEnd(this, cb);
    else if (validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
      "hex",
      "utf8",
      "utf-8",
      "ascii",
      "binary",
      "base64",
      "ucs2",
      "ucs-2",
      "utf16le",
      "utf-16le",
      "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  }, "setDefaultEncoding");
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = Buffer2.from(chunk, encoding);
    return chunk;
  }
  __name(decodeChunk, "decodeChunk");
  function writeOrBuffer(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer2.isBuffer(chunk)) encoding = "buffer";
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) last.next = state.lastBufferedRequest;
      else state.bufferedRequest = state.lastBufferedRequest;
      state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
  }
  __name(writeOrBuffer, "writeOrBuffer");
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  __name(doWrite, "doWrite");
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) nextTick(cb, er);
    else cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit("error", er);
  }
  __name(onwriteError, "onwriteError");
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  __name(onwriteStateUpdate, "onwriteStateUpdate");
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
      if (sync) nextTick(afterWrite, stream, state, finished, cb);
      else afterWrite(stream, state, finished, cb);
    }
  }
  __name(onwrite, "onwrite");
  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  __name(afterWrite, "afterWrite");
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  __name(onwriteDrain, "onwriteDrain");
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state.bufferedRequestCount;
      var buffer = new Array(l2);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else state.corkedRequestsFree = new CorkedRequest(state);
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        if (state.writing) break;
      }
      if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  __name(clearBuffer, "clearBuffer");
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished) endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  __name(needFinish, "needFinish");
  function prefinish(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
  __name(prefinish, "prefinish");
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit("finish");
      } else prefinish(stream, state);
    }
    return need;
  }
  __name(finishMaybe, "finishMaybe");
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) nextTick(cb);
      else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  __name(endWritable, "endWritable");
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function(err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) state.corkedRequestsFree.next = _this;
      else state.corkedRequestsFree = _this;
    };
  }
  __name(CorkedRequest, "CorkedRequest");
  inherits$3(Duplex, Readable);
  var keys1 = Object.keys(Writable.prototype);
  for (var v1 = 0; v1 < keys1.length; v1++) {
    var method1 = keys1[v1];
    if (!Duplex.prototype[method1]) Duplex.prototype[method1] = Writable.prototype[method1];
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend1);
  }
  __name(Duplex, "Duplex");
  function onend1() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    nextTick(onEndNT, this);
  }
  __name(onend1, "onend1");
  function onEndNT(self2) {
    self2.end();
  }
  __name(onEndNT, "onEndNT");
  inherits$3(Transform, Duplex);
  function TransformState(stream) {
    this.afterTransform = function(er, data) {
      return afterTransform(stream, er, data);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }
  __name(TransformState, "TransformState");
  function afterTransform(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) return stream.emit("error", new Error("no writecb in Transform class"));
    ts.writechunk = null;
    ts.writecb = null;
    if (data !== null && data !== void 0) stream.push(data);
    cb(er);
    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) stream._read(rs.highWaterMark);
  }
  __name(afterTransform, "afterTransform");
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = new TransformState(this);
    var stream = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.once("prefinish", function() {
      if (typeof this._flush === "function") this._flush(function(er) {
        done1(stream, er);
      });
      else done1(stream);
    });
  }
  __name(Transform, "Transform");
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("Not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n2) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else
      ts.needTransform = true;
  };
  function done1(stream, er) {
    if (er) return stream.emit("error", er);
    var ws = stream._writableState;
    var ts = stream._transformState;
    if (ws.length) throw new Error("Calling transform done when ws.length != 0");
    if (ts.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
  __name(done1, "done1");
  inherits$3(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  __name(PassThrough, "PassThrough");
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  inherits$3(Stream, EventEmitter$2);
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex;
  Stream.Transform = Transform;
  Stream.PassThrough = PassThrough;
  Stream.Stream = Stream;
  function Stream() {
    EventEmitter$2.call(this);
  }
  __name(Stream, "Stream");
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) source.pause();
      }
    }
    __name(ondata, "ondata");
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) source.resume();
    }
    __name(ondrain, "ondrain");
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    __name(onend, "onend");
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    __name(onclose, "onclose");
    function onerror(er) {
      cleanup();
      if (EventEmitter$2.listenerCount(this, "error") === 0) throw er;
    }
    __name(onerror, "onerror");
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    __name(cleanup, "cleanup");
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  var WritableStream = Stream.Writable;
  var inherits$1 = util.inherits;
  var browserStdout = BrowserStdout;
  inherits$1(BrowserStdout, WritableStream);
  function BrowserStdout(opts) {
    if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts);
    opts = opts || {};
    WritableStream.call(this, opts);
    this.label = opts.label !== void 0 ? opts.label : "stdout";
  }
  __name(BrowserStdout, "BrowserStdout");
  BrowserStdout.prototype._write = function(chunks, encoding, cb) {
    var output = chunks.toString ? chunks.toString() : chunks;
    if (this.label === false) console.log(output);
    else console.log(this.label + ":", output);
    nextTick$1(cb);
  };
  var parseQuery = /* @__PURE__ */ __name(function parseQuery2(qs) {
    return qs.replace("?", "").split("&").reduce(function(obj, pair) {
      var i2 = pair.indexOf("=");
      var key = pair.slice(0, i2);
      var val = pair.slice(++i2);
      obj[key] = decodeURIComponent(val.replace(/\+/g, "%20"));
      return obj;
    }, {});
  }, "parseQuery");
  function highlight(js) {
    return js.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>').replace(/('.*?')/gm, '<span class="string">$1</span>').replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>').replace(/(\d+)/gm, '<span class="number">$1</span>').replace(/\bnew[ \t]+(\w+)/gm, '<span class="keyword">new</span> <span class="init">$1</span>').replace(/\b(function|new|throw|return|var|if|else)\b/gm, '<span class="keyword">$1</span>');
  }
  __name(highlight, "highlight");
  var highlightTags = /* @__PURE__ */ __name(function highlightTags2(name) {
    var code = document.getElementById("mocha").getElementsByTagName(name);
    for (var i2 = 0, len = code.length; i2 < len; ++i2) code[i2].innerHTML = highlight(code[i2].innerHTML);
  }, "highlightTags");
  var escapeStringRegexp = /* @__PURE__ */ __name((string) => {
    if (typeof string !== "string") throw new TypeError("Expected a string");
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }, "escapeStringRegexp");
  function normalizeArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i2 = parts.length - 1; i2 >= 0; i2--) {
      var last = parts[i2];
      if (last === ".") parts.splice(i2, 1);
      else if (last === "..") {
        parts.splice(i2, 1);
        up++;
      } else if (up) {
        parts.splice(i2, 1);
        up--;
      }
    }
    if (allowAboveRoot) for (; up--; ) parts.unshift("..");
    return parts;
  }
  __name(normalizeArray, "normalizeArray");
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = /* @__PURE__ */ __name(function(filename) {
    return splitPathRe.exec(filename).slice(1);
  }, "splitPath");
  function resolve1() {
    var resolvedPath = "", resolvedAbsolute = false;
    for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
      var path = i2 >= 0 ? arguments[i2] : "/";
      if (typeof path !== "string") throw new TypeError("Arguments to path.resolve must be strings");
      else if (!path) continue;
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = path.charAt(0) === "/";
    }
    resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p2) {
      return !!p2;
    }), !resolvedAbsolute).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  }
  __name(resolve1, "resolve1");
  function normalize(path) {
    var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/";
    path = normalizeArray(filter(path.split("/"), function(p2) {
      return !!p2;
    }), !isPathAbsolute).join("/");
    if (!path && !isPathAbsolute) path = ".";
    if (path && trailingSlash) path += "/";
    return (isPathAbsolute ? "/" : "") + path;
  }
  __name(normalize, "normalize");
  function isAbsolute(path) {
    return path.charAt(0) === "/";
  }
  __name(isAbsolute, "isAbsolute");
  function join() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize(filter(paths, function(p2, index) {
      if (typeof p2 !== "string") throw new TypeError("Arguments to path.join must be strings");
      return p2;
    }).join("/"));
  }
  __name(join, "join");
  function relative(from2, to) {
    from2 = resolve1(from2).substr(1);
    to = resolve1(to).substr(1);
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "") break;
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "") break;
      }
      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }
    __name(trim, "trim");
    var fromParts = trim(from2.split("/"));
    var toParts = trim(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i2 = 0; i2 < length; i2++) if (fromParts[i2] !== toParts[i2]) {
      samePartsLength = i2;
      break;
    }
    var outputParts = [];
    for (var i2 = samePartsLength; i2 < fromParts.length; i2++) outputParts.push("..");
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
  __name(relative, "relative");
  var sep = "/";
  var delimiter1 = ":";
  function dirname(path) {
    var result = splitPath(path), root2 = result[0], dir = result[1];
    if (!root2 && !dir)
      return ".";
    if (dir)
      dir = dir.substr(0, dir.length - 1);
    return root2 + dir;
  }
  __name(dirname, "dirname");
  function basename(path, ext) {
    var f2 = splitPath(path)[2];
    if (ext && f2.substr(-1 * ext.length) === ext) f2 = f2.substr(0, f2.length - ext.length);
    return f2;
  }
  __name(basename, "basename");
  function extname(path) {
    return splitPath(path)[3];
  }
  __name(extname, "extname");
  var path1 = {
    extname,
    basename,
    dirname,
    sep,
    delimiter: delimiter1,
    relative,
    join,
    isAbsolute,
    normalize,
    resolve: resolve1
  };
  function filter(xs, f2) {
    if (xs.filter) return xs.filter(f2);
    var res = [];
    for (var i2 = 0; i2 < xs.length; i2++) if (f2(xs[i2], i2, xs)) res.push(xs[i2]);
    return res;
  }
  __name(filter, "filter");
  var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
    return str.substr(start, len);
  } : function(str, start, len) {
    if (start < 0) start = str.length + start;
    return str.substr(start, len);
  };
  var diff$1 = createCommonjsModule(function(module, exports1) {
    (function(global2, factory) {
      factory(exports1);
    })(commonjsGlobal, function(exports) {
      function Diff() {
      }
      __name(Diff, "Diff");
      Diff.prototype = {
        diff: /* @__PURE__ */ __name(function diff(oldString, newString) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var callback = options.callback;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          this.options = options;
          var self2 = this;
          function done(value) {
            if (callback) {
              setTimeout(function() {
                callback(void 0, value);
              }, 0);
              return true;
            } else return value;
          }
          __name(done, "done");
          oldString = this.castInput(oldString);
          newString = this.castInput(newString);
          oldString = this.removeEmpty(this.tokenize(oldString));
          newString = this.removeEmpty(this.tokenize(newString));
          var newLen = newString.length, oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [
            {
              newPos: -1,
              components: []
            }
          ];
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen)
            return done([
              {
                value: this.join(newString),
                count: newString.length
              }
            ]);
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = void 0;
              var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath)
                bestPath[diagonalPath - 1] = void 0;
              var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = void 0;
                continue;
              }
              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self2.pushComponent(basePath.components, void 0, true);
              } else {
                basePath = addPath;
                basePath.newPos++;
                self2.pushComponent(basePath.components, true, void 0);
              }
              _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
              if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
              else
                bestPath[diagonalPath] = basePath;
            }
            editLength++;
          }
          __name(execEditLength, "execEditLength");
          if (callback) (/* @__PURE__ */ __name((function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) return callback();
              if (!execEditLength()) exec();
            }, 0);
          }), "exec"))();
          else while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) return ret;
          }
        }, "diff"),
        pushComponent: /* @__PURE__ */ __name(function pushComponent(components, added, removed) {
          var last = components[components.length - 1];
          if (last && last.added === added && last.removed === removed)
            components[components.length - 1] = {
              count: last.count + 1,
              added,
              removed
            };
          else components.push({
            count: 1,
            added,
            removed
          });
        }, "pushComponent"),
        extractCommon: /* @__PURE__ */ __name(function extractCommon(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
          if (commonCount) basePath.components.push({
            count: commonCount
          });
          basePath.newPos = newPos;
          return oldPos;
        }, "extractCommon"),
        equals: /* @__PURE__ */ __name(function equals(left, right) {
          if (this.options.comparator) return this.options.comparator(left, right);
          else return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }, "equals"),
        removeEmpty: /* @__PURE__ */ __name(function removeEmpty(array) {
          var ret = [];
          for (var i2 = 0; i2 < array.length; i2++) if (array[i2]) ret.push(array[i2]);
          return ret;
        }, "removeEmpty"),
        castInput: /* @__PURE__ */ __name(function castInput(value) {
          return value;
        }, "castInput"),
        tokenize: /* @__PURE__ */ __name(function tokenize(value) {
          return value.split("");
        }, "tokenize"),
        join: /* @__PURE__ */ __name(function join2(chars) {
          return chars.join("");
        }, "join")
      };
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value1 = newString.slice(newPos, newPos + component.count);
              value1 = value1.map(function(value, i2) {
                var oldValue = oldString[oldPos + i2];
                return oldValue.length > value.length ? oldValue : value;
              });
              component.value = diff.join(value1);
            } else component.value = diff.join(newString.slice(newPos, newPos + component.count));
            newPos += component.count;
            if (!component.added) oldPos += component.count;
          } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
        var lastComponent = components[componentLen - 1];
        if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
          components[componentLen - 2].value += lastComponent.value;
          components.pop();
        }
        return components;
      }
      __name(buildValues, "buildValues");
      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }
      __name(clonePath, "clonePath");
      var characterDiff = new Diff();
      function diffChars(oldStr, newStr, options) {
        return characterDiff.diff(oldStr, newStr, options);
      }
      __name(diffChars, "diffChars");
      function generateOptions(options, defaults) {
        if (typeof options === "function") defaults.callback = options;
        else if (options) {
          for (var name in options) if (options.hasOwnProperty(name)) defaults[name] = options[name];
        }
        return defaults;
      }
      __name(generateOptions, "generateOptions");
      var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
      var reWhitespace = /\S/;
      var wordDiff = new Diff();
      wordDiff.equals = function(left, right) {
        if (this.options.ignoreCase) {
          left = left.toLowerCase();
          right = right.toLowerCase();
        }
        return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
      };
      wordDiff.tokenize = function(value) {
        var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
        for (var i2 = 0; i2 < tokens.length - 1; i2++)
          if (!tokens[i2 + 1] && tokens[i2 + 2] && extendedWordChars.test(tokens[i2]) && extendedWordChars.test(tokens[i2 + 2])) {
            tokens[i2] += tokens[i2 + 2];
            tokens.splice(i2 + 1, 2);
            i2--;
          }
        return tokens;
      };
      function diffWords(oldStr, newStr, options) {
        options = generateOptions(options, {
          ignoreWhitespace: true
        });
        return wordDiff.diff(oldStr, newStr, options);
      }
      __name(diffWords, "diffWords");
      function diffWordsWithSpace(oldStr, newStr, options) {
        return wordDiff.diff(oldStr, newStr, options);
      }
      __name(diffWordsWithSpace, "diffWordsWithSpace");
      var lineDiff = new Diff();
      lineDiff.tokenize = function(value) {
        var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
        if (!linesAndNewlines[linesAndNewlines.length - 1]) linesAndNewlines.pop();
        for (var i2 = 0; i2 < linesAndNewlines.length; i2++) {
          var line = linesAndNewlines[i2];
          if (i2 % 2 && !this.options.newlineIsToken) retLines[retLines.length - 1] += line;
          else {
            if (this.options.ignoreWhitespace) line = line.trim();
            retLines.push(line);
          }
        }
        return retLines;
      };
      function diffLines(oldStr, newStr, callback) {
        return lineDiff.diff(oldStr, newStr, callback);
      }
      __name(diffLines, "diffLines");
      function diffTrimmedLines(oldStr, newStr, callback) {
        var options = generateOptions(callback, {
          ignoreWhitespace: true
        });
        return lineDiff.diff(oldStr, newStr, options);
      }
      __name(diffTrimmedLines, "diffTrimmedLines");
      var sentenceDiff = new Diff();
      sentenceDiff.tokenize = function(value) {
        return value.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      function diffSentences(oldStr, newStr, callback) {
        return sentenceDiff.diff(oldStr, newStr, callback);
      }
      __name(diffSentences, "diffSentences");
      var cssDiff = new Diff();
      cssDiff.tokenize = function(value) {
        return value.split(/([{}:;,]|\s+)/);
      };
      function diffCss(oldStr, newStr, callback) {
        return cssDiff.diff(oldStr, newStr, callback);
      }
      __name(diffCss, "diffCss");
      function _typeof(obj1) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = /* @__PURE__ */ __name(function(obj) {
          return typeof obj;
        }, "_typeof");
        else _typeof = /* @__PURE__ */ __name(function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, "_typeof");
        return _typeof(obj1);
      }
      __name(_typeof, "_typeof");
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      __name(_toConsumableArray, "_toConsumableArray");
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }
      __name(_arrayWithoutHoles, "_arrayWithoutHoles");
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }
      __name(_iterableToArray, "_iterableToArray");
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2) return;
        if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set") return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
      }
      __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
        return arr2;
      }
      __name(_arrayLikeToArray, "_arrayLikeToArray");
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      __name(_nonIterableSpread, "_nonIterableSpread");
      var objectPrototypeToString = Object.prototype.toString;
      var jsonDiff = new Diff();
      jsonDiff.useLongestToken = true;
      jsonDiff.tokenize = lineDiff.tokenize;
      jsonDiff.castInput = function(value) {
        var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
          return typeof v === "undefined" ? undefinedReplacement : v;
        } : _this$options$stringi;
        return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
      };
      jsonDiff.equals = function(left, right) {
        return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
      };
      function diffJson(oldObj, newObj, options) {
        return jsonDiff.diff(oldObj, newObj, options);
      }
      __name(diffJson, "diffJson");
      function canonicalize(obj, stack, replacementStack, replacer, key) {
        stack = stack || [];
        replacementStack = replacementStack || [];
        if (replacer) obj = replacer(key, obj);
        var i2;
        for (i2 = 0; i2 < stack.length; i2 += 1) {
          if (stack[i2] === obj) return replacementStack[i2];
        }
        var canonicalizedObj;
        if ("[object Array]" === objectPrototypeToString.call(obj)) {
          stack.push(obj);
          canonicalizedObj = new Array(obj.length);
          replacementStack.push(canonicalizedObj);
          for (i2 = 0; i2 < obj.length; i2 += 1) canonicalizedObj[i2] = canonicalize(obj[i2], stack, replacementStack, replacer, key);
          stack.pop();
          replacementStack.pop();
          return canonicalizedObj;
        }
        if (obj && obj.toJSON) obj = obj.toJSON();
        if (_typeof(obj) === "object" && obj !== null) {
          stack.push(obj);
          canonicalizedObj = {};
          replacementStack.push(canonicalizedObj);
          var sortedKeys = [], _key;
          for (_key in obj) if (obj.hasOwnProperty(_key)) sortedKeys.push(_key);
          sortedKeys.sort();
          for (i2 = 0; i2 < sortedKeys.length; i2 += 1) {
            _key = sortedKeys[i2];
            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
          }
          stack.pop();
          replacementStack.pop();
        } else canonicalizedObj = obj;
        return canonicalizedObj;
      }
      __name(canonicalize, "canonicalize");
      var arrayDiff = new Diff();
      arrayDiff.tokenize = function(value) {
        return value.slice();
      };
      arrayDiff.join = arrayDiff.removeEmpty = function(value) {
        return value;
      };
      function diffArrays(oldArr, newArr, callback) {
        return arrayDiff.diff(oldArr, newArr, callback);
      }
      __name(diffArrays, "diffArrays");
      function parsePatch(uniDiff) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i2 = 0;
        function parseIndex() {
          var index = {};
          list.push(index);
          while (i2 < diffstr.length) {
            var line = diffstr[i2];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) break;
            var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
            if (header) index.index = header[1];
            i2++;
          }
          parseFileHeader(index);
          parseFileHeader(index);
          index.hunks = [];
          while (i2 < diffstr.length) {
            var _line = diffstr[i2];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) break;
            else if (/^@@/.test(_line)) index.hunks.push(parseHunk());
            else if (_line && options.strict)
              throw new Error("Unknown line " + (i2 + 1) + " " + JSON.stringify(_line));
            else i2++;
          }
        }
        __name(parseIndex, "parseIndex");
        function parseFileHeader(index) {
          var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i2]);
          if (fileHeader) {
            var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
            var data = fileHeader[2].split("	", 2);
            var fileName = data[0].replace(/\\\\/g, "\\");
            if (/^".*"$/.test(fileName)) fileName = fileName.substr(1, fileName.length - 2);
            index[keyPrefix + "FileName"] = fileName;
            index[keyPrefix + "Header"] = (data[1] || "").trim();
            i2++;
          }
        }
        __name(parseFileHeader, "parseFileHeader");
        function parseHunk() {
          var chunkHeaderIndex = i2, chunkHeaderLine = diffstr[i2++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
          var hunk = {
            oldStart: +chunkHeader[1],
            oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
            newStart: +chunkHeader[3],
            newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
            lines: [],
            linedelimiters: []
          };
          if (hunk.oldLines === 0) hunk.oldStart += 1;
          if (hunk.newLines === 0) hunk.newStart += 1;
          var addCount = 0, removeCount = 0;
          for (; i2 < diffstr.length; i2++) {
            if (diffstr[i2].indexOf("--- ") === 0 && i2 + 2 < diffstr.length && diffstr[i2 + 1].indexOf("+++ ") === 0 && diffstr[i2 + 2].indexOf("@@") === 0) break;
            var operation = diffstr[i2].length == 0 && i2 != diffstr.length - 1 ? " " : diffstr[i2][0];
            if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
              hunk.lines.push(diffstr[i2]);
              hunk.linedelimiters.push(delimiters[i2] || "\n");
              if (operation === "+") addCount++;
              else if (operation === "-") removeCount++;
              else if (operation === " ") {
                addCount++;
                removeCount++;
              }
            } else break;
          }
          if (!addCount && hunk.newLines === 1) hunk.newLines = 0;
          if (!removeCount && hunk.oldLines === 1) hunk.oldLines = 0;
          if (options.strict) {
            if (addCount !== hunk.newLines) throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
            if (removeCount !== hunk.oldLines) throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
          return hunk;
        }
        __name(parseHunk, "parseHunk");
        while (i2 < diffstr.length) parseIndex();
        return list;
      }
      __name(parsePatch, "parsePatch");
      function distanceIterator(start, minLine, maxLine) {
        var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
        return /* @__PURE__ */ __name(function iterator() {
          if (wantForward && !forwardExhausted) {
            if (backwardExhausted) localOffset++;
            else wantForward = false;
            if (start + localOffset <= maxLine) return localOffset;
            forwardExhausted = true;
          }
          if (!backwardExhausted) {
            if (!forwardExhausted) wantForward = true;
            if (minLine <= start - localOffset) return -localOffset++;
            backwardExhausted = true;
            return iterator();
          }
        }, "iterator");
      }
      __name(distanceIterator, "distanceIterator");
      function applyPatch(source, uniDiff) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (typeof uniDiff === "string") uniDiff = parsePatch(uniDiff);
        if (Array.isArray(uniDiff)) {
          if (uniDiff.length > 1) throw new Error("applyPatch only works with a single input.");
          uniDiff = uniDiff[0];
        }
        var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {
          return line === patchContent;
        }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
        function hunkFits(hunk, toPos) {
          for (var j = 0; j < hunk.lines.length; j++) {
            var line = hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line;
            if (operation === " " || operation === "-") {
              if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
                errorCount++;
                if (errorCount > fuzzFactor) return false;
              }
              toPos++;
            }
          }
          return true;
        }
        __name(hunkFits, "hunkFits");
        for (var i2 = 0; i2 < hunks.length; i2++) {
          var hunk1 = hunks[i2], maxLine = lines.length - hunk1.oldLines, localOffset = 0, toPos1 = offset + hunk1.oldStart - 1;
          var iterator = distanceIterator(toPos1, minLine, maxLine);
          for (; localOffset !== void 0; localOffset = iterator()) if (hunkFits(hunk1, toPos1 + localOffset)) {
            hunk1.offset = offset += localOffset;
            break;
          }
          if (localOffset === void 0) return false;
          minLine = hunk1.offset + hunk1.oldStart + hunk1.oldLines;
        }
        var diffOffset = 0;
        for (var _i = 0; _i < hunks.length; _i++) {
          var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
          diffOffset += _hunk.newLines - _hunk.oldLines;
          for (var j1 = 0; j1 < _hunk.lines.length; j1++) {
            var line1 = _hunk.lines[j1], operation1 = line1.length > 0 ? line1[0] : " ", content1 = line1.length > 0 ? line1.substr(1) : line1, delimiter = _hunk.linedelimiters[j1];
            if (operation1 === " ") _toPos++;
            else if (operation1 === "-") {
              lines.splice(_toPos, 1);
              delimiters.splice(_toPos, 1);
            } else if (operation1 === "+") {
              lines.splice(_toPos, 0, content1);
              delimiters.splice(_toPos, 0, delimiter);
              _toPos++;
            } else if (operation1 === "\\") {
              var previousOperation = _hunk.lines[j1 - 1] ? _hunk.lines[j1 - 1][0] : null;
              if (previousOperation === "+") removeEOFNL = true;
              else if (previousOperation === "-") addEOFNL = true;
            }
          }
        }
        if (removeEOFNL) while (!lines[lines.length - 1]) {
          lines.pop();
          delimiters.pop();
        }
        else if (addEOFNL) {
          lines.push("");
          delimiters.push("\n");
        }
        for (var _k = 0; _k < lines.length - 1; _k++) lines[_k] = lines[_k] + delimiters[_k];
        return lines.join("");
      }
      __name(applyPatch, "applyPatch");
      function applyPatches(uniDiff, options) {
        if (typeof uniDiff === "string") uniDiff = parsePatch(uniDiff);
        var currentIndex = 0;
        function processIndex() {
          var index = uniDiff[currentIndex++];
          if (!index) return options.complete();
          options.loadFile(index, function(err1, data) {
            if (err1) return options.complete(err1);
            var updatedContent = applyPatch(data, index, options);
            options.patched(index, updatedContent, function(err) {
              if (err) return options.complete(err);
              processIndex();
            });
          });
        }
        __name(processIndex, "processIndex");
        processIndex();
      }
      __name(applyPatches, "applyPatches");
      function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        if (!options) options = {};
        if (typeof options.context === "undefined") options.context = 4;
        var diff = diffLines(oldStr, newStr, options);
        diff.push({
          value: "",
          lines: []
        });
        function contextLines(lines) {
          return lines.map(function(entry) {
            return " " + entry;
          });
        }
        __name(contextLines, "contextLines");
        var hunks = [];
        var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
        var _loop = /* @__PURE__ */ __name(function _loop2(i2) {
          var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
          current.lines = lines;
          if (current.added || current.removed) {
            var _curRange;
            if (!oldRangeStart) {
              var prev = diff[i2 - 1];
              oldRangeStart = oldLine;
              newRangeStart = newLine;
              if (prev) {
                curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
                oldRangeStart -= curRange.length;
                newRangeStart -= curRange.length;
              }
            }
            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
              return (current.added ? "+" : "-") + entry;
            })));
            if (current.added) newLine += lines.length;
            else oldLine += lines.length;
          } else {
            if (oldRangeStart) {
              if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
                var _curRange2;
                (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
              } else {
                var _curRange3;
                var contextSize = Math.min(lines.length, options.context);
                (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                var hunk = {
                  oldStart: oldRangeStart,
                  oldLines: oldLine - oldRangeStart + contextSize,
                  newStart: newRangeStart,
                  newLines: newLine - newRangeStart + contextSize,
                  lines: curRange
                };
                if (i2 >= diff.length - 2 && lines.length <= options.context) {
                  var oldEOFNewline = /\n$/.test(oldStr);
                  var newEOFNewline = /\n$/.test(newStr);
                  var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                  if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0)
                    curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                  if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) curRange.push("\\ No newline at end of file");
                }
                hunks.push(hunk);
                oldRangeStart = 0;
                newRangeStart = 0;
                curRange = [];
              }
            }
            oldLine += lines.length;
            newLine += lines.length;
          }
        }, "_loop");
        for (var i3 = 0; i3 < diff.length; i3++) _loop(i3);
        return {
          oldFileName,
          newFileName,
          oldHeader,
          newHeader,
          hunks
        };
      }
      __name(structuredPatch, "structuredPatch");
      function formatPatch(diff) {
        var ret = [];
        if (diff.oldFileName == diff.newFileName) ret.push("Index: " + diff.oldFileName);
        ret.push("===================================================================");
        ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
        ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
        for (var i2 = 0; i2 < diff.hunks.length; i2++) {
          var hunk = diff.hunks[i2];
          if (hunk.oldLines === 0) hunk.oldStart -= 1;
          if (hunk.newLines === 0) hunk.newStart -= 1;
          ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
          ret.push.apply(ret, hunk.lines);
        }
        return ret.join("\n") + "\n";
      }
      __name(formatPatch, "formatPatch");
      function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
      }
      __name(createTwoFilesPatch, "createTwoFilesPatch");
      function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
        return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
      }
      __name(createPatch, "createPatch");
      function arrayEqual(a2, b) {
        if (a2.length !== b.length) return false;
        return arrayStartsWith(a2, b);
      }
      __name(arrayEqual, "arrayEqual");
      function arrayStartsWith(array, start) {
        if (start.length > array.length) return false;
        for (var i2 = 0; i2 < start.length; i2++) {
          if (start[i2] !== array[i2]) return false;
        }
        return true;
      }
      __name(arrayStartsWith, "arrayStartsWith");
      function calcLineCount(hunk) {
        var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
        if (oldLines !== void 0) hunk.oldLines = oldLines;
        else delete hunk.oldLines;
        if (newLines !== void 0) hunk.newLines = newLines;
        else delete hunk.newLines;
      }
      __name(calcLineCount, "calcLineCount");
      function merge(mine, theirs, base2) {
        mine = loadPatch(mine, base2);
        theirs = loadPatch(theirs, base2);
        var ret = {};
        if (mine.index || theirs.index) ret.index = mine.index || theirs.index;
        if (mine.newFileName || theirs.newFileName) {
          if (!fileNameChanged(mine)) {
            ret.oldFileName = theirs.oldFileName || mine.oldFileName;
            ret.newFileName = theirs.newFileName || mine.newFileName;
            ret.oldHeader = theirs.oldHeader || mine.oldHeader;
            ret.newHeader = theirs.newHeader || mine.newHeader;
          } else if (!fileNameChanged(theirs)) {
            ret.oldFileName = mine.oldFileName;
            ret.newFileName = mine.newFileName;
            ret.oldHeader = mine.oldHeader;
            ret.newHeader = mine.newHeader;
          } else {
            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
          }
        }
        ret.hunks = [];
        var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
        while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
          var mineCurrent = mine.hunks[mineIndex] || {
            oldStart: Infinity
          }, theirsCurrent = theirs.hunks[theirsIndex] || {
            oldStart: Infinity
          };
          if (hunkBefore(mineCurrent, theirsCurrent)) {
            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
            mineIndex++;
            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
          } else if (hunkBefore(theirsCurrent, mineCurrent)) {
            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
            theirsIndex++;
            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
          } else {
            var mergedHunk = {
              oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
              oldLines: 0,
              newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
              newLines: 0,
              lines: []
            };
            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
            theirsIndex++;
            mineIndex++;
            ret.hunks.push(mergedHunk);
          }
        }
        return ret;
      }
      __name(merge, "merge");
      function loadPatch(param, base2) {
        if (typeof param === "string") {
          if (/^@@/m.test(param) || /^Index:/m.test(param)) return parsePatch(param)[0];
          if (!base2) throw new Error("Must provide a base reference or pass in a patch");
          return structuredPatch(void 0, void 0, base2, param);
        }
        return param;
      }
      __name(loadPatch, "loadPatch");
      function fileNameChanged(patch) {
        return patch.newFileName && patch.newFileName !== patch.oldFileName;
      }
      __name(fileNameChanged, "fileNameChanged");
      function selectField(index, mine, theirs) {
        if (mine === theirs) return mine;
        else {
          index.conflict = true;
          return {
            mine,
            theirs
          };
        }
      }
      __name(selectField, "selectField");
      function hunkBefore(test2, check) {
        return test2.oldStart < check.oldStart && test2.oldStart + test2.oldLines < check.oldStart;
      }
      __name(hunkBefore, "hunkBefore");
      function cloneHunk(hunk, offset) {
        return {
          oldStart: hunk.oldStart,
          oldLines: hunk.oldLines,
          newStart: hunk.newStart + offset,
          newLines: hunk.newLines,
          lines: hunk.lines
        };
      }
      __name(cloneHunk, "cloneHunk");
      function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
        var mine = {
          offset: mineOffset,
          lines: mineLines,
          index: 0
        }, their = {
          offset: theirOffset,
          lines: theirLines,
          index: 0
        };
        insertLeading(hunk, mine, their);
        insertLeading(hunk, their, mine);
        while (mine.index < mine.lines.length && their.index < their.lines.length) {
          var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
          if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+"))
            mutualChange(hunk, mine, their);
          else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
            var _hunk$lines;
            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
          } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
            var _hunk$lines2;
            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
          } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ")
            removal(hunk, mine, their);
          else if (theirCurrent[0] === "-" && mineCurrent[0] === " ")
            removal(hunk, their, mine, true);
          else if (mineCurrent === theirCurrent) {
            hunk.lines.push(mineCurrent);
            mine.index++;
            their.index++;
          } else
            conflict(hunk, collectChange(mine), collectChange(their));
        }
        insertTrailing(hunk, mine);
        insertTrailing(hunk, their);
        calcLineCount(hunk);
      }
      __name(mergeLines, "mergeLines");
      function mutualChange(hunk, mine, their) {
        var myChanges = collectChange(mine), theirChanges = collectChange(their);
        if (allRemoves(myChanges) && allRemoves(theirChanges)) {
          if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
            var _hunk$lines3;
            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
            return;
          } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
            var _hunk$lines4;
            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
            return;
          }
        } else if (arrayEqual(myChanges, theirChanges)) {
          var _hunk$lines5;
          (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
          return;
        }
        conflict(hunk, myChanges, theirChanges);
      }
      __name(mutualChange, "mutualChange");
      function removal(hunk, mine, their, swap) {
        var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
        if (theirChanges.merged) {
          var _hunk$lines6;
          (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
        } else conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
      }
      __name(removal, "removal");
      function conflict(hunk, mine, their) {
        hunk.conflict = true;
        hunk.lines.push({
          conflict: true,
          mine,
          theirs: their
        });
      }
      __name(conflict, "conflict");
      function insertLeading(hunk, insert, their) {
        while (insert.offset < their.offset && insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
          insert.offset++;
        }
      }
      __name(insertLeading, "insertLeading");
      function insertTrailing(hunk, insert) {
        while (insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
        }
      }
      __name(insertTrailing, "insertTrailing");
      function collectChange(state) {
        var ret = [], operation = state.lines[state.index][0];
        while (state.index < state.lines.length) {
          var line = state.lines[state.index];
          if (operation === "-" && line[0] === "+") operation = "+";
          if (operation === line[0]) {
            ret.push(line);
            state.index++;
          } else break;
        }
        return ret;
      }
      __name(collectChange, "collectChange");
      function collectContext(state, matchChanges) {
        var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
        while (matchIndex < matchChanges.length && state.index < state.lines.length) {
          var change = state.lines[state.index], match = matchChanges[matchIndex];
          if (match[0] === "+") break;
          contextChanges = contextChanges || change[0] !== " ";
          merged.push(match);
          matchIndex++;
          if (change[0] === "+") {
            conflicted = true;
            while (change[0] === "+") {
              changes.push(change);
              change = state.lines[++state.index];
            }
          }
          if (match.substr(1) === change.substr(1)) {
            changes.push(change);
            state.index++;
          } else conflicted = true;
        }
        if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) conflicted = true;
        if (conflicted) return changes;
        while (matchIndex < matchChanges.length) merged.push(matchChanges[matchIndex++]);
        return {
          merged,
          changes
        };
      }
      __name(collectContext, "collectContext");
      function allRemoves(changes) {
        return changes.reduce(function(prev, change) {
          return prev && change[0] === "-";
        }, true);
      }
      __name(allRemoves, "allRemoves");
      function skipRemoveSuperset(state, removeChanges, delta) {
        for (var i2 = 0; i2 < delta; i2++) {
          var changeContent = removeChanges[removeChanges.length - delta + i2].substr(1);
          if (state.lines[state.index + i2] !== " " + changeContent) return false;
        }
        state.index += delta;
        return true;
      }
      __name(skipRemoveSuperset, "skipRemoveSuperset");
      function calcOldNewLineCount(lines) {
        var oldLines = 0;
        var newLines = 0;
        lines.forEach(function(line) {
          if (typeof line !== "string") {
            var myCount = calcOldNewLineCount(line.mine);
            var theirCount = calcOldNewLineCount(line.theirs);
            if (oldLines !== void 0) {
              if (myCount.oldLines === theirCount.oldLines) oldLines += myCount.oldLines;
              else oldLines = void 0;
            }
            if (newLines !== void 0) {
              if (myCount.newLines === theirCount.newLines) newLines += myCount.newLines;
              else newLines = void 0;
            }
          } else {
            if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) newLines++;
            if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) oldLines++;
          }
        });
        return {
          oldLines,
          newLines
        };
      }
      __name(calcOldNewLineCount, "calcOldNewLineCount");
      function convertChangesToDMP(changes) {
        var ret = [], change, operation;
        for (var i2 = 0; i2 < changes.length; i2++) {
          change = changes[i2];
          if (change.added) operation = 1;
          else if (change.removed) operation = -1;
          else operation = 0;
          ret.push([
            operation,
            change.value
          ]);
        }
        return ret;
      }
      __name(convertChangesToDMP, "convertChangesToDMP");
      function convertChangesToXML(changes) {
        var ret = [];
        for (var i2 = 0; i2 < changes.length; i2++) {
          var change = changes[i2];
          if (change.added) ret.push("<ins>");
          else if (change.removed) ret.push("<del>");
          ret.push(escapeHTML(change.value));
          if (change.added) ret.push("</ins>");
          else if (change.removed) ret.push("</del>");
        }
        return ret.join("");
      }
      __name(convertChangesToXML, "convertChangesToXML");
      function escapeHTML(s2) {
        var n2 = s2;
        n2 = n2.replace(/&/g, "&amp;");
        n2 = n2.replace(/</g, "&lt;");
        n2 = n2.replace(/>/g, "&gt;");
        n2 = n2.replace(/"/g, "&quot;");
        return n2;
      }
      __name(escapeHTML, "escapeHTML");
      exports.Diff = Diff;
      exports.applyPatch = applyPatch;
      exports.applyPatches = applyPatches;
      exports.canonicalize = canonicalize;
      exports.convertChangesToDMP = convertChangesToDMP;
      exports.convertChangesToXML = convertChangesToXML;
      exports.createPatch = createPatch;
      exports.createTwoFilesPatch = createTwoFilesPatch;
      exports.diffArrays = diffArrays;
      exports.diffChars = diffChars;
      exports.diffCss = diffCss;
      exports.diffJson = diffJson;
      exports.diffLines = diffLines;
      exports.diffSentences = diffSentences;
      exports.diffTrimmedLines = diffTrimmedLines;
      exports.diffWords = diffWords;
      exports.diffWordsWithSpace = diffWordsWithSpace;
      exports.merge = merge;
      exports.parsePatch = parsePatch;
      exports.structuredPatch = structuredPatch;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    });
  });
  var s$1 = 1e3;
  var m$1 = s$1 * 60;
  var h$1 = m$1 * 60;
  var d$1 = h$1 * 24;
  var w$1 = d$1 * 7;
  var y$1 = d$1 * 365.25;
  var ms$1 = /* @__PURE__ */ __name(function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) return parse$1(val);
    else if (type === "number" && isFinite(val)) return options.long ? fmtLong$1(val) : fmtShort$1(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  }, "ms$1");
  function parse$1(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y$1;
      case "weeks":
      case "week":
      case "w":
        return n2 * w$1;
      case "days":
      case "day":
      case "d":
        return n2 * d$1;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h$1;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m$1;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s$1;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  __name(parse$1, "parse$1");
  function fmtShort$1(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d$1) return Math.round(ms / d$1) + "d";
    if (msAbs >= h$1) return Math.round(ms / h$1) + "h";
    if (msAbs >= m$1) return Math.round(ms / m$1) + "m";
    if (msAbs >= s$1) return Math.round(ms / s$1) + "s";
    return ms + "ms";
  }
  __name(fmtShort$1, "fmtShort$1");
  function fmtLong$1(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d$1) return plural$1(ms, msAbs, d$1, "day");
    if (msAbs >= h$1) return plural$1(ms, msAbs, h$1, "hour");
    if (msAbs >= m$1) return plural$1(ms, msAbs, m$1, "minute");
    if (msAbs >= s$1) return plural$1(ms, msAbs, s$1, "second");
    return ms + " ms";
  }
  __name(fmtLong$1, "fmtLong$1");
  function plural$1(ms, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
  }
  __name(plural$1, "plural$1");
  var browser$2 = true;
  let urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
  let customAlphabet = /* @__PURE__ */ __name((alphabet, size) => {
    return () => {
      let id = "";
      let i2 = size;
      while (i2--)
        id += alphabet[Math.random() * alphabet.length | 0];
      return id;
    };
  }, "customAlphabet");
  let nanoid1 = /* @__PURE__ */ __name((size = 21) => {
    let id = "";
    let i2 = size;
    while (i2--)
      id += urlAlphabet[Math.random() * 64 | 0];
    return id;
  }, "nanoid1");
  var nonSecure = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    nanoid: nanoid1,
    customAlphabet
  });
  var he1 = createCommonjsModule(function(module, exports) {
    (function(root2) {
      var freeExports = exports;
      var freeModule = module && module.exports == freeExports && module;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) root2 = freeGlobal;
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = {
        "\xAD": "shy",
        "\u200C": "zwnj",
        "\u200D": "zwj",
        "\u200E": "lrm",
        "\u2063": "ic",
        "\u2062": "it",
        "\u2061": "af",
        "\u200F": "rlm",
        "\u200B": "ZeroWidthSpace",
        "\u2060": "NoBreak",
        "\u0311": "DownBreve",
        "\u20DB": "tdot",
        "\u20DC": "DotDot",
        "	": "Tab",
        "\n": "NewLine",
        "\u2008": "puncsp",
        "\u205F": "MediumSpace",
        "\u2009": "thinsp",
        "\u200A": "hairsp",
        "\u2004": "emsp13",
        "\u2002": "ensp",
        "\u2005": "emsp14",
        "\u2003": "emsp",
        "\u2007": "numsp",
        "\xA0": "nbsp",
        "\u205F\u200A": "ThickSpace",
        "\u203E": "oline",
        "_": "lowbar",
        "\u2010": "dash",
        "\u2013": "ndash",
        "\u2014": "mdash",
        "\u2015": "horbar",
        ",": "comma",
        ";": "semi",
        "\u204F": "bsemi",
        ":": "colon",
        "\u2A74": "Colone",
        "!": "excl",
        "\xA1": "iexcl",
        "?": "quest",
        "\xBF": "iquest",
        ".": "period",
        "\u2025": "nldr",
        "\u2026": "mldr",
        "\xB7": "middot",
        "'": "apos",
        "\u2018": "lsquo",
        "\u2019": "rsquo",
        "\u201A": "sbquo",
        "\u2039": "lsaquo",
        "\u203A": "rsaquo",
        '"': "quot",
        "\u201C": "ldquo",
        "\u201D": "rdquo",
        "\u201E": "bdquo",
        "\xAB": "laquo",
        "\xBB": "raquo",
        "(": "lpar",
        ")": "rpar",
        "[": "lsqb",
        "]": "rsqb",
        "{": "lcub",
        "}": "rcub",
        "\u2308": "lceil",
        "\u2309": "rceil",
        "\u230A": "lfloor",
        "\u230B": "rfloor",
        "\u2985": "lopar",
        "\u2986": "ropar",
        "\u298B": "lbrke",
        "\u298C": "rbrke",
        "\u298D": "lbrkslu",
        "\u298E": "rbrksld",
        "\u298F": "lbrksld",
        "\u2990": "rbrkslu",
        "\u2991": "langd",
        "\u2992": "rangd",
        "\u2993": "lparlt",
        "\u2994": "rpargt",
        "\u2995": "gtlPar",
        "\u2996": "ltrPar",
        "\u27E6": "lobrk",
        "\u27E7": "robrk",
        "\u27E8": "lang",
        "\u27E9": "rang",
        "\u27EA": "Lang",
        "\u27EB": "Rang",
        "\u27EC": "loang",
        "\u27ED": "roang",
        "\u2772": "lbbrk",
        "\u2773": "rbbrk",
        "\u2016": "Vert",
        "\xA7": "sect",
        "\xB6": "para",
        "@": "commat",
        "*": "ast",
        "/": "sol",
        "undefined": null,
        "&": "amp",
        "#": "num",
        "%": "percnt",
        "\u2030": "permil",
        "\u2031": "pertenk",
        "\u2020": "dagger",
        "\u2021": "Dagger",
        "\u2022": "bull",
        "\u2043": "hybull",
        "\u2032": "prime",
        "\u2033": "Prime",
        "\u2034": "tprime",
        "\u2057": "qprime",
        "\u2035": "bprime",
        "\u2041": "caret",
        "`": "grave",
        "\xB4": "acute",
        "\u02DC": "tilde",
        "^": "Hat",
        "\xAF": "macr",
        "\u02D8": "breve",
        "\u02D9": "dot",
        "\xA8": "die",
        "\u02DA": "ring",
        "\u02DD": "dblac",
        "\xB8": "cedil",
        "\u02DB": "ogon",
        "\u02C6": "circ",
        "\u02C7": "caron",
        "\xB0": "deg",
        "\xA9": "copy",
        "\xAE": "reg",
        "\u2117": "copysr",
        "\u2118": "wp",
        "\u211E": "rx",
        "\u2127": "mho",
        "\u2129": "iiota",
        "\u2190": "larr",
        "\u219A": "nlarr",
        "\u2192": "rarr",
        "\u219B": "nrarr",
        "\u2191": "uarr",
        "\u2193": "darr",
        "\u2194": "harr",
        "\u21AE": "nharr",
        "\u2195": "varr",
        "\u2196": "nwarr",
        "\u2197": "nearr",
        "\u2198": "searr",
        "\u2199": "swarr",
        "\u219D": "rarrw",
        "\u219D\u0338": "nrarrw",
        "\u219E": "Larr",
        "\u219F": "Uarr",
        "\u21A0": "Rarr",
        "\u21A1": "Darr",
        "\u21A2": "larrtl",
        "\u21A3": "rarrtl",
        "\u21A4": "mapstoleft",
        "\u21A5": "mapstoup",
        "\u21A6": "map",
        "\u21A7": "mapstodown",
        "\u21A9": "larrhk",
        "\u21AA": "rarrhk",
        "\u21AB": "larrlp",
        "\u21AC": "rarrlp",
        "\u21AD": "harrw",
        "\u21B0": "lsh",
        "\u21B1": "rsh",
        "\u21B2": "ldsh",
        "\u21B3": "rdsh",
        "\u21B5": "crarr",
        "\u21B6": "cularr",
        "\u21B7": "curarr",
        "\u21BA": "olarr",
        "\u21BB": "orarr",
        "\u21BC": "lharu",
        "\u21BD": "lhard",
        "\u21BE": "uharr",
        "\u21BF": "uharl",
        "\u21C0": "rharu",
        "\u21C1": "rhard",
        "\u21C2": "dharr",
        "\u21C3": "dharl",
        "\u21C4": "rlarr",
        "\u21C5": "udarr",
        "\u21C6": "lrarr",
        "\u21C7": "llarr",
        "\u21C8": "uuarr",
        "\u21C9": "rrarr",
        "\u21CA": "ddarr",
        "\u21CB": "lrhar",
        "\u21CC": "rlhar",
        "\u21D0": "lArr",
        "\u21CD": "nlArr",
        "\u21D1": "uArr",
        "\u21D2": "rArr",
        "\u21CF": "nrArr",
        "\u21D3": "dArr",
        "\u21D4": "iff",
        "\u21CE": "nhArr",
        "\u21D5": "vArr",
        "\u21D6": "nwArr",
        "\u21D7": "neArr",
        "\u21D8": "seArr",
        "\u21D9": "swArr",
        "\u21DA": "lAarr",
        "\u21DB": "rAarr",
        "\u21DD": "zigrarr",
        "\u21E4": "larrb",
        "\u21E5": "rarrb",
        "\u21F5": "duarr",
        "\u21FD": "loarr",
        "\u21FE": "roarr",
        "\u21FF": "hoarr",
        "\u2200": "forall",
        "\u2201": "comp",
        "\u2202": "part",
        "\u2202\u0338": "npart",
        "\u2203": "exist",
        "\u2204": "nexist",
        "\u2205": "empty",
        "\u2207": "Del",
        "\u2208": "in",
        "\u2209": "notin",
        "\u220B": "ni",
        "\u220C": "notni",
        "\u03F6": "bepsi",
        "\u220F": "prod",
        "\u2210": "coprod",
        "\u2211": "sum",
        "+": "plus",
        "\xB1": "pm",
        "\xF7": "div",
        "\xD7": "times",
        "<": "lt",
        "\u226E": "nlt",
        "<\u20D2": "nvlt",
        "=": "equals",
        "\u2260": "ne",
        "=\u20E5": "bne",
        "\u2A75": "Equal",
        ">": "gt",
        "\u226F": "ngt",
        ">\u20D2": "nvgt",
        "\xAC": "not",
        "|": "vert",
        "\xA6": "brvbar",
        "\u2212": "minus",
        "\u2213": "mp",
        "\u2214": "plusdo",
        "\u2044": "frasl",
        "\u2216": "setmn",
        "\u2217": "lowast",
        "\u2218": "compfn",
        "\u221A": "Sqrt",
        "\u221D": "prop",
        "\u221E": "infin",
        "\u221F": "angrt",
        "\u2220": "ang",
        "\u2220\u20D2": "nang",
        "\u2221": "angmsd",
        "\u2222": "angsph",
        "\u2223": "mid",
        "\u2224": "nmid",
        "\u2225": "par",
        "\u2226": "npar",
        "\u2227": "and",
        "\u2228": "or",
        "\u2229": "cap",
        "\u2229\uFE00": "caps",
        "\u222A": "cup",
        "\u222A\uFE00": "cups",
        "\u222B": "int",
        "\u222C": "Int",
        "\u222D": "tint",
        "\u2A0C": "qint",
        "\u222E": "oint",
        "\u222F": "Conint",
        "\u2230": "Cconint",
        "\u2231": "cwint",
        "\u2232": "cwconint",
        "\u2233": "awconint",
        "\u2234": "there4",
        "\u2235": "becaus",
        "\u2236": "ratio",
        "\u2237": "Colon",
        "\u2238": "minusd",
        "\u223A": "mDDot",
        "\u223B": "homtht",
        "\u223C": "sim",
        "\u2241": "nsim",
        "\u223C\u20D2": "nvsim",
        "\u223D": "bsim",
        "\u223D\u0331": "race",
        "\u223E": "ac",
        "\u223E\u0333": "acE",
        "\u223F": "acd",
        "\u2240": "wr",
        "\u2242": "esim",
        "\u2242\u0338": "nesim",
        "\u2243": "sime",
        "\u2244": "nsime",
        "\u2245": "cong",
        "\u2247": "ncong",
        "\u2246": "simne",
        "\u2248": "ap",
        "\u2249": "nap",
        "\u224A": "ape",
        "\u224B": "apid",
        "\u224B\u0338": "napid",
        "\u224C": "bcong",
        "\u224D": "CupCap",
        "\u226D": "NotCupCap",
        "\u224D\u20D2": "nvap",
        "\u224E": "bump",
        "\u224E\u0338": "nbump",
        "\u224F": "bumpe",
        "\u224F\u0338": "nbumpe",
        "\u2250": "doteq",
        "\u2250\u0338": "nedot",
        "\u2251": "eDot",
        "\u2252": "efDot",
        "\u2253": "erDot",
        "\u2254": "colone",
        "\u2255": "ecolon",
        "\u2256": "ecir",
        "\u2257": "cire",
        "\u2259": "wedgeq",
        "\u225A": "veeeq",
        "\u225C": "trie",
        "\u225F": "equest",
        "\u2261": "equiv",
        "\u2262": "nequiv",
        "\u2261\u20E5": "bnequiv",
        "\u2264": "le",
        "\u2270": "nle",
        "\u2264\u20D2": "nvle",
        "\u2265": "ge",
        "\u2271": "nge",
        "\u2265\u20D2": "nvge",
        "\u2266": "lE",
        "\u2266\u0338": "nlE",
        "\u2267": "gE",
        "\u2267\u0338": "ngE",
        "\u2268\uFE00": "lvnE",
        "\u2268": "lnE",
        "\u2269": "gnE",
        "\u2269\uFE00": "gvnE",
        "\u226A": "ll",
        "\u226A\u0338": "nLtv",
        "\u226A\u20D2": "nLt",
        "\u226B": "gg",
        "\u226B\u0338": "nGtv",
        "\u226B\u20D2": "nGt",
        "\u226C": "twixt",
        "\u2272": "lsim",
        "\u2274": "nlsim",
        "\u2273": "gsim",
        "\u2275": "ngsim",
        "\u2276": "lg",
        "\u2278": "ntlg",
        "\u2277": "gl",
        "\u2279": "ntgl",
        "\u227A": "pr",
        "\u2280": "npr",
        "\u227B": "sc",
        "\u2281": "nsc",
        "\u227C": "prcue",
        "\u22E0": "nprcue",
        "\u227D": "sccue",
        "\u22E1": "nsccue",
        "\u227E": "prsim",
        "\u227F": "scsim",
        "\u227F\u0338": "NotSucceedsTilde",
        "\u2282": "sub",
        "\u2284": "nsub",
        "\u2282\u20D2": "vnsub",
        "\u2283": "sup",
        "\u2285": "nsup",
        "\u2283\u20D2": "vnsup",
        "\u2286": "sube",
        "\u2288": "nsube",
        "\u2287": "supe",
        "\u2289": "nsupe",
        "\u228A\uFE00": "vsubne",
        "\u228A": "subne",
        "\u228B\uFE00": "vsupne",
        "\u228B": "supne",
        "\u228D": "cupdot",
        "\u228E": "uplus",
        "\u228F": "sqsub",
        "\u228F\u0338": "NotSquareSubset",
        "\u2290": "sqsup",
        "\u2290\u0338": "NotSquareSuperset",
        "\u2291": "sqsube",
        "\u22E2": "nsqsube",
        "\u2292": "sqsupe",
        "\u22E3": "nsqsupe",
        "\u2293": "sqcap",
        "\u2293\uFE00": "sqcaps",
        "\u2294": "sqcup",
        "\u2294\uFE00": "sqcups",
        "\u2295": "oplus",
        "\u2296": "ominus",
        "\u2297": "otimes",
        "\u2298": "osol",
        "\u2299": "odot",
        "\u229A": "ocir",
        "\u229B": "oast",
        "\u229D": "odash",
        "\u229E": "plusb",
        "\u229F": "minusb",
        "\u22A0": "timesb",
        "\u22A1": "sdotb",
        "\u22A2": "vdash",
        "\u22AC": "nvdash",
        "\u22A3": "dashv",
        "\u22A4": "top",
        "\u22A5": "bot",
        "\u22A7": "models",
        "\u22A8": "vDash",
        "\u22AD": "nvDash",
        "\u22A9": "Vdash",
        "\u22AE": "nVdash",
        "\u22AA": "Vvdash",
        "\u22AB": "VDash",
        "\u22AF": "nVDash",
        "\u22B0": "prurel",
        "\u22B2": "vltri",
        "\u22EA": "nltri",
        "\u22B3": "vrtri",
        "\u22EB": "nrtri",
        "\u22B4": "ltrie",
        "\u22EC": "nltrie",
        "\u22B4\u20D2": "nvltrie",
        "\u22B5": "rtrie",
        "\u22ED": "nrtrie",
        "\u22B5\u20D2": "nvrtrie",
        "\u22B6": "origof",
        "\u22B7": "imof",
        "\u22B8": "mumap",
        "\u22B9": "hercon",
        "\u22BA": "intcal",
        "\u22BB": "veebar",
        "\u22BD": "barvee",
        "\u22BE": "angrtvb",
        "\u22BF": "lrtri",
        "\u22C0": "Wedge",
        "\u22C1": "Vee",
        "\u22C2": "xcap",
        "\u22C3": "xcup",
        "\u22C4": "diam",
        "\u22C5": "sdot",
        "\u22C6": "Star",
        "\u22C7": "divonx",
        "\u22C8": "bowtie",
        "\u22C9": "ltimes",
        "\u22CA": "rtimes",
        "\u22CB": "lthree",
        "\u22CC": "rthree",
        "\u22CD": "bsime",
        "\u22CE": "cuvee",
        "\u22CF": "cuwed",
        "\u22D0": "Sub",
        "\u22D1": "Sup",
        "\u22D2": "Cap",
        "\u22D3": "Cup",
        "\u22D4": "fork",
        "\u22D5": "epar",
        "\u22D6": "ltdot",
        "\u22D7": "gtdot",
        "\u22D8": "Ll",
        "\u22D8\u0338": "nLl",
        "\u22D9": "Gg",
        "\u22D9\u0338": "nGg",
        "\u22DA\uFE00": "lesg",
        "\u22DA": "leg",
        "\u22DB": "gel",
        "\u22DB\uFE00": "gesl",
        "\u22DE": "cuepr",
        "\u22DF": "cuesc",
        "\u22E6": "lnsim",
        "\u22E7": "gnsim",
        "\u22E8": "prnsim",
        "\u22E9": "scnsim",
        "\u22EE": "vellip",
        "\u22EF": "ctdot",
        "\u22F0": "utdot",
        "\u22F1": "dtdot",
        "\u22F2": "disin",
        "\u22F3": "isinsv",
        "\u22F4": "isins",
        "\u22F5": "isindot",
        "\u22F5\u0338": "notindot",
        "\u22F6": "notinvc",
        "\u22F7": "notinvb",
        "\u22F9": "isinE",
        "\u22F9\u0338": "notinE",
        "\u22FA": "nisd",
        "\u22FB": "xnis",
        "\u22FC": "nis",
        "\u22FD": "notnivc",
        "\u22FE": "notnivb",
        "\u2305": "barwed",
        "\u2306": "Barwed",
        "\u230C": "drcrop",
        "\u230D": "dlcrop",
        "\u230E": "urcrop",
        "\u230F": "ulcrop",
        "\u2310": "bnot",
        "\u2312": "profline",
        "\u2313": "profsurf",
        "\u2315": "telrec",
        "\u2316": "target",
        "\u231C": "ulcorn",
        "\u231D": "urcorn",
        "\u231E": "dlcorn",
        "\u231F": "drcorn",
        "\u2322": "frown",
        "\u2323": "smile",
        "\u232D": "cylcty",
        "\u232E": "profalar",
        "\u2336": "topbot",
        "\u233D": "ovbar",
        "\u233F": "solbar",
        "\u237C": "angzarr",
        "\u23B0": "lmoust",
        "\u23B1": "rmoust",
        "\u23B4": "tbrk",
        "\u23B5": "bbrk",
        "\u23B6": "bbrktbrk",
        "\u23DC": "OverParenthesis",
        "\u23DD": "UnderParenthesis",
        "\u23DE": "OverBrace",
        "\u23DF": "UnderBrace",
        "\u23E2": "trpezium",
        "\u23E7": "elinters",
        "\u2423": "blank",
        "\u2500": "boxh",
        "\u2502": "boxv",
        "\u250C": "boxdr",
        "\u2510": "boxdl",
        "\u2514": "boxur",
        "\u2518": "boxul",
        "\u251C": "boxvr",
        "\u2524": "boxvl",
        "\u252C": "boxhd",
        "\u2534": "boxhu",
        "\u253C": "boxvh",
        "\u2550": "boxH",
        "\u2551": "boxV",
        "\u2552": "boxdR",
        "\u2553": "boxDr",
        "\u2554": "boxDR",
        "\u2555": "boxdL",
        "\u2556": "boxDl",
        "\u2557": "boxDL",
        "\u2558": "boxuR",
        "\u2559": "boxUr",
        "\u255A": "boxUR",
        "\u255B": "boxuL",
        "\u255C": "boxUl",
        "\u255D": "boxUL",
        "\u255E": "boxvR",
        "\u255F": "boxVr",
        "\u2560": "boxVR",
        "\u2561": "boxvL",
        "\u2562": "boxVl",
        "\u2563": "boxVL",
        "\u2564": "boxHd",
        "\u2565": "boxhD",
        "\u2566": "boxHD",
        "\u2567": "boxHu",
        "\u2568": "boxhU",
        "\u2569": "boxHU",
        "\u256A": "boxvH",
        "\u256B": "boxVh",
        "\u256C": "boxVH",
        "\u2580": "uhblk",
        "\u2584": "lhblk",
        "\u2588": "block",
        "\u2591": "blk14",
        "\u2592": "blk12",
        "\u2593": "blk34",
        "\u25A1": "squ",
        "\u25AA": "squf",
        "\u25AB": "EmptyVerySmallSquare",
        "\u25AD": "rect",
        "\u25AE": "marker",
        "\u25B1": "fltns",
        "\u25B3": "xutri",
        "\u25B4": "utrif",
        "\u25B5": "utri",
        "\u25B8": "rtrif",
        "\u25B9": "rtri",
        "\u25BD": "xdtri",
        "\u25BE": "dtrif",
        "\u25BF": "dtri",
        "\u25C2": "ltrif",
        "\u25C3": "ltri",
        "\u25CA": "loz",
        "\u25CB": "cir",
        "\u25EC": "tridot",
        "\u25EF": "xcirc",
        "\u25F8": "ultri",
        "\u25F9": "urtri",
        "\u25FA": "lltri",
        "\u25FB": "EmptySmallSquare",
        "\u25FC": "FilledSmallSquare",
        "\u2605": "starf",
        "\u2606": "star",
        "\u260E": "phone",
        "\u2640": "female",
        "\u2642": "male",
        "\u2660": "spades",
        "\u2663": "clubs",
        "\u2665": "hearts",
        "\u2666": "diams",
        "\u266A": "sung",
        "\u2713": "check",
        "\u2717": "cross",
        "\u2720": "malt",
        "\u2736": "sext",
        "\u2758": "VerticalSeparator",
        "\u27C8": "bsolhsub",
        "\u27C9": "suphsol",
        "\u27F5": "xlarr",
        "\u27F6": "xrarr",
        "\u27F7": "xharr",
        "\u27F8": "xlArr",
        "\u27F9": "xrArr",
        "\u27FA": "xhArr",
        "\u27FC": "xmap",
        "\u27FF": "dzigrarr",
        "\u2902": "nvlArr",
        "\u2903": "nvrArr",
        "\u2904": "nvHarr",
        "\u2905": "Map",
        "\u290C": "lbarr",
        "\u290D": "rbarr",
        "\u290E": "lBarr",
        "\u290F": "rBarr",
        "\u2910": "RBarr",
        "\u2911": "DDotrahd",
        "\u2912": "UpArrowBar",
        "\u2913": "DownArrowBar",
        "\u2916": "Rarrtl",
        "\u2919": "latail",
        "\u291A": "ratail",
        "\u291B": "lAtail",
        "\u291C": "rAtail",
        "\u291D": "larrfs",
        "\u291E": "rarrfs",
        "\u291F": "larrbfs",
        "\u2920": "rarrbfs",
        "\u2923": "nwarhk",
        "\u2924": "nearhk",
        "\u2925": "searhk",
        "\u2926": "swarhk",
        "\u2927": "nwnear",
        "\u2928": "toea",
        "\u2929": "tosa",
        "\u292A": "swnwar",
        "\u2933": "rarrc",
        "\u2933\u0338": "nrarrc",
        "\u2935": "cudarrr",
        "\u2936": "ldca",
        "\u2937": "rdca",
        "\u2938": "cudarrl",
        "\u2939": "larrpl",
        "\u293C": "curarrm",
        "\u293D": "cularrp",
        "\u2945": "rarrpl",
        "\u2948": "harrcir",
        "\u2949": "Uarrocir",
        "\u294A": "lurdshar",
        "\u294B": "ldrushar",
        "\u294E": "LeftRightVector",
        "\u294F": "RightUpDownVector",
        "\u2950": "DownLeftRightVector",
        "\u2951": "LeftUpDownVector",
        "\u2952": "LeftVectorBar",
        "\u2953": "RightVectorBar",
        "\u2954": "RightUpVectorBar",
        "\u2955": "RightDownVectorBar",
        "\u2956": "DownLeftVectorBar",
        "\u2957": "DownRightVectorBar",
        "\u2958": "LeftUpVectorBar",
        "\u2959": "LeftDownVectorBar",
        "\u295A": "LeftTeeVector",
        "\u295B": "RightTeeVector",
        "\u295C": "RightUpTeeVector",
        "\u295D": "RightDownTeeVector",
        "\u295E": "DownLeftTeeVector",
        "\u295F": "DownRightTeeVector",
        "\u2960": "LeftUpTeeVector",
        "\u2961": "LeftDownTeeVector",
        "\u2962": "lHar",
        "\u2963": "uHar",
        "\u2964": "rHar",
        "\u2965": "dHar",
        "\u2966": "luruhar",
        "\u2967": "ldrdhar",
        "\u2968": "ruluhar",
        "\u2969": "rdldhar",
        "\u296A": "lharul",
        "\u296B": "llhard",
        "\u296C": "rharul",
        "\u296D": "lrhard",
        "\u296E": "udhar",
        "\u296F": "duhar",
        "\u2970": "RoundImplies",
        "\u2971": "erarr",
        "\u2972": "simrarr",
        "\u2973": "larrsim",
        "\u2974": "rarrsim",
        "\u2975": "rarrap",
        "\u2976": "ltlarr",
        "\u2978": "gtrarr",
        "\u2979": "subrarr",
        "\u297B": "suplarr",
        "\u297C": "lfisht",
        "\u297D": "rfisht",
        "\u297E": "ufisht",
        "\u297F": "dfisht",
        "\u299A": "vzigzag",
        "\u299C": "vangrt",
        "\u299D": "angrtvbd",
        "\u29A4": "ange",
        "\u29A5": "range",
        "\u29A6": "dwangle",
        "\u29A7": "uwangle",
        "\u29A8": "angmsdaa",
        "\u29A9": "angmsdab",
        "\u29AA": "angmsdac",
        "\u29AB": "angmsdad",
        "\u29AC": "angmsdae",
        "\u29AD": "angmsdaf",
        "\u29AE": "angmsdag",
        "\u29AF": "angmsdah",
        "\u29B0": "bemptyv",
        "\u29B1": "demptyv",
        "\u29B2": "cemptyv",
        "\u29B3": "raemptyv",
        "\u29B4": "laemptyv",
        "\u29B5": "ohbar",
        "\u29B6": "omid",
        "\u29B7": "opar",
        "\u29B9": "operp",
        "\u29BB": "olcross",
        "\u29BC": "odsold",
        "\u29BE": "olcir",
        "\u29BF": "ofcir",
        "\u29C0": "olt",
        "\u29C1": "ogt",
        "\u29C2": "cirscir",
        "\u29C3": "cirE",
        "\u29C4": "solb",
        "\u29C5": "bsolb",
        "\u29C9": "boxbox",
        "\u29CD": "trisb",
        "\u29CE": "rtriltri",
        "\u29CF": "LeftTriangleBar",
        "\u29CF\u0338": "NotLeftTriangleBar",
        "\u29D0": "RightTriangleBar",
        "\u29D0\u0338": "NotRightTriangleBar",
        "\u29DC": "iinfin",
        "\u29DD": "infintie",
        "\u29DE": "nvinfin",
        "\u29E3": "eparsl",
        "\u29E4": "smeparsl",
        "\u29E5": "eqvparsl",
        "\u29EB": "lozf",
        "\u29F4": "RuleDelayed",
        "\u29F6": "dsol",
        "\u2A00": "xodot",
        "\u2A01": "xoplus",
        "\u2A02": "xotime",
        "\u2A04": "xuplus",
        "\u2A06": "xsqcup",
        "\u2A0D": "fpartint",
        "\u2A10": "cirfnint",
        "\u2A11": "awint",
        "\u2A12": "rppolint",
        "\u2A13": "scpolint",
        "\u2A14": "npolint",
        "\u2A15": "pointint",
        "\u2A16": "quatint",
        "\u2A17": "intlarhk",
        "\u2A22": "pluscir",
        "\u2A23": "plusacir",
        "\u2A24": "simplus",
        "\u2A25": "plusdu",
        "\u2A26": "plussim",
        "\u2A27": "plustwo",
        "\u2A29": "mcomma",
        "\u2A2A": "minusdu",
        "\u2A2D": "loplus",
        "\u2A2E": "roplus",
        "\u2A2F": "Cross",
        "\u2A30": "timesd",
        "\u2A31": "timesbar",
        "\u2A33": "smashp",
        "\u2A34": "lotimes",
        "\u2A35": "rotimes",
        "\u2A36": "otimesas",
        "\u2A37": "Otimes",
        "\u2A38": "odiv",
        "\u2A39": "triplus",
        "\u2A3A": "triminus",
        "\u2A3B": "tritime",
        "\u2A3C": "iprod",
        "\u2A3F": "amalg",
        "\u2A40": "capdot",
        "\u2A42": "ncup",
        "\u2A43": "ncap",
        "\u2A44": "capand",
        "\u2A45": "cupor",
        "\u2A46": "cupcap",
        "\u2A47": "capcup",
        "\u2A48": "cupbrcap",
        "\u2A49": "capbrcup",
        "\u2A4A": "cupcup",
        "\u2A4B": "capcap",
        "\u2A4C": "ccups",
        "\u2A4D": "ccaps",
        "\u2A50": "ccupssm",
        "\u2A53": "And",
        "\u2A54": "Or",
        "\u2A55": "andand",
        "\u2A56": "oror",
        "\u2A57": "orslope",
        "\u2A58": "andslope",
        "\u2A5A": "andv",
        "\u2A5B": "orv",
        "\u2A5C": "andd",
        "\u2A5D": "ord",
        "\u2A5F": "wedbar",
        "\u2A66": "sdote",
        "\u2A6A": "simdot",
        "\u2A6D": "congdot",
        "\u2A6D\u0338": "ncongdot",
        "\u2A6E": "easter",
        "\u2A6F": "apacir",
        "\u2A70": "apE",
        "\u2A70\u0338": "napE",
        "\u2A71": "eplus",
        "\u2A72": "pluse",
        "\u2A73": "Esim",
        "\u2A77": "eDDot",
        "\u2A78": "equivDD",
        "\u2A79": "ltcir",
        "\u2A7A": "gtcir",
        "\u2A7B": "ltquest",
        "\u2A7C": "gtquest",
        "\u2A7D": "les",
        "\u2A7D\u0338": "nles",
        "\u2A7E": "ges",
        "\u2A7E\u0338": "nges",
        "\u2A7F": "lesdot",
        "\u2A80": "gesdot",
        "\u2A81": "lesdoto",
        "\u2A82": "gesdoto",
        "\u2A83": "lesdotor",
        "\u2A84": "gesdotol",
        "\u2A85": "lap",
        "\u2A86": "gap",
        "\u2A87": "lne",
        "\u2A88": "gne",
        "\u2A89": "lnap",
        "\u2A8A": "gnap",
        "\u2A8B": "lEg",
        "\u2A8C": "gEl",
        "\u2A8D": "lsime",
        "\u2A8E": "gsime",
        "\u2A8F": "lsimg",
        "\u2A90": "gsiml",
        "\u2A91": "lgE",
        "\u2A92": "glE",
        "\u2A93": "lesges",
        "\u2A94": "gesles",
        "\u2A95": "els",
        "\u2A96": "egs",
        "\u2A97": "elsdot",
        "\u2A98": "egsdot",
        "\u2A99": "el",
        "\u2A9A": "eg",
        "\u2A9D": "siml",
        "\u2A9E": "simg",
        "\u2A9F": "simlE",
        "\u2AA0": "simgE",
        "\u2AA1": "LessLess",
        "\u2AA1\u0338": "NotNestedLessLess",
        "\u2AA2": "GreaterGreater",
        "\u2AA2\u0338": "NotNestedGreaterGreater",
        "\u2AA4": "glj",
        "\u2AA5": "gla",
        "\u2AA6": "ltcc",
        "\u2AA7": "gtcc",
        "\u2AA8": "lescc",
        "\u2AA9": "gescc",
        "\u2AAA": "smt",
        "\u2AAB": "lat",
        "\u2AAC": "smte",
        "\u2AAC\uFE00": "smtes",
        "\u2AAD": "late",
        "\u2AAD\uFE00": "lates",
        "\u2AAE": "bumpE",
        "\u2AAF": "pre",
        "\u2AAF\u0338": "npre",
        "\u2AB0": "sce",
        "\u2AB0\u0338": "nsce",
        "\u2AB3": "prE",
        "\u2AB4": "scE",
        "\u2AB5": "prnE",
        "\u2AB6": "scnE",
        "\u2AB7": "prap",
        "\u2AB8": "scap",
        "\u2AB9": "prnap",
        "\u2ABA": "scnap",
        "\u2ABB": "Pr",
        "\u2ABC": "Sc",
        "\u2ABD": "subdot",
        "\u2ABE": "supdot",
        "\u2ABF": "subplus",
        "\u2AC0": "supplus",
        "\u2AC1": "submult",
        "\u2AC2": "supmult",
        "\u2AC3": "subedot",
        "\u2AC4": "supedot",
        "\u2AC5": "subE",
        "\u2AC5\u0338": "nsubE",
        "\u2AC6": "supE",
        "\u2AC6\u0338": "nsupE",
        "\u2AC7": "subsim",
        "\u2AC8": "supsim",
        "\u2ACB\uFE00": "vsubnE",
        "\u2ACB": "subnE",
        "\u2ACC\uFE00": "vsupnE",
        "\u2ACC": "supnE",
        "\u2ACF": "csub",
        "\u2AD0": "csup",
        "\u2AD1": "csube",
        "\u2AD2": "csupe",
        "\u2AD3": "subsup",
        "\u2AD4": "supsub",
        "\u2AD5": "subsub",
        "\u2AD6": "supsup",
        "\u2AD7": "suphsub",
        "\u2AD8": "supdsub",
        "\u2AD9": "forkv",
        "\u2ADA": "topfork",
        "\u2ADB": "mlcp",
        "\u2AE4": "Dashv",
        "\u2AE6": "Vdashl",
        "\u2AE7": "Barv",
        "\u2AE8": "vBar",
        "\u2AE9": "vBarv",
        "\u2AEB": "Vbar",
        "\u2AEC": "Not",
        "\u2AED": "bNot",
        "\u2AEE": "rnmid",
        "\u2AEF": "cirmid",
        "\u2AF0": "midcir",
        "\u2AF1": "topcir",
        "\u2AF2": "nhpar",
        "\u2AF3": "parsim",
        "\u2AFD": "parsl",
        "\u2AFD\u20E5": "nparsl",
        "\u266D": "flat",
        "\u266E": "natur",
        "\u266F": "sharp",
        "\xA4": "curren",
        "\xA2": "cent",
        "$": "dollar",
        "\xA3": "pound",
        "\xA5": "yen",
        "\u20AC": "euro",
        "\xB9": "sup1",
        "\xBD": "half",
        "\u2153": "frac13",
        "\xBC": "frac14",
        "\u2155": "frac15",
        "\u2159": "frac16",
        "\u215B": "frac18",
        "\xB2": "sup2",
        "\u2154": "frac23",
        "\u2156": "frac25",
        "\xB3": "sup3",
        "\xBE": "frac34",
        "\u2157": "frac35",
        "\u215C": "frac38",
        "\u2158": "frac45",
        "\u215A": "frac56",
        "\u215D": "frac58",
        "\u215E": "frac78",
        "\u{1D4B6}": "ascr",
        "\u{1D552}": "aopf",
        "\u{1D51E}": "afr",
        "\u{1D538}": "Aopf",
        "\u{1D504}": "Afr",
        "\u{1D49C}": "Ascr",
        "\xAA": "ordf",
        "\xE1": "aacute",
        "\xC1": "Aacute",
        "\xE0": "agrave",
        "\xC0": "Agrave",
        "\u0103": "abreve",
        "\u0102": "Abreve",
        "\xE2": "acirc",
        "\xC2": "Acirc",
        "\xE5": "aring",
        "\xC5": "angst",
        "\xE4": "auml",
        "\xC4": "Auml",
        "\xE3": "atilde",
        "\xC3": "Atilde",
        "\u0105": "aogon",
        "\u0104": "Aogon",
        "\u0101": "amacr",
        "\u0100": "Amacr",
        "\xE6": "aelig",
        "\xC6": "AElig",
        "\u{1D4B7}": "bscr",
        "\u{1D553}": "bopf",
        "\u{1D51F}": "bfr",
        "\u{1D539}": "Bopf",
        "\u212C": "Bscr",
        "\u{1D505}": "Bfr",
        "\u{1D520}": "cfr",
        "\u{1D4B8}": "cscr",
        "\u{1D554}": "copf",
        "\u212D": "Cfr",
        "\u{1D49E}": "Cscr",
        "\u2102": "Copf",
        "\u0107": "cacute",
        "\u0106": "Cacute",
        "\u0109": "ccirc",
        "\u0108": "Ccirc",
        "\u010D": "ccaron",
        "\u010C": "Ccaron",
        "\u010B": "cdot",
        "\u010A": "Cdot",
        "\xE7": "ccedil",
        "\xC7": "Ccedil",
        "\u2105": "incare",
        "\u{1D521}": "dfr",
        "\u2146": "dd",
        "\u{1D555}": "dopf",
        "\u{1D4B9}": "dscr",
        "\u{1D49F}": "Dscr",
        "\u{1D507}": "Dfr",
        "\u2145": "DD",
        "\u{1D53B}": "Dopf",
        "\u010F": "dcaron",
        "\u010E": "Dcaron",
        "\u0111": "dstrok",
        "\u0110": "Dstrok",
        "\xF0": "eth",
        "\xD0": "ETH",
        "\u2147": "ee",
        "\u212F": "escr",
        "\u{1D522}": "efr",
        "\u{1D556}": "eopf",
        "\u2130": "Escr",
        "\u{1D508}": "Efr",
        "\u{1D53C}": "Eopf",
        "\xE9": "eacute",
        "\xC9": "Eacute",
        "\xE8": "egrave",
        "\xC8": "Egrave",
        "\xEA": "ecirc",
        "\xCA": "Ecirc",
        "\u011B": "ecaron",
        "\u011A": "Ecaron",
        "\xEB": "euml",
        "\xCB": "Euml",
        "\u0117": "edot",
        "\u0116": "Edot",
        "\u0119": "eogon",
        "\u0118": "Eogon",
        "\u0113": "emacr",
        "\u0112": "Emacr",
        "\u{1D523}": "ffr",
        "\u{1D557}": "fopf",
        "\u{1D4BB}": "fscr",
        "\u{1D509}": "Ffr",
        "\u{1D53D}": "Fopf",
        "\u2131": "Fscr",
        "\uFB00": "fflig",
        "\uFB03": "ffilig",
        "\uFB04": "ffllig",
        "\uFB01": "filig",
        "fj": "fjlig",
        "\uFB02": "fllig",
        "\u0192": "fnof",
        "\u210A": "gscr",
        "\u{1D558}": "gopf",
        "\u{1D524}": "gfr",
        "\u{1D4A2}": "Gscr",
        "\u{1D53E}": "Gopf",
        "\u{1D50A}": "Gfr",
        "\u01F5": "gacute",
        "\u011F": "gbreve",
        "\u011E": "Gbreve",
        "\u011D": "gcirc",
        "\u011C": "Gcirc",
        "\u0121": "gdot",
        "\u0120": "Gdot",
        "\u0122": "Gcedil",
        "\u{1D525}": "hfr",
        "\u210E": "planckh",
        "\u{1D4BD}": "hscr",
        "\u{1D559}": "hopf",
        "\u210B": "Hscr",
        "\u210C": "Hfr",
        "\u210D": "Hopf",
        "\u0125": "hcirc",
        "\u0124": "Hcirc",
        "\u210F": "hbar",
        "\u0127": "hstrok",
        "\u0126": "Hstrok",
        "\u{1D55A}": "iopf",
        "\u{1D526}": "ifr",
        "\u{1D4BE}": "iscr",
        "\u2148": "ii",
        "\u{1D540}": "Iopf",
        "\u2110": "Iscr",
        "\u2111": "Im",
        "\xED": "iacute",
        "\xCD": "Iacute",
        "\xEC": "igrave",
        "\xCC": "Igrave",
        "\xEE": "icirc",
        "\xCE": "Icirc",
        "\xEF": "iuml",
        "\xCF": "Iuml",
        "\u0129": "itilde",
        "\u0128": "Itilde",
        "\u0130": "Idot",
        "\u012F": "iogon",
        "\u012E": "Iogon",
        "\u012B": "imacr",
        "\u012A": "Imacr",
        "\u0133": "ijlig",
        "\u0132": "IJlig",
        "\u0131": "imath",
        "\u{1D4BF}": "jscr",
        "\u{1D55B}": "jopf",
        "\u{1D527}": "jfr",
        "\u{1D4A5}": "Jscr",
        "\u{1D50D}": "Jfr",
        "\u{1D541}": "Jopf",
        "\u0135": "jcirc",
        "\u0134": "Jcirc",
        "\u0237": "jmath",
        "\u{1D55C}": "kopf",
        "\u{1D4C0}": "kscr",
        "\u{1D528}": "kfr",
        "\u{1D4A6}": "Kscr",
        "\u{1D542}": "Kopf",
        "\u{1D50E}": "Kfr",
        "\u0137": "kcedil",
        "\u0136": "Kcedil",
        "\u{1D529}": "lfr",
        "\u{1D4C1}": "lscr",
        "\u2113": "ell",
        "\u{1D55D}": "lopf",
        "\u2112": "Lscr",
        "\u{1D50F}": "Lfr",
        "\u{1D543}": "Lopf",
        "\u013A": "lacute",
        "\u0139": "Lacute",
        "\u013E": "lcaron",
        "\u013D": "Lcaron",
        "\u013C": "lcedil",
        "\u013B": "Lcedil",
        "\u0142": "lstrok",
        "\u0141": "Lstrok",
        "\u0140": "lmidot",
        "\u013F": "Lmidot",
        "\u{1D52A}": "mfr",
        "\u{1D55E}": "mopf",
        "\u{1D4C2}": "mscr",
        "\u{1D510}": "Mfr",
        "\u{1D544}": "Mopf",
        "\u2133": "Mscr",
        "\u{1D52B}": "nfr",
        "\u{1D55F}": "nopf",
        "\u{1D4C3}": "nscr",
        "\u2115": "Nopf",
        "\u{1D4A9}": "Nscr",
        "\u{1D511}": "Nfr",
        "\u0144": "nacute",
        "\u0143": "Nacute",
        "\u0148": "ncaron",
        "\u0147": "Ncaron",
        "\xF1": "ntilde",
        "\xD1": "Ntilde",
        "\u0146": "ncedil",
        "\u0145": "Ncedil",
        "\u2116": "numero",
        "\u014B": "eng",
        "\u014A": "ENG",
        "\u{1D560}": "oopf",
        "\u{1D52C}": "ofr",
        "\u2134": "oscr",
        "\u{1D4AA}": "Oscr",
        "\u{1D512}": "Ofr",
        "\u{1D546}": "Oopf",
        "\xBA": "ordm",
        "\xF3": "oacute",
        "\xD3": "Oacute",
        "\xF2": "ograve",
        "\xD2": "Ograve",
        "\xF4": "ocirc",
        "\xD4": "Ocirc",
        "\xF6": "ouml",
        "\xD6": "Ouml",
        "\u0151": "odblac",
        "\u0150": "Odblac",
        "\xF5": "otilde",
        "\xD5": "Otilde",
        "\xF8": "oslash",
        "\xD8": "Oslash",
        "\u014D": "omacr",
        "\u014C": "Omacr",
        "\u0153": "oelig",
        "\u0152": "OElig",
        "\u{1D52D}": "pfr",
        "\u{1D4C5}": "pscr",
        "\u{1D561}": "popf",
        "\u2119": "Popf",
        "\u{1D513}": "Pfr",
        "\u{1D4AB}": "Pscr",
        "\u{1D562}": "qopf",
        "\u{1D52E}": "qfr",
        "\u{1D4C6}": "qscr",
        "\u{1D4AC}": "Qscr",
        "\u{1D514}": "Qfr",
        "\u211A": "Qopf",
        "\u0138": "kgreen",
        "\u{1D52F}": "rfr",
        "\u{1D563}": "ropf",
        "\u{1D4C7}": "rscr",
        "\u211B": "Rscr",
        "\u211C": "Re",
        "\u211D": "Ropf",
        "\u0155": "racute",
        "\u0154": "Racute",
        "\u0159": "rcaron",
        "\u0158": "Rcaron",
        "\u0157": "rcedil",
        "\u0156": "Rcedil",
        "\u{1D564}": "sopf",
        "\u{1D4C8}": "sscr",
        "\u{1D530}": "sfr",
        "\u{1D54A}": "Sopf",
        "\u{1D516}": "Sfr",
        "\u{1D4AE}": "Sscr",
        "\u24C8": "oS",
        "\u015B": "sacute",
        "\u015A": "Sacute",
        "\u015D": "scirc",
        "\u015C": "Scirc",
        "\u0161": "scaron",
        "\u0160": "Scaron",
        "\u015F": "scedil",
        "\u015E": "Scedil",
        "\xDF": "szlig",
        "\u{1D531}": "tfr",
        "\u{1D4C9}": "tscr",
        "\u{1D565}": "topf",
        "\u{1D4AF}": "Tscr",
        "\u{1D517}": "Tfr",
        "\u{1D54B}": "Topf",
        "\u0165": "tcaron",
        "\u0164": "Tcaron",
        "\u0163": "tcedil",
        "\u0162": "Tcedil",
        "\u2122": "trade",
        "\u0167": "tstrok",
        "\u0166": "Tstrok",
        "\u{1D4CA}": "uscr",
        "\u{1D566}": "uopf",
        "\u{1D532}": "ufr",
        "\u{1D54C}": "Uopf",
        "\u{1D518}": "Ufr",
        "\u{1D4B0}": "Uscr",
        "\xFA": "uacute",
        "\xDA": "Uacute",
        "\xF9": "ugrave",
        "\xD9": "Ugrave",
        "\u016D": "ubreve",
        "\u016C": "Ubreve",
        "\xFB": "ucirc",
        "\xDB": "Ucirc",
        "\u016F": "uring",
        "\u016E": "Uring",
        "\xFC": "uuml",
        "\xDC": "Uuml",
        "\u0171": "udblac",
        "\u0170": "Udblac",
        "\u0169": "utilde",
        "\u0168": "Utilde",
        "\u0173": "uogon",
        "\u0172": "Uogon",
        "\u016B": "umacr",
        "\u016A": "Umacr",
        "\u{1D533}": "vfr",
        "\u{1D567}": "vopf",
        "\u{1D4CB}": "vscr",
        "\u{1D519}": "Vfr",
        "\u{1D54D}": "Vopf",
        "\u{1D4B1}": "Vscr",
        "\u{1D568}": "wopf",
        "\u{1D4CC}": "wscr",
        "\u{1D534}": "wfr",
        "\u{1D4B2}": "Wscr",
        "\u{1D54E}": "Wopf",
        "\u{1D51A}": "Wfr",
        "\u0175": "wcirc",
        "\u0174": "Wcirc",
        "\u{1D535}": "xfr",
        "\u{1D4CD}": "xscr",
        "\u{1D569}": "xopf",
        "\u{1D54F}": "Xopf",
        "\u{1D51B}": "Xfr",
        "\u{1D4B3}": "Xscr",
        "\u{1D536}": "yfr",
        "\u{1D4CE}": "yscr",
        "\u{1D56A}": "yopf",
        "\u{1D4B4}": "Yscr",
        "\u{1D51C}": "Yfr",
        "\u{1D550}": "Yopf",
        "\xFD": "yacute",
        "\xDD": "Yacute",
        "\u0177": "ycirc",
        "\u0176": "Ycirc",
        "\xFF": "yuml",
        "\u0178": "Yuml",
        "\u{1D4CF}": "zscr",
        "\u{1D537}": "zfr",
        "\u{1D56B}": "zopf",
        "\u2128": "Zfr",
        "\u2124": "Zopf",
        "\u{1D4B5}": "Zscr",
        "\u017A": "zacute",
        "\u0179": "Zacute",
        "\u017E": "zcaron",
        "\u017D": "Zcaron",
        "\u017C": "zdot",
        "\u017B": "Zdot",
        "\u01B5": "imped",
        "\xFE": "thorn",
        "\xDE": "THORN",
        "\u0149": "napos",
        "\u03B1": "alpha",
        "\u0391": "Alpha",
        "\u03B2": "beta",
        "\u0392": "Beta",
        "\u03B3": "gamma",
        "\u0393": "Gamma",
        "\u03B4": "delta",
        "\u0394": "Delta",
        "\u03B5": "epsi",
        "\u03F5": "epsiv",
        "\u0395": "Epsilon",
        "\u03DD": "gammad",
        "\u03DC": "Gammad",
        "\u03B6": "zeta",
        "\u0396": "Zeta",
        "\u03B7": "eta",
        "\u0397": "Eta",
        "\u03B8": "theta",
        "\u03D1": "thetav",
        "\u0398": "Theta",
        "\u03B9": "iota",
        "\u0399": "Iota",
        "\u03BA": "kappa",
        "\u03F0": "kappav",
        "\u039A": "Kappa",
        "\u03BB": "lambda",
        "\u039B": "Lambda",
        "\u03BC": "mu",
        "\xB5": "micro",
        "\u039C": "Mu",
        "\u03BD": "nu",
        "\u039D": "Nu",
        "\u03BE": "xi",
        "\u039E": "Xi",
        "\u03BF": "omicron",
        "\u039F": "Omicron",
        "\u03C0": "pi",
        "\u03D6": "piv",
        "\u03A0": "Pi",
        "\u03C1": "rho",
        "\u03F1": "rhov",
        "\u03A1": "Rho",
        "\u03C3": "sigma",
        "\u03A3": "Sigma",
        "\u03C2": "sigmaf",
        "\u03C4": "tau",
        "\u03A4": "Tau",
        "\u03C5": "upsi",
        "\u03A5": "Upsilon",
        "\u03D2": "Upsi",
        "\u03C6": "phi",
        "\u03D5": "phiv",
        "\u03A6": "Phi",
        "\u03C7": "chi",
        "\u03A7": "Chi",
        "\u03C8": "psi",
        "\u03A8": "Psi",
        "\u03C9": "omega",
        "\u03A9": "ohm",
        "\u0430": "acy",
        "\u0410": "Acy",
        "\u0431": "bcy",
        "\u0411": "Bcy",
        "\u0432": "vcy",
        "\u0412": "Vcy",
        "\u0433": "gcy",
        "\u0413": "Gcy",
        "\u0453": "gjcy",
        "\u0403": "GJcy",
        "\u0434": "dcy",
        "\u0414": "Dcy",
        "\u0452": "djcy",
        "\u0402": "DJcy",
        "\u0435": "iecy",
        "\u0415": "IEcy",
        "\u0451": "iocy",
        "\u0401": "IOcy",
        "\u0454": "jukcy",
        "\u0404": "Jukcy",
        "\u0436": "zhcy",
        "\u0416": "ZHcy",
        "\u0437": "zcy",
        "\u0417": "Zcy",
        "\u0455": "dscy",
        "\u0405": "DScy",
        "\u0438": "icy",
        "\u0418": "Icy",
        "\u0456": "iukcy",
        "\u0406": "Iukcy",
        "\u0457": "yicy",
        "\u0407": "YIcy",
        "\u0439": "jcy",
        "\u0419": "Jcy",
        "\u0458": "jsercy",
        "\u0408": "Jsercy",
        "\u043A": "kcy",
        "\u041A": "Kcy",
        "\u045C": "kjcy",
        "\u040C": "KJcy",
        "\u043B": "lcy",
        "\u041B": "Lcy",
        "\u0459": "ljcy",
        "\u0409": "LJcy",
        "\u043C": "mcy",
        "\u041C": "Mcy",
        "\u043D": "ncy",
        "\u041D": "Ncy",
        "\u045A": "njcy",
        "\u040A": "NJcy",
        "\u043E": "ocy",
        "\u041E": "Ocy",
        "\u043F": "pcy",
        "\u041F": "Pcy",
        "\u0440": "rcy",
        "\u0420": "Rcy",
        "\u0441": "scy",
        "\u0421": "Scy",
        "\u0442": "tcy",
        "\u0422": "Tcy",
        "\u045B": "tshcy",
        "\u040B": "TSHcy",
        "\u0443": "ucy",
        "\u0423": "Ucy",
        "\u045E": "ubrcy",
        "\u040E": "Ubrcy",
        "\u0444": "fcy",
        "\u0424": "Fcy",
        "\u0445": "khcy",
        "\u0425": "KHcy",
        "\u0446": "tscy",
        "\u0426": "TScy",
        "\u0447": "chcy",
        "\u0427": "CHcy",
        "\u045F": "dzcy",
        "\u040F": "DZcy",
        "\u0448": "shcy",
        "\u0428": "SHcy",
        "\u0449": "shchcy",
        "\u0429": "SHCHcy",
        "\u044A": "hardcy",
        "\u042A": "HARDcy",
        "\u044B": "ycy",
        "\u042B": "Ycy",
        "\u044C": "softcy",
        "\u042C": "SOFTcy",
        "\u044D": "ecy",
        "\u042D": "Ecy",
        "\u044E": "yucy",
        "\u042E": "YUcy",
        "\u044F": "yacy",
        "\u042F": "YAcy",
        "\u2135": "aleph",
        "\u2136": "beth",
        "\u2137": "gimel",
        "\u2138": "daleth"
      };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = {
        "aacute": "\xE1",
        "Aacute": "\xC1",
        "abreve": "\u0103",
        "Abreve": "\u0102",
        "ac": "\u223E",
        "acd": "\u223F",
        "acE": "\u223E\u0333",
        "acirc": "\xE2",
        "Acirc": "\xC2",
        "acute": "\xB4",
        "acy": "\u0430",
        "Acy": "\u0410",
        "aelig": "\xE6",
        "AElig": "\xC6",
        "af": "\u2061",
        "afr": "\u{1D51E}",
        "Afr": "\u{1D504}",
        "agrave": "\xE0",
        "Agrave": "\xC0",
        "alefsym": "\u2135",
        "aleph": "\u2135",
        "alpha": "\u03B1",
        "Alpha": "\u0391",
        "amacr": "\u0101",
        "Amacr": "\u0100",
        "amalg": "\u2A3F",
        "amp": "&",
        "AMP": "&",
        "and": "\u2227",
        "And": "\u2A53",
        "andand": "\u2A55",
        "andd": "\u2A5C",
        "andslope": "\u2A58",
        "andv": "\u2A5A",
        "ang": "\u2220",
        "ange": "\u29A4",
        "angle": "\u2220",
        "angmsd": "\u2221",
        "angmsdaa": "\u29A8",
        "angmsdab": "\u29A9",
        "angmsdac": "\u29AA",
        "angmsdad": "\u29AB",
        "angmsdae": "\u29AC",
        "angmsdaf": "\u29AD",
        "angmsdag": "\u29AE",
        "angmsdah": "\u29AF",
        "angrt": "\u221F",
        "angrtvb": "\u22BE",
        "angrtvbd": "\u299D",
        "angsph": "\u2222",
        "angst": "\xC5",
        "angzarr": "\u237C",
        "aogon": "\u0105",
        "Aogon": "\u0104",
        "aopf": "\u{1D552}",
        "Aopf": "\u{1D538}",
        "ap": "\u2248",
        "apacir": "\u2A6F",
        "ape": "\u224A",
        "apE": "\u2A70",
        "apid": "\u224B",
        "apos": "'",
        "ApplyFunction": "\u2061",
        "approx": "\u2248",
        "approxeq": "\u224A",
        "aring": "\xE5",
        "Aring": "\xC5",
        "ascr": "\u{1D4B6}",
        "Ascr": "\u{1D49C}",
        "Assign": "\u2254",
        "ast": "*",
        "asymp": "\u2248",
        "asympeq": "\u224D",
        "atilde": "\xE3",
        "Atilde": "\xC3",
        "auml": "\xE4",
        "Auml": "\xC4",
        "awconint": "\u2233",
        "awint": "\u2A11",
        "backcong": "\u224C",
        "backepsilon": "\u03F6",
        "backprime": "\u2035",
        "backsim": "\u223D",
        "backsimeq": "\u22CD",
        "Backslash": "\u2216",
        "Barv": "\u2AE7",
        "barvee": "\u22BD",
        "barwed": "\u2305",
        "Barwed": "\u2306",
        "barwedge": "\u2305",
        "bbrk": "\u23B5",
        "bbrktbrk": "\u23B6",
        "bcong": "\u224C",
        "bcy": "\u0431",
        "Bcy": "\u0411",
        "bdquo": "\u201E",
        "becaus": "\u2235",
        "because": "\u2235",
        "Because": "\u2235",
        "bemptyv": "\u29B0",
        "bepsi": "\u03F6",
        "bernou": "\u212C",
        "Bernoullis": "\u212C",
        "beta": "\u03B2",
        "Beta": "\u0392",
        "beth": "\u2136",
        "between": "\u226C",
        "bfr": "\u{1D51F}",
        "Bfr": "\u{1D505}",
        "bigcap": "\u22C2",
        "bigcirc": "\u25EF",
        "bigcup": "\u22C3",
        "bigodot": "\u2A00",
        "bigoplus": "\u2A01",
        "bigotimes": "\u2A02",
        "bigsqcup": "\u2A06",
        "bigstar": "\u2605",
        "bigtriangledown": "\u25BD",
        "bigtriangleup": "\u25B3",
        "biguplus": "\u2A04",
        "bigvee": "\u22C1",
        "bigwedge": "\u22C0",
        "bkarow": "\u290D",
        "blacklozenge": "\u29EB",
        "blacksquare": "\u25AA",
        "blacktriangle": "\u25B4",
        "blacktriangledown": "\u25BE",
        "blacktriangleleft": "\u25C2",
        "blacktriangleright": "\u25B8",
        "blank": "\u2423",
        "blk12": "\u2592",
        "blk14": "\u2591",
        "blk34": "\u2593",
        "block": "\u2588",
        "bne": "=\u20E5",
        "bnequiv": "\u2261\u20E5",
        "bnot": "\u2310",
        "bNot": "\u2AED",
        "bopf": "\u{1D553}",
        "Bopf": "\u{1D539}",
        "bot": "\u22A5",
        "bottom": "\u22A5",
        "bowtie": "\u22C8",
        "boxbox": "\u29C9",
        "boxdl": "\u2510",
        "boxdL": "\u2555",
        "boxDl": "\u2556",
        "boxDL": "\u2557",
        "boxdr": "\u250C",
        "boxdR": "\u2552",
        "boxDr": "\u2553",
        "boxDR": "\u2554",
        "boxh": "\u2500",
        "boxH": "\u2550",
        "boxhd": "\u252C",
        "boxhD": "\u2565",
        "boxHd": "\u2564",
        "boxHD": "\u2566",
        "boxhu": "\u2534",
        "boxhU": "\u2568",
        "boxHu": "\u2567",
        "boxHU": "\u2569",
        "boxminus": "\u229F",
        "boxplus": "\u229E",
        "boxtimes": "\u22A0",
        "boxul": "\u2518",
        "boxuL": "\u255B",
        "boxUl": "\u255C",
        "boxUL": "\u255D",
        "boxur": "\u2514",
        "boxuR": "\u2558",
        "boxUr": "\u2559",
        "boxUR": "\u255A",
        "boxv": "\u2502",
        "boxV": "\u2551",
        "boxvh": "\u253C",
        "boxvH": "\u256A",
        "boxVh": "\u256B",
        "boxVH": "\u256C",
        "boxvl": "\u2524",
        "boxvL": "\u2561",
        "boxVl": "\u2562",
        "boxVL": "\u2563",
        "boxvr": "\u251C",
        "boxvR": "\u255E",
        "boxVr": "\u255F",
        "boxVR": "\u2560",
        "bprime": "\u2035",
        "breve": "\u02D8",
        "Breve": "\u02D8",
        "brvbar": "\xA6",
        "bscr": "\u{1D4B7}",
        "Bscr": "\u212C",
        "bsemi": "\u204F",
        "bsim": "\u223D",
        "bsime": "\u22CD",
        "bsol": "\\",
        "bsolb": "\u29C5",
        "bsolhsub": "\u27C8",
        "bull": "\u2022",
        "bullet": "\u2022",
        "bump": "\u224E",
        "bumpe": "\u224F",
        "bumpE": "\u2AAE",
        "bumpeq": "\u224F",
        "Bumpeq": "\u224E",
        "cacute": "\u0107",
        "Cacute": "\u0106",
        "cap": "\u2229",
        "Cap": "\u22D2",
        "capand": "\u2A44",
        "capbrcup": "\u2A49",
        "capcap": "\u2A4B",
        "capcup": "\u2A47",
        "capdot": "\u2A40",
        "CapitalDifferentialD": "\u2145",
        "caps": "\u2229\uFE00",
        "caret": "\u2041",
        "caron": "\u02C7",
        "Cayleys": "\u212D",
        "ccaps": "\u2A4D",
        "ccaron": "\u010D",
        "Ccaron": "\u010C",
        "ccedil": "\xE7",
        "Ccedil": "\xC7",
        "ccirc": "\u0109",
        "Ccirc": "\u0108",
        "Cconint": "\u2230",
        "ccups": "\u2A4C",
        "ccupssm": "\u2A50",
        "cdot": "\u010B",
        "Cdot": "\u010A",
        "cedil": "\xB8",
        "Cedilla": "\xB8",
        "cemptyv": "\u29B2",
        "cent": "\xA2",
        "centerdot": "\xB7",
        "CenterDot": "\xB7",
        "cfr": "\u{1D520}",
        "Cfr": "\u212D",
        "chcy": "\u0447",
        "CHcy": "\u0427",
        "check": "\u2713",
        "checkmark": "\u2713",
        "chi": "\u03C7",
        "Chi": "\u03A7",
        "cir": "\u25CB",
        "circ": "\u02C6",
        "circeq": "\u2257",
        "circlearrowleft": "\u21BA",
        "circlearrowright": "\u21BB",
        "circledast": "\u229B",
        "circledcirc": "\u229A",
        "circleddash": "\u229D",
        "CircleDot": "\u2299",
        "circledR": "\xAE",
        "circledS": "\u24C8",
        "CircleMinus": "\u2296",
        "CirclePlus": "\u2295",
        "CircleTimes": "\u2297",
        "cire": "\u2257",
        "cirE": "\u29C3",
        "cirfnint": "\u2A10",
        "cirmid": "\u2AEF",
        "cirscir": "\u29C2",
        "ClockwiseContourIntegral": "\u2232",
        "CloseCurlyDoubleQuote": "\u201D",
        "CloseCurlyQuote": "\u2019",
        "clubs": "\u2663",
        "clubsuit": "\u2663",
        "colon": ":",
        "Colon": "\u2237",
        "colone": "\u2254",
        "Colone": "\u2A74",
        "coloneq": "\u2254",
        "comma": ",",
        "commat": "@",
        "comp": "\u2201",
        "compfn": "\u2218",
        "complement": "\u2201",
        "complexes": "\u2102",
        "cong": "\u2245",
        "congdot": "\u2A6D",
        "Congruent": "\u2261",
        "conint": "\u222E",
        "Conint": "\u222F",
        "ContourIntegral": "\u222E",
        "copf": "\u{1D554}",
        "Copf": "\u2102",
        "coprod": "\u2210",
        "Coproduct": "\u2210",
        "copy": "\xA9",
        "COPY": "\xA9",
        "copysr": "\u2117",
        "CounterClockwiseContourIntegral": "\u2233",
        "crarr": "\u21B5",
        "cross": "\u2717",
        "Cross": "\u2A2F",
        "cscr": "\u{1D4B8}",
        "Cscr": "\u{1D49E}",
        "csub": "\u2ACF",
        "csube": "\u2AD1",
        "csup": "\u2AD0",
        "csupe": "\u2AD2",
        "ctdot": "\u22EF",
        "cudarrl": "\u2938",
        "cudarrr": "\u2935",
        "cuepr": "\u22DE",
        "cuesc": "\u22DF",
        "cularr": "\u21B6",
        "cularrp": "\u293D",
        "cup": "\u222A",
        "Cup": "\u22D3",
        "cupbrcap": "\u2A48",
        "cupcap": "\u2A46",
        "CupCap": "\u224D",
        "cupcup": "\u2A4A",
        "cupdot": "\u228D",
        "cupor": "\u2A45",
        "cups": "\u222A\uFE00",
        "curarr": "\u21B7",
        "curarrm": "\u293C",
        "curlyeqprec": "\u22DE",
        "curlyeqsucc": "\u22DF",
        "curlyvee": "\u22CE",
        "curlywedge": "\u22CF",
        "curren": "\xA4",
        "curvearrowleft": "\u21B6",
        "curvearrowright": "\u21B7",
        "cuvee": "\u22CE",
        "cuwed": "\u22CF",
        "cwconint": "\u2232",
        "cwint": "\u2231",
        "cylcty": "\u232D",
        "dagger": "\u2020",
        "Dagger": "\u2021",
        "daleth": "\u2138",
        "darr": "\u2193",
        "dArr": "\u21D3",
        "Darr": "\u21A1",
        "dash": "\u2010",
        "dashv": "\u22A3",
        "Dashv": "\u2AE4",
        "dbkarow": "\u290F",
        "dblac": "\u02DD",
        "dcaron": "\u010F",
        "Dcaron": "\u010E",
        "dcy": "\u0434",
        "Dcy": "\u0414",
        "dd": "\u2146",
        "DD": "\u2145",
        "ddagger": "\u2021",
        "ddarr": "\u21CA",
        "DDotrahd": "\u2911",
        "ddotseq": "\u2A77",
        "deg": "\xB0",
        "Del": "\u2207",
        "delta": "\u03B4",
        "Delta": "\u0394",
        "demptyv": "\u29B1",
        "dfisht": "\u297F",
        "dfr": "\u{1D521}",
        "Dfr": "\u{1D507}",
        "dHar": "\u2965",
        "dharl": "\u21C3",
        "dharr": "\u21C2",
        "DiacriticalAcute": "\xB4",
        "DiacriticalDot": "\u02D9",
        "DiacriticalDoubleAcute": "\u02DD",
        "DiacriticalGrave": "`",
        "DiacriticalTilde": "\u02DC",
        "diam": "\u22C4",
        "diamond": "\u22C4",
        "Diamond": "\u22C4",
        "diamondsuit": "\u2666",
        "diams": "\u2666",
        "die": "\xA8",
        "DifferentialD": "\u2146",
        "digamma": "\u03DD",
        "disin": "\u22F2",
        "div": "\xF7",
        "divide": "\xF7",
        "divideontimes": "\u22C7",
        "divonx": "\u22C7",
        "djcy": "\u0452",
        "DJcy": "\u0402",
        "dlcorn": "\u231E",
        "dlcrop": "\u230D",
        "dollar": "$",
        "dopf": "\u{1D555}",
        "Dopf": "\u{1D53B}",
        "dot": "\u02D9",
        "Dot": "\xA8",
        "DotDot": "\u20DC",
        "doteq": "\u2250",
        "doteqdot": "\u2251",
        "DotEqual": "\u2250",
        "dotminus": "\u2238",
        "dotplus": "\u2214",
        "dotsquare": "\u22A1",
        "doublebarwedge": "\u2306",
        "DoubleContourIntegral": "\u222F",
        "DoubleDot": "\xA8",
        "DoubleDownArrow": "\u21D3",
        "DoubleLeftArrow": "\u21D0",
        "DoubleLeftRightArrow": "\u21D4",
        "DoubleLeftTee": "\u2AE4",
        "DoubleLongLeftArrow": "\u27F8",
        "DoubleLongLeftRightArrow": "\u27FA",
        "DoubleLongRightArrow": "\u27F9",
        "DoubleRightArrow": "\u21D2",
        "DoubleRightTee": "\u22A8",
        "DoubleUpArrow": "\u21D1",
        "DoubleUpDownArrow": "\u21D5",
        "DoubleVerticalBar": "\u2225",
        "downarrow": "\u2193",
        "Downarrow": "\u21D3",
        "DownArrow": "\u2193",
        "DownArrowBar": "\u2913",
        "DownArrowUpArrow": "\u21F5",
        "DownBreve": "\u0311",
        "downdownarrows": "\u21CA",
        "downharpoonleft": "\u21C3",
        "downharpoonright": "\u21C2",
        "DownLeftRightVector": "\u2950",
        "DownLeftTeeVector": "\u295E",
        "DownLeftVector": "\u21BD",
        "DownLeftVectorBar": "\u2956",
        "DownRightTeeVector": "\u295F",
        "DownRightVector": "\u21C1",
        "DownRightVectorBar": "\u2957",
        "DownTee": "\u22A4",
        "DownTeeArrow": "\u21A7",
        "drbkarow": "\u2910",
        "drcorn": "\u231F",
        "drcrop": "\u230C",
        "dscr": "\u{1D4B9}",
        "Dscr": "\u{1D49F}",
        "dscy": "\u0455",
        "DScy": "\u0405",
        "dsol": "\u29F6",
        "dstrok": "\u0111",
        "Dstrok": "\u0110",
        "dtdot": "\u22F1",
        "dtri": "\u25BF",
        "dtrif": "\u25BE",
        "duarr": "\u21F5",
        "duhar": "\u296F",
        "dwangle": "\u29A6",
        "dzcy": "\u045F",
        "DZcy": "\u040F",
        "dzigrarr": "\u27FF",
        "eacute": "\xE9",
        "Eacute": "\xC9",
        "easter": "\u2A6E",
        "ecaron": "\u011B",
        "Ecaron": "\u011A",
        "ecir": "\u2256",
        "ecirc": "\xEA",
        "Ecirc": "\xCA",
        "ecolon": "\u2255",
        "ecy": "\u044D",
        "Ecy": "\u042D",
        "eDDot": "\u2A77",
        "edot": "\u0117",
        "eDot": "\u2251",
        "Edot": "\u0116",
        "ee": "\u2147",
        "efDot": "\u2252",
        "efr": "\u{1D522}",
        "Efr": "\u{1D508}",
        "eg": "\u2A9A",
        "egrave": "\xE8",
        "Egrave": "\xC8",
        "egs": "\u2A96",
        "egsdot": "\u2A98",
        "el": "\u2A99",
        "Element": "\u2208",
        "elinters": "\u23E7",
        "ell": "\u2113",
        "els": "\u2A95",
        "elsdot": "\u2A97",
        "emacr": "\u0113",
        "Emacr": "\u0112",
        "empty": "\u2205",
        "emptyset": "\u2205",
        "EmptySmallSquare": "\u25FB",
        "emptyv": "\u2205",
        "EmptyVerySmallSquare": "\u25AB",
        "emsp": "\u2003",
        "emsp13": "\u2004",
        "emsp14": "\u2005",
        "eng": "\u014B",
        "ENG": "\u014A",
        "ensp": "\u2002",
        "eogon": "\u0119",
        "Eogon": "\u0118",
        "eopf": "\u{1D556}",
        "Eopf": "\u{1D53C}",
        "epar": "\u22D5",
        "eparsl": "\u29E3",
        "eplus": "\u2A71",
        "epsi": "\u03B5",
        "epsilon": "\u03B5",
        "Epsilon": "\u0395",
        "epsiv": "\u03F5",
        "eqcirc": "\u2256",
        "eqcolon": "\u2255",
        "eqsim": "\u2242",
        "eqslantgtr": "\u2A96",
        "eqslantless": "\u2A95",
        "Equal": "\u2A75",
        "equals": "=",
        "EqualTilde": "\u2242",
        "equest": "\u225F",
        "Equilibrium": "\u21CC",
        "equiv": "\u2261",
        "equivDD": "\u2A78",
        "eqvparsl": "\u29E5",
        "erarr": "\u2971",
        "erDot": "\u2253",
        "escr": "\u212F",
        "Escr": "\u2130",
        "esdot": "\u2250",
        "esim": "\u2242",
        "Esim": "\u2A73",
        "eta": "\u03B7",
        "Eta": "\u0397",
        "eth": "\xF0",
        "ETH": "\xD0",
        "euml": "\xEB",
        "Euml": "\xCB",
        "euro": "\u20AC",
        "excl": "!",
        "exist": "\u2203",
        "Exists": "\u2203",
        "expectation": "\u2130",
        "exponentiale": "\u2147",
        "ExponentialE": "\u2147",
        "fallingdotseq": "\u2252",
        "fcy": "\u0444",
        "Fcy": "\u0424",
        "female": "\u2640",
        "ffilig": "\uFB03",
        "fflig": "\uFB00",
        "ffllig": "\uFB04",
        "ffr": "\u{1D523}",
        "Ffr": "\u{1D509}",
        "filig": "\uFB01",
        "FilledSmallSquare": "\u25FC",
        "FilledVerySmallSquare": "\u25AA",
        "fjlig": "fj",
        "flat": "\u266D",
        "fllig": "\uFB02",
        "fltns": "\u25B1",
        "fnof": "\u0192",
        "fopf": "\u{1D557}",
        "Fopf": "\u{1D53D}",
        "forall": "\u2200",
        "ForAll": "\u2200",
        "fork": "\u22D4",
        "forkv": "\u2AD9",
        "Fouriertrf": "\u2131",
        "fpartint": "\u2A0D",
        "frac12": "\xBD",
        "frac13": "\u2153",
        "frac14": "\xBC",
        "frac15": "\u2155",
        "frac16": "\u2159",
        "frac18": "\u215B",
        "frac23": "\u2154",
        "frac25": "\u2156",
        "frac34": "\xBE",
        "frac35": "\u2157",
        "frac38": "\u215C",
        "frac45": "\u2158",
        "frac56": "\u215A",
        "frac58": "\u215D",
        "frac78": "\u215E",
        "frasl": "\u2044",
        "frown": "\u2322",
        "fscr": "\u{1D4BB}",
        "Fscr": "\u2131",
        "gacute": "\u01F5",
        "gamma": "\u03B3",
        "Gamma": "\u0393",
        "gammad": "\u03DD",
        "Gammad": "\u03DC",
        "gap": "\u2A86",
        "gbreve": "\u011F",
        "Gbreve": "\u011E",
        "Gcedil": "\u0122",
        "gcirc": "\u011D",
        "Gcirc": "\u011C",
        "gcy": "\u0433",
        "Gcy": "\u0413",
        "gdot": "\u0121",
        "Gdot": "\u0120",
        "ge": "\u2265",
        "gE": "\u2267",
        "gel": "\u22DB",
        "gEl": "\u2A8C",
        "geq": "\u2265",
        "geqq": "\u2267",
        "geqslant": "\u2A7E",
        "ges": "\u2A7E",
        "gescc": "\u2AA9",
        "gesdot": "\u2A80",
        "gesdoto": "\u2A82",
        "gesdotol": "\u2A84",
        "gesl": "\u22DB\uFE00",
        "gesles": "\u2A94",
        "gfr": "\u{1D524}",
        "Gfr": "\u{1D50A}",
        "gg": "\u226B",
        "Gg": "\u22D9",
        "ggg": "\u22D9",
        "gimel": "\u2137",
        "gjcy": "\u0453",
        "GJcy": "\u0403",
        "gl": "\u2277",
        "gla": "\u2AA5",
        "glE": "\u2A92",
        "glj": "\u2AA4",
        "gnap": "\u2A8A",
        "gnapprox": "\u2A8A",
        "gne": "\u2A88",
        "gnE": "\u2269",
        "gneq": "\u2A88",
        "gneqq": "\u2269",
        "gnsim": "\u22E7",
        "gopf": "\u{1D558}",
        "Gopf": "\u{1D53E}",
        "grave": "`",
        "GreaterEqual": "\u2265",
        "GreaterEqualLess": "\u22DB",
        "GreaterFullEqual": "\u2267",
        "GreaterGreater": "\u2AA2",
        "GreaterLess": "\u2277",
        "GreaterSlantEqual": "\u2A7E",
        "GreaterTilde": "\u2273",
        "gscr": "\u210A",
        "Gscr": "\u{1D4A2}",
        "gsim": "\u2273",
        "gsime": "\u2A8E",
        "gsiml": "\u2A90",
        "gt": ">",
        "Gt": "\u226B",
        "GT": ">",
        "gtcc": "\u2AA7",
        "gtcir": "\u2A7A",
        "gtdot": "\u22D7",
        "gtlPar": "\u2995",
        "gtquest": "\u2A7C",
        "gtrapprox": "\u2A86",
        "gtrarr": "\u2978",
        "gtrdot": "\u22D7",
        "gtreqless": "\u22DB",
        "gtreqqless": "\u2A8C",
        "gtrless": "\u2277",
        "gtrsim": "\u2273",
        "gvertneqq": "\u2269\uFE00",
        "gvnE": "\u2269\uFE00",
        "Hacek": "\u02C7",
        "hairsp": "\u200A",
        "half": "\xBD",
        "hamilt": "\u210B",
        "hardcy": "\u044A",
        "HARDcy": "\u042A",
        "harr": "\u2194",
        "hArr": "\u21D4",
        "harrcir": "\u2948",
        "harrw": "\u21AD",
        "Hat": "^",
        "hbar": "\u210F",
        "hcirc": "\u0125",
        "Hcirc": "\u0124",
        "hearts": "\u2665",
        "heartsuit": "\u2665",
        "hellip": "\u2026",
        "hercon": "\u22B9",
        "hfr": "\u{1D525}",
        "Hfr": "\u210C",
        "HilbertSpace": "\u210B",
        "hksearow": "\u2925",
        "hkswarow": "\u2926",
        "hoarr": "\u21FF",
        "homtht": "\u223B",
        "hookleftarrow": "\u21A9",
        "hookrightarrow": "\u21AA",
        "hopf": "\u{1D559}",
        "Hopf": "\u210D",
        "horbar": "\u2015",
        "HorizontalLine": "\u2500",
        "hscr": "\u{1D4BD}",
        "Hscr": "\u210B",
        "hslash": "\u210F",
        "hstrok": "\u0127",
        "Hstrok": "\u0126",
        "HumpDownHump": "\u224E",
        "HumpEqual": "\u224F",
        "hybull": "\u2043",
        "hyphen": "\u2010",
        "iacute": "\xED",
        "Iacute": "\xCD",
        "ic": "\u2063",
        "icirc": "\xEE",
        "Icirc": "\xCE",
        "icy": "\u0438",
        "Icy": "\u0418",
        "Idot": "\u0130",
        "iecy": "\u0435",
        "IEcy": "\u0415",
        "iexcl": "\xA1",
        "iff": "\u21D4",
        "ifr": "\u{1D526}",
        "Ifr": "\u2111",
        "igrave": "\xEC",
        "Igrave": "\xCC",
        "ii": "\u2148",
        "iiiint": "\u2A0C",
        "iiint": "\u222D",
        "iinfin": "\u29DC",
        "iiota": "\u2129",
        "ijlig": "\u0133",
        "IJlig": "\u0132",
        "Im": "\u2111",
        "imacr": "\u012B",
        "Imacr": "\u012A",
        "image": "\u2111",
        "ImaginaryI": "\u2148",
        "imagline": "\u2110",
        "imagpart": "\u2111",
        "imath": "\u0131",
        "imof": "\u22B7",
        "imped": "\u01B5",
        "Implies": "\u21D2",
        "in": "\u2208",
        "incare": "\u2105",
        "infin": "\u221E",
        "infintie": "\u29DD",
        "inodot": "\u0131",
        "int": "\u222B",
        "Int": "\u222C",
        "intcal": "\u22BA",
        "integers": "\u2124",
        "Integral": "\u222B",
        "intercal": "\u22BA",
        "Intersection": "\u22C2",
        "intlarhk": "\u2A17",
        "intprod": "\u2A3C",
        "InvisibleComma": "\u2063",
        "InvisibleTimes": "\u2062",
        "iocy": "\u0451",
        "IOcy": "\u0401",
        "iogon": "\u012F",
        "Iogon": "\u012E",
        "iopf": "\u{1D55A}",
        "Iopf": "\u{1D540}",
        "iota": "\u03B9",
        "Iota": "\u0399",
        "iprod": "\u2A3C",
        "iquest": "\xBF",
        "iscr": "\u{1D4BE}",
        "Iscr": "\u2110",
        "isin": "\u2208",
        "isindot": "\u22F5",
        "isinE": "\u22F9",
        "isins": "\u22F4",
        "isinsv": "\u22F3",
        "isinv": "\u2208",
        "it": "\u2062",
        "itilde": "\u0129",
        "Itilde": "\u0128",
        "iukcy": "\u0456",
        "Iukcy": "\u0406",
        "iuml": "\xEF",
        "Iuml": "\xCF",
        "jcirc": "\u0135",
        "Jcirc": "\u0134",
        "jcy": "\u0439",
        "Jcy": "\u0419",
        "jfr": "\u{1D527}",
        "Jfr": "\u{1D50D}",
        "jmath": "\u0237",
        "jopf": "\u{1D55B}",
        "Jopf": "\u{1D541}",
        "jscr": "\u{1D4BF}",
        "Jscr": "\u{1D4A5}",
        "jsercy": "\u0458",
        "Jsercy": "\u0408",
        "jukcy": "\u0454",
        "Jukcy": "\u0404",
        "kappa": "\u03BA",
        "Kappa": "\u039A",
        "kappav": "\u03F0",
        "kcedil": "\u0137",
        "Kcedil": "\u0136",
        "kcy": "\u043A",
        "Kcy": "\u041A",
        "kfr": "\u{1D528}",
        "Kfr": "\u{1D50E}",
        "kgreen": "\u0138",
        "khcy": "\u0445",
        "KHcy": "\u0425",
        "kjcy": "\u045C",
        "KJcy": "\u040C",
        "kopf": "\u{1D55C}",
        "Kopf": "\u{1D542}",
        "kscr": "\u{1D4C0}",
        "Kscr": "\u{1D4A6}",
        "lAarr": "\u21DA",
        "lacute": "\u013A",
        "Lacute": "\u0139",
        "laemptyv": "\u29B4",
        "lagran": "\u2112",
        "lambda": "\u03BB",
        "Lambda": "\u039B",
        "lang": "\u27E8",
        "Lang": "\u27EA",
        "langd": "\u2991",
        "langle": "\u27E8",
        "lap": "\u2A85",
        "Laplacetrf": "\u2112",
        "laquo": "\xAB",
        "larr": "\u2190",
        "lArr": "\u21D0",
        "Larr": "\u219E",
        "larrb": "\u21E4",
        "larrbfs": "\u291F",
        "larrfs": "\u291D",
        "larrhk": "\u21A9",
        "larrlp": "\u21AB",
        "larrpl": "\u2939",
        "larrsim": "\u2973",
        "larrtl": "\u21A2",
        "lat": "\u2AAB",
        "latail": "\u2919",
        "lAtail": "\u291B",
        "late": "\u2AAD",
        "lates": "\u2AAD\uFE00",
        "lbarr": "\u290C",
        "lBarr": "\u290E",
        "lbbrk": "\u2772",
        "lbrace": "{",
        "lbrack": "[",
        "lbrke": "\u298B",
        "lbrksld": "\u298F",
        "lbrkslu": "\u298D",
        "lcaron": "\u013E",
        "Lcaron": "\u013D",
        "lcedil": "\u013C",
        "Lcedil": "\u013B",
        "lceil": "\u2308",
        "lcub": "{",
        "lcy": "\u043B",
        "Lcy": "\u041B",
        "ldca": "\u2936",
        "ldquo": "\u201C",
        "ldquor": "\u201E",
        "ldrdhar": "\u2967",
        "ldrushar": "\u294B",
        "ldsh": "\u21B2",
        "le": "\u2264",
        "lE": "\u2266",
        "LeftAngleBracket": "\u27E8",
        "leftarrow": "\u2190",
        "Leftarrow": "\u21D0",
        "LeftArrow": "\u2190",
        "LeftArrowBar": "\u21E4",
        "LeftArrowRightArrow": "\u21C6",
        "leftarrowtail": "\u21A2",
        "LeftCeiling": "\u2308",
        "LeftDoubleBracket": "\u27E6",
        "LeftDownTeeVector": "\u2961",
        "LeftDownVector": "\u21C3",
        "LeftDownVectorBar": "\u2959",
        "LeftFloor": "\u230A",
        "leftharpoondown": "\u21BD",
        "leftharpoonup": "\u21BC",
        "leftleftarrows": "\u21C7",
        "leftrightarrow": "\u2194",
        "Leftrightarrow": "\u21D4",
        "LeftRightArrow": "\u2194",
        "leftrightarrows": "\u21C6",
        "leftrightharpoons": "\u21CB",
        "leftrightsquigarrow": "\u21AD",
        "LeftRightVector": "\u294E",
        "LeftTee": "\u22A3",
        "LeftTeeArrow": "\u21A4",
        "LeftTeeVector": "\u295A",
        "leftthreetimes": "\u22CB",
        "LeftTriangle": "\u22B2",
        "LeftTriangleBar": "\u29CF",
        "LeftTriangleEqual": "\u22B4",
        "LeftUpDownVector": "\u2951",
        "LeftUpTeeVector": "\u2960",
        "LeftUpVector": "\u21BF",
        "LeftUpVectorBar": "\u2958",
        "LeftVector": "\u21BC",
        "LeftVectorBar": "\u2952",
        "leg": "\u22DA",
        "lEg": "\u2A8B",
        "leq": "\u2264",
        "leqq": "\u2266",
        "leqslant": "\u2A7D",
        "les": "\u2A7D",
        "lescc": "\u2AA8",
        "lesdot": "\u2A7F",
        "lesdoto": "\u2A81",
        "lesdotor": "\u2A83",
        "lesg": "\u22DA\uFE00",
        "lesges": "\u2A93",
        "lessapprox": "\u2A85",
        "lessdot": "\u22D6",
        "lesseqgtr": "\u22DA",
        "lesseqqgtr": "\u2A8B",
        "LessEqualGreater": "\u22DA",
        "LessFullEqual": "\u2266",
        "LessGreater": "\u2276",
        "lessgtr": "\u2276",
        "LessLess": "\u2AA1",
        "lesssim": "\u2272",
        "LessSlantEqual": "\u2A7D",
        "LessTilde": "\u2272",
        "lfisht": "\u297C",
        "lfloor": "\u230A",
        "lfr": "\u{1D529}",
        "Lfr": "\u{1D50F}",
        "lg": "\u2276",
        "lgE": "\u2A91",
        "lHar": "\u2962",
        "lhard": "\u21BD",
        "lharu": "\u21BC",
        "lharul": "\u296A",
        "lhblk": "\u2584",
        "ljcy": "\u0459",
        "LJcy": "\u0409",
        "ll": "\u226A",
        "Ll": "\u22D8",
        "llarr": "\u21C7",
        "llcorner": "\u231E",
        "Lleftarrow": "\u21DA",
        "llhard": "\u296B",
        "lltri": "\u25FA",
        "lmidot": "\u0140",
        "Lmidot": "\u013F",
        "lmoust": "\u23B0",
        "lmoustache": "\u23B0",
        "lnap": "\u2A89",
        "lnapprox": "\u2A89",
        "lne": "\u2A87",
        "lnE": "\u2268",
        "lneq": "\u2A87",
        "lneqq": "\u2268",
        "lnsim": "\u22E6",
        "loang": "\u27EC",
        "loarr": "\u21FD",
        "lobrk": "\u27E6",
        "longleftarrow": "\u27F5",
        "Longleftarrow": "\u27F8",
        "LongLeftArrow": "\u27F5",
        "longleftrightarrow": "\u27F7",
        "Longleftrightarrow": "\u27FA",
        "LongLeftRightArrow": "\u27F7",
        "longmapsto": "\u27FC",
        "longrightarrow": "\u27F6",
        "Longrightarrow": "\u27F9",
        "LongRightArrow": "\u27F6",
        "looparrowleft": "\u21AB",
        "looparrowright": "\u21AC",
        "lopar": "\u2985",
        "lopf": "\u{1D55D}",
        "Lopf": "\u{1D543}",
        "loplus": "\u2A2D",
        "lotimes": "\u2A34",
        "lowast": "\u2217",
        "lowbar": "_",
        "LowerLeftArrow": "\u2199",
        "LowerRightArrow": "\u2198",
        "loz": "\u25CA",
        "lozenge": "\u25CA",
        "lozf": "\u29EB",
        "lpar": "(",
        "lparlt": "\u2993",
        "lrarr": "\u21C6",
        "lrcorner": "\u231F",
        "lrhar": "\u21CB",
        "lrhard": "\u296D",
        "lrm": "\u200E",
        "lrtri": "\u22BF",
        "lsaquo": "\u2039",
        "lscr": "\u{1D4C1}",
        "Lscr": "\u2112",
        "lsh": "\u21B0",
        "Lsh": "\u21B0",
        "lsim": "\u2272",
        "lsime": "\u2A8D",
        "lsimg": "\u2A8F",
        "lsqb": "[",
        "lsquo": "\u2018",
        "lsquor": "\u201A",
        "lstrok": "\u0142",
        "Lstrok": "\u0141",
        "lt": "<",
        "Lt": "\u226A",
        "LT": "<",
        "ltcc": "\u2AA6",
        "ltcir": "\u2A79",
        "ltdot": "\u22D6",
        "lthree": "\u22CB",
        "ltimes": "\u22C9",
        "ltlarr": "\u2976",
        "ltquest": "\u2A7B",
        "ltri": "\u25C3",
        "ltrie": "\u22B4",
        "ltrif": "\u25C2",
        "ltrPar": "\u2996",
        "lurdshar": "\u294A",
        "luruhar": "\u2966",
        "lvertneqq": "\u2268\uFE00",
        "lvnE": "\u2268\uFE00",
        "macr": "\xAF",
        "male": "\u2642",
        "malt": "\u2720",
        "maltese": "\u2720",
        "map": "\u21A6",
        "Map": "\u2905",
        "mapsto": "\u21A6",
        "mapstodown": "\u21A7",
        "mapstoleft": "\u21A4",
        "mapstoup": "\u21A5",
        "marker": "\u25AE",
        "mcomma": "\u2A29",
        "mcy": "\u043C",
        "Mcy": "\u041C",
        "mdash": "\u2014",
        "mDDot": "\u223A",
        "measuredangle": "\u2221",
        "MediumSpace": "\u205F",
        "Mellintrf": "\u2133",
        "mfr": "\u{1D52A}",
        "Mfr": "\u{1D510}",
        "mho": "\u2127",
        "micro": "\xB5",
        "mid": "\u2223",
        "midast": "*",
        "midcir": "\u2AF0",
        "middot": "\xB7",
        "minus": "\u2212",
        "minusb": "\u229F",
        "minusd": "\u2238",
        "minusdu": "\u2A2A",
        "MinusPlus": "\u2213",
        "mlcp": "\u2ADB",
        "mldr": "\u2026",
        "mnplus": "\u2213",
        "models": "\u22A7",
        "mopf": "\u{1D55E}",
        "Mopf": "\u{1D544}",
        "mp": "\u2213",
        "mscr": "\u{1D4C2}",
        "Mscr": "\u2133",
        "mstpos": "\u223E",
        "mu": "\u03BC",
        "Mu": "\u039C",
        "multimap": "\u22B8",
        "mumap": "\u22B8",
        "nabla": "\u2207",
        "nacute": "\u0144",
        "Nacute": "\u0143",
        "nang": "\u2220\u20D2",
        "nap": "\u2249",
        "napE": "\u2A70\u0338",
        "napid": "\u224B\u0338",
        "napos": "\u0149",
        "napprox": "\u2249",
        "natur": "\u266E",
        "natural": "\u266E",
        "naturals": "\u2115",
        "nbsp": "\xA0",
        "nbump": "\u224E\u0338",
        "nbumpe": "\u224F\u0338",
        "ncap": "\u2A43",
        "ncaron": "\u0148",
        "Ncaron": "\u0147",
        "ncedil": "\u0146",
        "Ncedil": "\u0145",
        "ncong": "\u2247",
        "ncongdot": "\u2A6D\u0338",
        "ncup": "\u2A42",
        "ncy": "\u043D",
        "Ncy": "\u041D",
        "ndash": "\u2013",
        "ne": "\u2260",
        "nearhk": "\u2924",
        "nearr": "\u2197",
        "neArr": "\u21D7",
        "nearrow": "\u2197",
        "nedot": "\u2250\u0338",
        "NegativeMediumSpace": "\u200B",
        "NegativeThickSpace": "\u200B",
        "NegativeThinSpace": "\u200B",
        "NegativeVeryThinSpace": "\u200B",
        "nequiv": "\u2262",
        "nesear": "\u2928",
        "nesim": "\u2242\u0338",
        "NestedGreaterGreater": "\u226B",
        "NestedLessLess": "\u226A",
        "NewLine": "\n",
        "nexist": "\u2204",
        "nexists": "\u2204",
        "nfr": "\u{1D52B}",
        "Nfr": "\u{1D511}",
        "nge": "\u2271",
        "ngE": "\u2267\u0338",
        "ngeq": "\u2271",
        "ngeqq": "\u2267\u0338",
        "ngeqslant": "\u2A7E\u0338",
        "nges": "\u2A7E\u0338",
        "nGg": "\u22D9\u0338",
        "ngsim": "\u2275",
        "ngt": "\u226F",
        "nGt": "\u226B\u20D2",
        "ngtr": "\u226F",
        "nGtv": "\u226B\u0338",
        "nharr": "\u21AE",
        "nhArr": "\u21CE",
        "nhpar": "\u2AF2",
        "ni": "\u220B",
        "nis": "\u22FC",
        "nisd": "\u22FA",
        "niv": "\u220B",
        "njcy": "\u045A",
        "NJcy": "\u040A",
        "nlarr": "\u219A",
        "nlArr": "\u21CD",
        "nldr": "\u2025",
        "nle": "\u2270",
        "nlE": "\u2266\u0338",
        "nleftarrow": "\u219A",
        "nLeftarrow": "\u21CD",
        "nleftrightarrow": "\u21AE",
        "nLeftrightarrow": "\u21CE",
        "nleq": "\u2270",
        "nleqq": "\u2266\u0338",
        "nleqslant": "\u2A7D\u0338",
        "nles": "\u2A7D\u0338",
        "nless": "\u226E",
        "nLl": "\u22D8\u0338",
        "nlsim": "\u2274",
        "nlt": "\u226E",
        "nLt": "\u226A\u20D2",
        "nltri": "\u22EA",
        "nltrie": "\u22EC",
        "nLtv": "\u226A\u0338",
        "nmid": "\u2224",
        "NoBreak": "\u2060",
        "NonBreakingSpace": "\xA0",
        "nopf": "\u{1D55F}",
        "Nopf": "\u2115",
        "not": "\xAC",
        "Not": "\u2AEC",
        "NotCongruent": "\u2262",
        "NotCupCap": "\u226D",
        "NotDoubleVerticalBar": "\u2226",
        "NotElement": "\u2209",
        "NotEqual": "\u2260",
        "NotEqualTilde": "\u2242\u0338",
        "NotExists": "\u2204",
        "NotGreater": "\u226F",
        "NotGreaterEqual": "\u2271",
        "NotGreaterFullEqual": "\u2267\u0338",
        "NotGreaterGreater": "\u226B\u0338",
        "NotGreaterLess": "\u2279",
        "NotGreaterSlantEqual": "\u2A7E\u0338",
        "NotGreaterTilde": "\u2275",
        "NotHumpDownHump": "\u224E\u0338",
        "NotHumpEqual": "\u224F\u0338",
        "notin": "\u2209",
        "notindot": "\u22F5\u0338",
        "notinE": "\u22F9\u0338",
        "notinva": "\u2209",
        "notinvb": "\u22F7",
        "notinvc": "\u22F6",
        "NotLeftTriangle": "\u22EA",
        "NotLeftTriangleBar": "\u29CF\u0338",
        "NotLeftTriangleEqual": "\u22EC",
        "NotLess": "\u226E",
        "NotLessEqual": "\u2270",
        "NotLessGreater": "\u2278",
        "NotLessLess": "\u226A\u0338",
        "NotLessSlantEqual": "\u2A7D\u0338",
        "NotLessTilde": "\u2274",
        "NotNestedGreaterGreater": "\u2AA2\u0338",
        "NotNestedLessLess": "\u2AA1\u0338",
        "notni": "\u220C",
        "notniva": "\u220C",
        "notnivb": "\u22FE",
        "notnivc": "\u22FD",
        "NotPrecedes": "\u2280",
        "NotPrecedesEqual": "\u2AAF\u0338",
        "NotPrecedesSlantEqual": "\u22E0",
        "NotReverseElement": "\u220C",
        "NotRightTriangle": "\u22EB",
        "NotRightTriangleBar": "\u29D0\u0338",
        "NotRightTriangleEqual": "\u22ED",
        "NotSquareSubset": "\u228F\u0338",
        "NotSquareSubsetEqual": "\u22E2",
        "NotSquareSuperset": "\u2290\u0338",
        "NotSquareSupersetEqual": "\u22E3",
        "NotSubset": "\u2282\u20D2",
        "NotSubsetEqual": "\u2288",
        "NotSucceeds": "\u2281",
        "NotSucceedsEqual": "\u2AB0\u0338",
        "NotSucceedsSlantEqual": "\u22E1",
        "NotSucceedsTilde": "\u227F\u0338",
        "NotSuperset": "\u2283\u20D2",
        "NotSupersetEqual": "\u2289",
        "NotTilde": "\u2241",
        "NotTildeEqual": "\u2244",
        "NotTildeFullEqual": "\u2247",
        "NotTildeTilde": "\u2249",
        "NotVerticalBar": "\u2224",
        "npar": "\u2226",
        "nparallel": "\u2226",
        "nparsl": "\u2AFD\u20E5",
        "npart": "\u2202\u0338",
        "npolint": "\u2A14",
        "npr": "\u2280",
        "nprcue": "\u22E0",
        "npre": "\u2AAF\u0338",
        "nprec": "\u2280",
        "npreceq": "\u2AAF\u0338",
        "nrarr": "\u219B",
        "nrArr": "\u21CF",
        "nrarrc": "\u2933\u0338",
        "nrarrw": "\u219D\u0338",
        "nrightarrow": "\u219B",
        "nRightarrow": "\u21CF",
        "nrtri": "\u22EB",
        "nrtrie": "\u22ED",
        "nsc": "\u2281",
        "nsccue": "\u22E1",
        "nsce": "\u2AB0\u0338",
        "nscr": "\u{1D4C3}",
        "Nscr": "\u{1D4A9}",
        "nshortmid": "\u2224",
        "nshortparallel": "\u2226",
        "nsim": "\u2241",
        "nsime": "\u2244",
        "nsimeq": "\u2244",
        "nsmid": "\u2224",
        "nspar": "\u2226",
        "nsqsube": "\u22E2",
        "nsqsupe": "\u22E3",
        "nsub": "\u2284",
        "nsube": "\u2288",
        "nsubE": "\u2AC5\u0338",
        "nsubset": "\u2282\u20D2",
        "nsubseteq": "\u2288",
        "nsubseteqq": "\u2AC5\u0338",
        "nsucc": "\u2281",
        "nsucceq": "\u2AB0\u0338",
        "nsup": "\u2285",
        "nsupe": "\u2289",
        "nsupE": "\u2AC6\u0338",
        "nsupset": "\u2283\u20D2",
        "nsupseteq": "\u2289",
        "nsupseteqq": "\u2AC6\u0338",
        "ntgl": "\u2279",
        "ntilde": "\xF1",
        "Ntilde": "\xD1",
        "ntlg": "\u2278",
        "ntriangleleft": "\u22EA",
        "ntrianglelefteq": "\u22EC",
        "ntriangleright": "\u22EB",
        "ntrianglerighteq": "\u22ED",
        "nu": "\u03BD",
        "Nu": "\u039D",
        "num": "#",
        "numero": "\u2116",
        "numsp": "\u2007",
        "nvap": "\u224D\u20D2",
        "nvdash": "\u22AC",
        "nvDash": "\u22AD",
        "nVdash": "\u22AE",
        "nVDash": "\u22AF",
        "nvge": "\u2265\u20D2",
        "nvgt": ">\u20D2",
        "nvHarr": "\u2904",
        "nvinfin": "\u29DE",
        "nvlArr": "\u2902",
        "nvle": "\u2264\u20D2",
        "nvlt": "<\u20D2",
        "nvltrie": "\u22B4\u20D2",
        "nvrArr": "\u2903",
        "nvrtrie": "\u22B5\u20D2",
        "nvsim": "\u223C\u20D2",
        "nwarhk": "\u2923",
        "nwarr": "\u2196",
        "nwArr": "\u21D6",
        "nwarrow": "\u2196",
        "nwnear": "\u2927",
        "oacute": "\xF3",
        "Oacute": "\xD3",
        "oast": "\u229B",
        "ocir": "\u229A",
        "ocirc": "\xF4",
        "Ocirc": "\xD4",
        "ocy": "\u043E",
        "Ocy": "\u041E",
        "odash": "\u229D",
        "odblac": "\u0151",
        "Odblac": "\u0150",
        "odiv": "\u2A38",
        "odot": "\u2299",
        "odsold": "\u29BC",
        "oelig": "\u0153",
        "OElig": "\u0152",
        "ofcir": "\u29BF",
        "ofr": "\u{1D52C}",
        "Ofr": "\u{1D512}",
        "ogon": "\u02DB",
        "ograve": "\xF2",
        "Ograve": "\xD2",
        "ogt": "\u29C1",
        "ohbar": "\u29B5",
        "ohm": "\u03A9",
        "oint": "\u222E",
        "olarr": "\u21BA",
        "olcir": "\u29BE",
        "olcross": "\u29BB",
        "oline": "\u203E",
        "olt": "\u29C0",
        "omacr": "\u014D",
        "Omacr": "\u014C",
        "omega": "\u03C9",
        "Omega": "\u03A9",
        "omicron": "\u03BF",
        "Omicron": "\u039F",
        "omid": "\u29B6",
        "ominus": "\u2296",
        "oopf": "\u{1D560}",
        "Oopf": "\u{1D546}",
        "opar": "\u29B7",
        "OpenCurlyDoubleQuote": "\u201C",
        "OpenCurlyQuote": "\u2018",
        "operp": "\u29B9",
        "oplus": "\u2295",
        "or": "\u2228",
        "Or": "\u2A54",
        "orarr": "\u21BB",
        "ord": "\u2A5D",
        "order": "\u2134",
        "orderof": "\u2134",
        "ordf": "\xAA",
        "ordm": "\xBA",
        "origof": "\u22B6",
        "oror": "\u2A56",
        "orslope": "\u2A57",
        "orv": "\u2A5B",
        "oS": "\u24C8",
        "oscr": "\u2134",
        "Oscr": "\u{1D4AA}",
        "oslash": "\xF8",
        "Oslash": "\xD8",
        "osol": "\u2298",
        "otilde": "\xF5",
        "Otilde": "\xD5",
        "otimes": "\u2297",
        "Otimes": "\u2A37",
        "otimesas": "\u2A36",
        "ouml": "\xF6",
        "Ouml": "\xD6",
        "ovbar": "\u233D",
        "OverBar": "\u203E",
        "OverBrace": "\u23DE",
        "OverBracket": "\u23B4",
        "OverParenthesis": "\u23DC",
        "par": "\u2225",
        "para": "\xB6",
        "parallel": "\u2225",
        "parsim": "\u2AF3",
        "parsl": "\u2AFD",
        "part": "\u2202",
        "PartialD": "\u2202",
        "pcy": "\u043F",
        "Pcy": "\u041F",
        "percnt": "%",
        "period": ".",
        "permil": "\u2030",
        "perp": "\u22A5",
        "pertenk": "\u2031",
        "pfr": "\u{1D52D}",
        "Pfr": "\u{1D513}",
        "phi": "\u03C6",
        "Phi": "\u03A6",
        "phiv": "\u03D5",
        "phmmat": "\u2133",
        "phone": "\u260E",
        "pi": "\u03C0",
        "Pi": "\u03A0",
        "pitchfork": "\u22D4",
        "piv": "\u03D6",
        "planck": "\u210F",
        "planckh": "\u210E",
        "plankv": "\u210F",
        "plus": "+",
        "plusacir": "\u2A23",
        "plusb": "\u229E",
        "pluscir": "\u2A22",
        "plusdo": "\u2214",
        "plusdu": "\u2A25",
        "pluse": "\u2A72",
        "PlusMinus": "\xB1",
        "plusmn": "\xB1",
        "plussim": "\u2A26",
        "plustwo": "\u2A27",
        "pm": "\xB1",
        "Poincareplane": "\u210C",
        "pointint": "\u2A15",
        "popf": "\u{1D561}",
        "Popf": "\u2119",
        "pound": "\xA3",
        "pr": "\u227A",
        "Pr": "\u2ABB",
        "prap": "\u2AB7",
        "prcue": "\u227C",
        "pre": "\u2AAF",
        "prE": "\u2AB3",
        "prec": "\u227A",
        "precapprox": "\u2AB7",
        "preccurlyeq": "\u227C",
        "Precedes": "\u227A",
        "PrecedesEqual": "\u2AAF",
        "PrecedesSlantEqual": "\u227C",
        "PrecedesTilde": "\u227E",
        "preceq": "\u2AAF",
        "precnapprox": "\u2AB9",
        "precneqq": "\u2AB5",
        "precnsim": "\u22E8",
        "precsim": "\u227E",
        "prime": "\u2032",
        "Prime": "\u2033",
        "primes": "\u2119",
        "prnap": "\u2AB9",
        "prnE": "\u2AB5",
        "prnsim": "\u22E8",
        "prod": "\u220F",
        "Product": "\u220F",
        "profalar": "\u232E",
        "profline": "\u2312",
        "profsurf": "\u2313",
        "prop": "\u221D",
        "Proportion": "\u2237",
        "Proportional": "\u221D",
        "propto": "\u221D",
        "prsim": "\u227E",
        "prurel": "\u22B0",
        "pscr": "\u{1D4C5}",
        "Pscr": "\u{1D4AB}",
        "psi": "\u03C8",
        "Psi": "\u03A8",
        "puncsp": "\u2008",
        "qfr": "\u{1D52E}",
        "Qfr": "\u{1D514}",
        "qint": "\u2A0C",
        "qopf": "\u{1D562}",
        "Qopf": "\u211A",
        "qprime": "\u2057",
        "qscr": "\u{1D4C6}",
        "Qscr": "\u{1D4AC}",
        "quaternions": "\u210D",
        "quatint": "\u2A16",
        "quest": "?",
        "questeq": "\u225F",
        "quot": '"',
        "QUOT": '"',
        "rAarr": "\u21DB",
        "race": "\u223D\u0331",
        "racute": "\u0155",
        "Racute": "\u0154",
        "radic": "\u221A",
        "raemptyv": "\u29B3",
        "rang": "\u27E9",
        "Rang": "\u27EB",
        "rangd": "\u2992",
        "range": "\u29A5",
        "rangle": "\u27E9",
        "raquo": "\xBB",
        "rarr": "\u2192",
        "rArr": "\u21D2",
        "Rarr": "\u21A0",
        "rarrap": "\u2975",
        "rarrb": "\u21E5",
        "rarrbfs": "\u2920",
        "rarrc": "\u2933",
        "rarrfs": "\u291E",
        "rarrhk": "\u21AA",
        "rarrlp": "\u21AC",
        "rarrpl": "\u2945",
        "rarrsim": "\u2974",
        "rarrtl": "\u21A3",
        "Rarrtl": "\u2916",
        "rarrw": "\u219D",
        "ratail": "\u291A",
        "rAtail": "\u291C",
        "ratio": "\u2236",
        "rationals": "\u211A",
        "rbarr": "\u290D",
        "rBarr": "\u290F",
        "RBarr": "\u2910",
        "rbbrk": "\u2773",
        "rbrace": "}",
        "rbrack": "]",
        "rbrke": "\u298C",
        "rbrksld": "\u298E",
        "rbrkslu": "\u2990",
        "rcaron": "\u0159",
        "Rcaron": "\u0158",
        "rcedil": "\u0157",
        "Rcedil": "\u0156",
        "rceil": "\u2309",
        "rcub": "}",
        "rcy": "\u0440",
        "Rcy": "\u0420",
        "rdca": "\u2937",
        "rdldhar": "\u2969",
        "rdquo": "\u201D",
        "rdquor": "\u201D",
        "rdsh": "\u21B3",
        "Re": "\u211C",
        "real": "\u211C",
        "realine": "\u211B",
        "realpart": "\u211C",
        "reals": "\u211D",
        "rect": "\u25AD",
        "reg": "\xAE",
        "REG": "\xAE",
        "ReverseElement": "\u220B",
        "ReverseEquilibrium": "\u21CB",
        "ReverseUpEquilibrium": "\u296F",
        "rfisht": "\u297D",
        "rfloor": "\u230B",
        "rfr": "\u{1D52F}",
        "Rfr": "\u211C",
        "rHar": "\u2964",
        "rhard": "\u21C1",
        "rharu": "\u21C0",
        "rharul": "\u296C",
        "rho": "\u03C1",
        "Rho": "\u03A1",
        "rhov": "\u03F1",
        "RightAngleBracket": "\u27E9",
        "rightarrow": "\u2192",
        "Rightarrow": "\u21D2",
        "RightArrow": "\u2192",
        "RightArrowBar": "\u21E5",
        "RightArrowLeftArrow": "\u21C4",
        "rightarrowtail": "\u21A3",
        "RightCeiling": "\u2309",
        "RightDoubleBracket": "\u27E7",
        "RightDownTeeVector": "\u295D",
        "RightDownVector": "\u21C2",
        "RightDownVectorBar": "\u2955",
        "RightFloor": "\u230B",
        "rightharpoondown": "\u21C1",
        "rightharpoonup": "\u21C0",
        "rightleftarrows": "\u21C4",
        "rightleftharpoons": "\u21CC",
        "rightrightarrows": "\u21C9",
        "rightsquigarrow": "\u219D",
        "RightTee": "\u22A2",
        "RightTeeArrow": "\u21A6",
        "RightTeeVector": "\u295B",
        "rightthreetimes": "\u22CC",
        "RightTriangle": "\u22B3",
        "RightTriangleBar": "\u29D0",
        "RightTriangleEqual": "\u22B5",
        "RightUpDownVector": "\u294F",
        "RightUpTeeVector": "\u295C",
        "RightUpVector": "\u21BE",
        "RightUpVectorBar": "\u2954",
        "RightVector": "\u21C0",
        "RightVectorBar": "\u2953",
        "ring": "\u02DA",
        "risingdotseq": "\u2253",
        "rlarr": "\u21C4",
        "rlhar": "\u21CC",
        "rlm": "\u200F",
        "rmoust": "\u23B1",
        "rmoustache": "\u23B1",
        "rnmid": "\u2AEE",
        "roang": "\u27ED",
        "roarr": "\u21FE",
        "robrk": "\u27E7",
        "ropar": "\u2986",
        "ropf": "\u{1D563}",
        "Ropf": "\u211D",
        "roplus": "\u2A2E",
        "rotimes": "\u2A35",
        "RoundImplies": "\u2970",
        "rpar": ")",
        "rpargt": "\u2994",
        "rppolint": "\u2A12",
        "rrarr": "\u21C9",
        "Rrightarrow": "\u21DB",
        "rsaquo": "\u203A",
        "rscr": "\u{1D4C7}",
        "Rscr": "\u211B",
        "rsh": "\u21B1",
        "Rsh": "\u21B1",
        "rsqb": "]",
        "rsquo": "\u2019",
        "rsquor": "\u2019",
        "rthree": "\u22CC",
        "rtimes": "\u22CA",
        "rtri": "\u25B9",
        "rtrie": "\u22B5",
        "rtrif": "\u25B8",
        "rtriltri": "\u29CE",
        "RuleDelayed": "\u29F4",
        "ruluhar": "\u2968",
        "rx": "\u211E",
        "sacute": "\u015B",
        "Sacute": "\u015A",
        "sbquo": "\u201A",
        "sc": "\u227B",
        "Sc": "\u2ABC",
        "scap": "\u2AB8",
        "scaron": "\u0161",
        "Scaron": "\u0160",
        "sccue": "\u227D",
        "sce": "\u2AB0",
        "scE": "\u2AB4",
        "scedil": "\u015F",
        "Scedil": "\u015E",
        "scirc": "\u015D",
        "Scirc": "\u015C",
        "scnap": "\u2ABA",
        "scnE": "\u2AB6",
        "scnsim": "\u22E9",
        "scpolint": "\u2A13",
        "scsim": "\u227F",
        "scy": "\u0441",
        "Scy": "\u0421",
        "sdot": "\u22C5",
        "sdotb": "\u22A1",
        "sdote": "\u2A66",
        "searhk": "\u2925",
        "searr": "\u2198",
        "seArr": "\u21D8",
        "searrow": "\u2198",
        "sect": "\xA7",
        "semi": ";",
        "seswar": "\u2929",
        "setminus": "\u2216",
        "setmn": "\u2216",
        "sext": "\u2736",
        "sfr": "\u{1D530}",
        "Sfr": "\u{1D516}",
        "sfrown": "\u2322",
        "sharp": "\u266F",
        "shchcy": "\u0449",
        "SHCHcy": "\u0429",
        "shcy": "\u0448",
        "SHcy": "\u0428",
        "ShortDownArrow": "\u2193",
        "ShortLeftArrow": "\u2190",
        "shortmid": "\u2223",
        "shortparallel": "\u2225",
        "ShortRightArrow": "\u2192",
        "ShortUpArrow": "\u2191",
        "shy": "\xAD",
        "sigma": "\u03C3",
        "Sigma": "\u03A3",
        "sigmaf": "\u03C2",
        "sigmav": "\u03C2",
        "sim": "\u223C",
        "simdot": "\u2A6A",
        "sime": "\u2243",
        "simeq": "\u2243",
        "simg": "\u2A9E",
        "simgE": "\u2AA0",
        "siml": "\u2A9D",
        "simlE": "\u2A9F",
        "simne": "\u2246",
        "simplus": "\u2A24",
        "simrarr": "\u2972",
        "slarr": "\u2190",
        "SmallCircle": "\u2218",
        "smallsetminus": "\u2216",
        "smashp": "\u2A33",
        "smeparsl": "\u29E4",
        "smid": "\u2223",
        "smile": "\u2323",
        "smt": "\u2AAA",
        "smte": "\u2AAC",
        "smtes": "\u2AAC\uFE00",
        "softcy": "\u044C",
        "SOFTcy": "\u042C",
        "sol": "/",
        "solb": "\u29C4",
        "solbar": "\u233F",
        "sopf": "\u{1D564}",
        "Sopf": "\u{1D54A}",
        "spades": "\u2660",
        "spadesuit": "\u2660",
        "spar": "\u2225",
        "sqcap": "\u2293",
        "sqcaps": "\u2293\uFE00",
        "sqcup": "\u2294",
        "sqcups": "\u2294\uFE00",
        "Sqrt": "\u221A",
        "sqsub": "\u228F",
        "sqsube": "\u2291",
        "sqsubset": "\u228F",
        "sqsubseteq": "\u2291",
        "sqsup": "\u2290",
        "sqsupe": "\u2292",
        "sqsupset": "\u2290",
        "sqsupseteq": "\u2292",
        "squ": "\u25A1",
        "square": "\u25A1",
        "Square": "\u25A1",
        "SquareIntersection": "\u2293",
        "SquareSubset": "\u228F",
        "SquareSubsetEqual": "\u2291",
        "SquareSuperset": "\u2290",
        "SquareSupersetEqual": "\u2292",
        "SquareUnion": "\u2294",
        "squarf": "\u25AA",
        "squf": "\u25AA",
        "srarr": "\u2192",
        "sscr": "\u{1D4C8}",
        "Sscr": "\u{1D4AE}",
        "ssetmn": "\u2216",
        "ssmile": "\u2323",
        "sstarf": "\u22C6",
        "star": "\u2606",
        "Star": "\u22C6",
        "starf": "\u2605",
        "straightepsilon": "\u03F5",
        "straightphi": "\u03D5",
        "strns": "\xAF",
        "sub": "\u2282",
        "Sub": "\u22D0",
        "subdot": "\u2ABD",
        "sube": "\u2286",
        "subE": "\u2AC5",
        "subedot": "\u2AC3",
        "submult": "\u2AC1",
        "subne": "\u228A",
        "subnE": "\u2ACB",
        "subplus": "\u2ABF",
        "subrarr": "\u2979",
        "subset": "\u2282",
        "Subset": "\u22D0",
        "subseteq": "\u2286",
        "subseteqq": "\u2AC5",
        "SubsetEqual": "\u2286",
        "subsetneq": "\u228A",
        "subsetneqq": "\u2ACB",
        "subsim": "\u2AC7",
        "subsub": "\u2AD5",
        "subsup": "\u2AD3",
        "succ": "\u227B",
        "succapprox": "\u2AB8",
        "succcurlyeq": "\u227D",
        "Succeeds": "\u227B",
        "SucceedsEqual": "\u2AB0",
        "SucceedsSlantEqual": "\u227D",
        "SucceedsTilde": "\u227F",
        "succeq": "\u2AB0",
        "succnapprox": "\u2ABA",
        "succneqq": "\u2AB6",
        "succnsim": "\u22E9",
        "succsim": "\u227F",
        "SuchThat": "\u220B",
        "sum": "\u2211",
        "Sum": "\u2211",
        "sung": "\u266A",
        "sup": "\u2283",
        "Sup": "\u22D1",
        "sup1": "\xB9",
        "sup2": "\xB2",
        "sup3": "\xB3",
        "supdot": "\u2ABE",
        "supdsub": "\u2AD8",
        "supe": "\u2287",
        "supE": "\u2AC6",
        "supedot": "\u2AC4",
        "Superset": "\u2283",
        "SupersetEqual": "\u2287",
        "suphsol": "\u27C9",
        "suphsub": "\u2AD7",
        "suplarr": "\u297B",
        "supmult": "\u2AC2",
        "supne": "\u228B",
        "supnE": "\u2ACC",
        "supplus": "\u2AC0",
        "supset": "\u2283",
        "Supset": "\u22D1",
        "supseteq": "\u2287",
        "supseteqq": "\u2AC6",
        "supsetneq": "\u228B",
        "supsetneqq": "\u2ACC",
        "supsim": "\u2AC8",
        "supsub": "\u2AD4",
        "supsup": "\u2AD6",
        "swarhk": "\u2926",
        "swarr": "\u2199",
        "swArr": "\u21D9",
        "swarrow": "\u2199",
        "swnwar": "\u292A",
        "szlig": "\xDF",
        "Tab": "	",
        "target": "\u2316",
        "tau": "\u03C4",
        "Tau": "\u03A4",
        "tbrk": "\u23B4",
        "tcaron": "\u0165",
        "Tcaron": "\u0164",
        "tcedil": "\u0163",
        "Tcedil": "\u0162",
        "tcy": "\u0442",
        "Tcy": "\u0422",
        "tdot": "\u20DB",
        "telrec": "\u2315",
        "tfr": "\u{1D531}",
        "Tfr": "\u{1D517}",
        "there4": "\u2234",
        "therefore": "\u2234",
        "Therefore": "\u2234",
        "theta": "\u03B8",
        "Theta": "\u0398",
        "thetasym": "\u03D1",
        "thetav": "\u03D1",
        "thickapprox": "\u2248",
        "thicksim": "\u223C",
        "ThickSpace": "\u205F\u200A",
        "thinsp": "\u2009",
        "ThinSpace": "\u2009",
        "thkap": "\u2248",
        "thksim": "\u223C",
        "thorn": "\xFE",
        "THORN": "\xDE",
        "tilde": "\u02DC",
        "Tilde": "\u223C",
        "TildeEqual": "\u2243",
        "TildeFullEqual": "\u2245",
        "TildeTilde": "\u2248",
        "times": "\xD7",
        "timesb": "\u22A0",
        "timesbar": "\u2A31",
        "timesd": "\u2A30",
        "tint": "\u222D",
        "toea": "\u2928",
        "top": "\u22A4",
        "topbot": "\u2336",
        "topcir": "\u2AF1",
        "topf": "\u{1D565}",
        "Topf": "\u{1D54B}",
        "topfork": "\u2ADA",
        "tosa": "\u2929",
        "tprime": "\u2034",
        "trade": "\u2122",
        "TRADE": "\u2122",
        "triangle": "\u25B5",
        "triangledown": "\u25BF",
        "triangleleft": "\u25C3",
        "trianglelefteq": "\u22B4",
        "triangleq": "\u225C",
        "triangleright": "\u25B9",
        "trianglerighteq": "\u22B5",
        "tridot": "\u25EC",
        "trie": "\u225C",
        "triminus": "\u2A3A",
        "TripleDot": "\u20DB",
        "triplus": "\u2A39",
        "trisb": "\u29CD",
        "tritime": "\u2A3B",
        "trpezium": "\u23E2",
        "tscr": "\u{1D4C9}",
        "Tscr": "\u{1D4AF}",
        "tscy": "\u0446",
        "TScy": "\u0426",
        "tshcy": "\u045B",
        "TSHcy": "\u040B",
        "tstrok": "\u0167",
        "Tstrok": "\u0166",
        "twixt": "\u226C",
        "twoheadleftarrow": "\u219E",
        "twoheadrightarrow": "\u21A0",
        "uacute": "\xFA",
        "Uacute": "\xDA",
        "uarr": "\u2191",
        "uArr": "\u21D1",
        "Uarr": "\u219F",
        "Uarrocir": "\u2949",
        "ubrcy": "\u045E",
        "Ubrcy": "\u040E",
        "ubreve": "\u016D",
        "Ubreve": "\u016C",
        "ucirc": "\xFB",
        "Ucirc": "\xDB",
        "ucy": "\u0443",
        "Ucy": "\u0423",
        "udarr": "\u21C5",
        "udblac": "\u0171",
        "Udblac": "\u0170",
        "udhar": "\u296E",
        "ufisht": "\u297E",
        "ufr": "\u{1D532}",
        "Ufr": "\u{1D518}",
        "ugrave": "\xF9",
        "Ugrave": "\xD9",
        "uHar": "\u2963",
        "uharl": "\u21BF",
        "uharr": "\u21BE",
        "uhblk": "\u2580",
        "ulcorn": "\u231C",
        "ulcorner": "\u231C",
        "ulcrop": "\u230F",
        "ultri": "\u25F8",
        "umacr": "\u016B",
        "Umacr": "\u016A",
        "uml": "\xA8",
        "UnderBar": "_",
        "UnderBrace": "\u23DF",
        "UnderBracket": "\u23B5",
        "UnderParenthesis": "\u23DD",
        "Union": "\u22C3",
        "UnionPlus": "\u228E",
        "uogon": "\u0173",
        "Uogon": "\u0172",
        "uopf": "\u{1D566}",
        "Uopf": "\u{1D54C}",
        "uparrow": "\u2191",
        "Uparrow": "\u21D1",
        "UpArrow": "\u2191",
        "UpArrowBar": "\u2912",
        "UpArrowDownArrow": "\u21C5",
        "updownarrow": "\u2195",
        "Updownarrow": "\u21D5",
        "UpDownArrow": "\u2195",
        "UpEquilibrium": "\u296E",
        "upharpoonleft": "\u21BF",
        "upharpoonright": "\u21BE",
        "uplus": "\u228E",
        "UpperLeftArrow": "\u2196",
        "UpperRightArrow": "\u2197",
        "upsi": "\u03C5",
        "Upsi": "\u03D2",
        "upsih": "\u03D2",
        "upsilon": "\u03C5",
        "Upsilon": "\u03A5",
        "UpTee": "\u22A5",
        "UpTeeArrow": "\u21A5",
        "upuparrows": "\u21C8",
        "urcorn": "\u231D",
        "urcorner": "\u231D",
        "urcrop": "\u230E",
        "uring": "\u016F",
        "Uring": "\u016E",
        "urtri": "\u25F9",
        "uscr": "\u{1D4CA}",
        "Uscr": "\u{1D4B0}",
        "utdot": "\u22F0",
        "utilde": "\u0169",
        "Utilde": "\u0168",
        "utri": "\u25B5",
        "utrif": "\u25B4",
        "uuarr": "\u21C8",
        "uuml": "\xFC",
        "Uuml": "\xDC",
        "uwangle": "\u29A7",
        "vangrt": "\u299C",
        "varepsilon": "\u03F5",
        "varkappa": "\u03F0",
        "varnothing": "\u2205",
        "varphi": "\u03D5",
        "varpi": "\u03D6",
        "varpropto": "\u221D",
        "varr": "\u2195",
        "vArr": "\u21D5",
        "varrho": "\u03F1",
        "varsigma": "\u03C2",
        "varsubsetneq": "\u228A\uFE00",
        "varsubsetneqq": "\u2ACB\uFE00",
        "varsupsetneq": "\u228B\uFE00",
        "varsupsetneqq": "\u2ACC\uFE00",
        "vartheta": "\u03D1",
        "vartriangleleft": "\u22B2",
        "vartriangleright": "\u22B3",
        "vBar": "\u2AE8",
        "Vbar": "\u2AEB",
        "vBarv": "\u2AE9",
        "vcy": "\u0432",
        "Vcy": "\u0412",
        "vdash": "\u22A2",
        "vDash": "\u22A8",
        "Vdash": "\u22A9",
        "VDash": "\u22AB",
        "Vdashl": "\u2AE6",
        "vee": "\u2228",
        "Vee": "\u22C1",
        "veebar": "\u22BB",
        "veeeq": "\u225A",
        "vellip": "\u22EE",
        "verbar": "|",
        "Verbar": "\u2016",
        "vert": "|",
        "Vert": "\u2016",
        "VerticalBar": "\u2223",
        "VerticalLine": "|",
        "VerticalSeparator": "\u2758",
        "VerticalTilde": "\u2240",
        "VeryThinSpace": "\u200A",
        "vfr": "\u{1D533}",
        "Vfr": "\u{1D519}",
        "vltri": "\u22B2",
        "vnsub": "\u2282\u20D2",
        "vnsup": "\u2283\u20D2",
        "vopf": "\u{1D567}",
        "Vopf": "\u{1D54D}",
        "vprop": "\u221D",
        "vrtri": "\u22B3",
        "vscr": "\u{1D4CB}",
        "Vscr": "\u{1D4B1}",
        "vsubne": "\u228A\uFE00",
        "vsubnE": "\u2ACB\uFE00",
        "vsupne": "\u228B\uFE00",
        "vsupnE": "\u2ACC\uFE00",
        "Vvdash": "\u22AA",
        "vzigzag": "\u299A",
        "wcirc": "\u0175",
        "Wcirc": "\u0174",
        "wedbar": "\u2A5F",
        "wedge": "\u2227",
        "Wedge": "\u22C0",
        "wedgeq": "\u2259",
        "weierp": "\u2118",
        "wfr": "\u{1D534}",
        "Wfr": "\u{1D51A}",
        "wopf": "\u{1D568}",
        "Wopf": "\u{1D54E}",
        "wp": "\u2118",
        "wr": "\u2240",
        "wreath": "\u2240",
        "wscr": "\u{1D4CC}",
        "Wscr": "\u{1D4B2}",
        "xcap": "\u22C2",
        "xcirc": "\u25EF",
        "xcup": "\u22C3",
        "xdtri": "\u25BD",
        "xfr": "\u{1D535}",
        "Xfr": "\u{1D51B}",
        "xharr": "\u27F7",
        "xhArr": "\u27FA",
        "xi": "\u03BE",
        "Xi": "\u039E",
        "xlarr": "\u27F5",
        "xlArr": "\u27F8",
        "xmap": "\u27FC",
        "xnis": "\u22FB",
        "xodot": "\u2A00",
        "xopf": "\u{1D569}",
        "Xopf": "\u{1D54F}",
        "xoplus": "\u2A01",
        "xotime": "\u2A02",
        "xrarr": "\u27F6",
        "xrArr": "\u27F9",
        "xscr": "\u{1D4CD}",
        "Xscr": "\u{1D4B3}",
        "xsqcup": "\u2A06",
        "xuplus": "\u2A04",
        "xutri": "\u25B3",
        "xvee": "\u22C1",
        "xwedge": "\u22C0",
        "yacute": "\xFD",
        "Yacute": "\xDD",
        "yacy": "\u044F",
        "YAcy": "\u042F",
        "ycirc": "\u0177",
        "Ycirc": "\u0176",
        "ycy": "\u044B",
        "Ycy": "\u042B",
        "yen": "\xA5",
        "yfr": "\u{1D536}",
        "Yfr": "\u{1D51C}",
        "yicy": "\u0457",
        "YIcy": "\u0407",
        "yopf": "\u{1D56A}",
        "Yopf": "\u{1D550}",
        "yscr": "\u{1D4CE}",
        "Yscr": "\u{1D4B4}",
        "yucy": "\u044E",
        "YUcy": "\u042E",
        "yuml": "\xFF",
        "Yuml": "\u0178",
        "zacute": "\u017A",
        "Zacute": "\u0179",
        "zcaron": "\u017E",
        "Zcaron": "\u017D",
        "zcy": "\u0437",
        "Zcy": "\u0417",
        "zdot": "\u017C",
        "Zdot": "\u017B",
        "zeetrf": "\u2128",
        "ZeroWidthSpace": "\u200B",
        "zeta": "\u03B6",
        "Zeta": "\u0396",
        "zfr": "\u{1D537}",
        "Zfr": "\u2128",
        "zhcy": "\u0436",
        "ZHcy": "\u0416",
        "zigrarr": "\u21DD",
        "zopf": "\u{1D56B}",
        "Zopf": "\u2124",
        "zscr": "\u{1D4CF}",
        "Zscr": "\u{1D4B5}",
        "zwj": "\u200D",
        "zwnj": "\u200C"
      };
      var decodeMapLegacy = {
        "aacute": "\xE1",
        "Aacute": "\xC1",
        "acirc": "\xE2",
        "Acirc": "\xC2",
        "acute": "\xB4",
        "aelig": "\xE6",
        "AElig": "\xC6",
        "agrave": "\xE0",
        "Agrave": "\xC0",
        "amp": "&",
        "AMP": "&",
        "aring": "\xE5",
        "Aring": "\xC5",
        "atilde": "\xE3",
        "Atilde": "\xC3",
        "auml": "\xE4",
        "Auml": "\xC4",
        "brvbar": "\xA6",
        "ccedil": "\xE7",
        "Ccedil": "\xC7",
        "cedil": "\xB8",
        "cent": "\xA2",
        "copy": "\xA9",
        "COPY": "\xA9",
        "curren": "\xA4",
        "deg": "\xB0",
        "divide": "\xF7",
        "eacute": "\xE9",
        "Eacute": "\xC9",
        "ecirc": "\xEA",
        "Ecirc": "\xCA",
        "egrave": "\xE8",
        "Egrave": "\xC8",
        "eth": "\xF0",
        "ETH": "\xD0",
        "euml": "\xEB",
        "Euml": "\xCB",
        "frac12": "\xBD",
        "frac14": "\xBC",
        "frac34": "\xBE",
        "gt": ">",
        "GT": ">",
        "iacute": "\xED",
        "Iacute": "\xCD",
        "icirc": "\xEE",
        "Icirc": "\xCE",
        "iexcl": "\xA1",
        "igrave": "\xEC",
        "Igrave": "\xCC",
        "iquest": "\xBF",
        "iuml": "\xEF",
        "Iuml": "\xCF",
        "laquo": "\xAB",
        "lt": "<",
        "LT": "<",
        "macr": "\xAF",
        "micro": "\xB5",
        "middot": "\xB7",
        "nbsp": "\xA0",
        "not": "\xAC",
        "ntilde": "\xF1",
        "Ntilde": "\xD1",
        "oacute": "\xF3",
        "Oacute": "\xD3",
        "ocirc": "\xF4",
        "Ocirc": "\xD4",
        "ograve": "\xF2",
        "Ograve": "\xD2",
        "ordf": "\xAA",
        "ordm": "\xBA",
        "oslash": "\xF8",
        "Oslash": "\xD8",
        "otilde": "\xF5",
        "Otilde": "\xD5",
        "ouml": "\xF6",
        "Ouml": "\xD6",
        "para": "\xB6",
        "plusmn": "\xB1",
        "pound": "\xA3",
        "quot": '"',
        "QUOT": '"',
        "raquo": "\xBB",
        "reg": "\xAE",
        "REG": "\xAE",
        "sect": "\xA7",
        "shy": "\xAD",
        "sup1": "\xB9",
        "sup2": "\xB2",
        "sup3": "\xB3",
        "szlig": "\xDF",
        "thorn": "\xFE",
        "THORN": "\xDE",
        "times": "\xD7",
        "uacute": "\xFA",
        "Uacute": "\xDA",
        "ucirc": "\xFB",
        "Ucirc": "\xDB",
        "ugrave": "\xF9",
        "Ugrave": "\xD9",
        "uml": "\xA8",
        "uuml": "\xFC",
        "Uuml": "\xDC",
        "yacute": "\xFD",
        "Yacute": "\xDD",
        "yen": "\xA5",
        "yuml": "\xFF"
      };
      var decodeMapNumeric = {
        "0": "\uFFFD",
        "128": "\u20AC",
        "130": "\u201A",
        "131": "\u0192",
        "132": "\u201E",
        "133": "\u2026",
        "134": "\u2020",
        "135": "\u2021",
        "136": "\u02C6",
        "137": "\u2030",
        "138": "\u0160",
        "139": "\u2039",
        "140": "\u0152",
        "142": "\u017D",
        "145": "\u2018",
        "146": "\u2019",
        "147": "\u201C",
        "148": "\u201D",
        "149": "\u2022",
        "150": "\u2013",
        "151": "\u2014",
        "152": "\u02DC",
        "153": "\u2122",
        "154": "\u0161",
        "155": "\u203A",
        "156": "\u0153",
        "158": "\u017E",
        "159": "\u0178"
      };
      var invalidReferenceCodePoints = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        64976,
        64977,
        64978,
        64979,
        64980,
        64981,
        64982,
        64983,
        64984,
        64985,
        64986,
        64987,
        64988,
        64989,
        64990,
        64991,
        64992,
        64993,
        64994,
        64995,
        64996,
        64997,
        64998,
        64999,
        65e3,
        65001,
        65002,
        65003,
        65004,
        65005,
        65006,
        65007,
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
      ];
      var stringFromCharCode = String.fromCharCode;
      var object1 = {};
      var hasOwnProperty = object1.hasOwnProperty;
      var has2 = /* @__PURE__ */ __name(function(object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
      }, "has");
      var contains = /* @__PURE__ */ __name(function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) return true;
        }
        return false;
      }, "contains");
      var merge = /* @__PURE__ */ __name(function(options, defaults) {
        if (!options) return defaults;
        var result = {};
        var key;
        for (key in defaults)
          result[key] = has2(options, key) ? options[key] : defaults[key];
        return result;
      }, "merge");
      var codePointToSymbol = /* @__PURE__ */ __name(function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) parseError("character reference outside the permissible Unicode range");
          return "\uFFFD";
        }
        if (has2(decodeMapNumeric, codePoint)) {
          if (strict) parseError("disallowed character reference");
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) parseError("disallowed character reference");
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      }, "codePointToSymbol");
      var hexEscape = /* @__PURE__ */ __name(function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      }, "hexEscape");
      var decEscape = /* @__PURE__ */ __name(function(codePoint) {
        return "&#" + codePoint + ";";
      }, "decEscape");
      var parseError = /* @__PURE__ */ __name(function(message) {
        throw Error("Parse error: " + message);
      }, "parseError");
      var encode2 = /* @__PURE__ */ __name(function(string1, options) {
        options = merge(options, encode2.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string1)) parseError("forbidden code point");
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = /* @__PURE__ */ __name(function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        }, "escapeBmpSymbol");
        if (encodeEverything) {
          string1 = string1.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has2(encodeMap, symbol)) return "&" + encodeMap[symbol] + ";";
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) string1 = string1.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          if (useNamedReferences)
            string1 = string1.replace(regexEncodeNonAscii, function(string) {
              return "&" + encodeMap[string] + ";";
            });
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) string1 = string1.replace(regexEscape, function(string) {
            return "&" + encodeMap[string] + ";";
          });
          string1 = string1.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string1 = string1.replace(regexEncodeNonAscii, function(string) {
            return "&" + encodeMap[string] + ";";
          });
        } else if (!allowUnsafeSymbols)
          string1 = string1.replace(regexEscape, escapeBmpSymbol);
        return string1.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      }, "encode");
      encode2.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode2 = /* @__PURE__ */ __name(function(html, options) {
        options = merge(options, decode2.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) parseError("malformed character reference");
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") parseError("`&` did not start a character reference");
              return $0;
            } else {
              if (strict) parseError("named character reference was not terminated by a semicolon");
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) parseError("character reference was not terminated by a semicolon");
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) parseError("character reference was not terminated by a semicolon");
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) parseError("named character reference was not terminated by a semicolon");
          return $0;
        });
      }, "decode");
      decode2.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = /* @__PURE__ */ __name(function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      }, "escape");
      var he = {
        "version": "1.2.0",
        "encode": encode2,
        "decode": decode2,
        "escape": escape,
        "unescape": decode2
      };
      if (freeExports && !freeExports.nodeType) {
        if (freeModule) freeModule.exports = he;
        else for (var key1 in he) has2(he, key1) && (freeExports[key1] = he[key1]);
      } else root2.he = he;
    })(commonjsGlobal);
  });
  var utils = createCommonjsModule(function(module, exports) {
    const { nanoid } = nonSecure;
    const MOCHA_ID_PROP_NAME = "__mocha_id__";
    exports.inherits = util.inherits;
    exports.escape = function(html) {
      return he1.encode(String(html), {
        useNamedReferences: false
      });
    };
    exports.isString = function(obj) {
      return typeof obj === "string";
    };
    exports.slug = function(str) {
      return str.toLowerCase().replace(/\s+/g, "-").replace(/[^-\w]/g, "").replace(/-{2,}/g, "-");
    };
    exports.clean = function(str) {
      str = str.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, "").replace(/^function(?:\s*|\s+[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\s*\}$|^\([^)]*\)\s*=>\s*(?:\{((?:.|\n)*?)\s*\}|((?:.|\n)*))$/, "$1$2$3");
      var spaces = str.match(/^\n?( *)/)[1].length;
      var tabs = str.match(/^\n?(\t*)/)[1].length;
      var re = new RegExp("^\n?" + (tabs ? "	" : " ") + "{" + (tabs || spaces) + "}", "gm");
      str = str.replace(re, "");
      return str.trim();
    };
    function emptyRepresentation(value, typeHint) {
      switch (typeHint) {
        case "function":
          return "[Function]";
        case "object":
          return "{}";
        case "array":
          return "[]";
        default:
          return value.toString();
      }
    }
    __name(emptyRepresentation, "emptyRepresentation");
    var canonicalType = exports.canonicalType = /* @__PURE__ */ __name(function canonicalType2(value) {
      if (value === void 0) return "undefined";
      else if (value === null) return "null";
      else if (isBuffer$2(value)) return "buffer";
      return Object.prototype.toString.call(value).replace(/^\[.+\s(.+?)]$/, "$1").toLowerCase();
    }, "canonicalType");
    exports.type = /* @__PURE__ */ __name(function type(value) {
      if (value === null) return "null";
      const primitives = /* @__PURE__ */ new Set([
        "undefined",
        "boolean",
        "number",
        "string",
        "bigint",
        "symbol"
      ]);
      const _type = typeof value;
      if (_type === "function") return _type;
      if (primitives.has(_type)) return _type;
      if (value instanceof String) return "string";
      if (value instanceof Error) return "error";
      if (Array.isArray(value)) return "array";
      return _type;
    }, "type");
    exports.stringify = function(value) {
      var typeHint = canonicalType(value);
      if (!~[
        "object",
        "array",
        "function"
      ].indexOf(typeHint)) {
        if (typeHint === "buffer") {
          var json = Buffer$1.prototype.toJSON.call(value);
          return jsonStringify(json.data && json.type ? json.data : json, 2).replace(/,(\n|$)/g, "$1");
        }
        if (typeHint === "string" && typeof value === "object") {
          value = value.split("").reduce(function(acc, char, idx) {
            acc[idx] = char;
            return acc;
          }, {});
          typeHint = "object";
        } else return jsonStringify(value);
      }
      for (var prop in value) {
        if (Object.prototype.hasOwnProperty.call(value, prop)) return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(/,(\n|$)/g, "$1");
      }
      return emptyRepresentation(value, typeHint);
    };
    function jsonStringify(object, spaces, depth) {
      if (typeof spaces === "undefined")
        return _stringify(object);
      depth = depth || 1;
      var space = spaces * depth;
      var str = Array.isArray(object) ? "[" : "{";
      var end = Array.isArray(object) ? "]" : "}";
      var length = typeof object.length === "number" ? object.length : Object.keys(object).length;
      function repeat(s2, n2) {
        return new Array(n2).join(s2);
      }
      __name(repeat, "repeat");
      function _stringify(val) {
        switch (canonicalType(val)) {
          case "null":
          case "undefined":
            val = "[" + val + "]";
            break;
          case "array":
          case "object":
            val = jsonStringify(val, spaces, depth + 1);
            break;
          case "boolean":
          case "regexp":
          case "symbol":
          case "number":
            val = val === 0 && 1 / val === -Infinity ? "-0" : val.toString();
            break;
          case "bigint":
            val = val.toString() + "n";
            break;
          case "date":
            var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();
            val = "[Date: " + sDate + "]";
            break;
          case "buffer":
            var json = val.toJSON();
            json = json.data && json.type ? json.data : json;
            val = "[Buffer: " + jsonStringify(json, 2, depth + 1) + "]";
            break;
          default:
            val = val === "[Function]" || val === "[Circular]" ? val : JSON.stringify(val);
        }
        return val;
      }
      __name(_stringify, "_stringify");
      for (var i2 in object) {
        if (!Object.prototype.hasOwnProperty.call(object, i2)) continue;
        --length;
        str += "\n " + repeat(" ", space) + (Array.isArray(object) ? "" : '"' + i2 + '": ') + _stringify(object[i2]) + (length ? "," : "");
      }
      return str + (str.length !== 1 ? "\n" + repeat(" ", --space) + end : end);
    }
    __name(jsonStringify, "jsonStringify");
    exports.canonicalize = /* @__PURE__ */ __name(function canonicalize(value5, stack, typeHint) {
      var canonicalizedObj;
      var prop;
      typeHint = typeHint || canonicalType(value5);
      function withStack(value, fn) {
        stack.push(value);
        fn();
        stack.pop();
      }
      __name(withStack, "withStack");
      stack = stack || [];
      if (stack.indexOf(value5) !== -1) return "[Circular]";
      switch (typeHint) {
        case "undefined":
        case "buffer":
        case "null":
          canonicalizedObj = value5;
          break;
        case "array":
          withStack(value5, function() {
            canonicalizedObj = value5.map(function(item) {
              return exports.canonicalize(item, stack);
            });
          });
          break;
        case "function":
          for (prop in value5) {
            canonicalizedObj = {};
            break;
          }
          if (!canonicalizedObj) {
            canonicalizedObj = emptyRepresentation(value5, typeHint);
            break;
          }
        /* falls through */
        case "object":
          canonicalizedObj = canonicalizedObj || {};
          withStack(value5, function() {
            Object.keys(value5).sort().forEach(function(key) {
              canonicalizedObj[key] = exports.canonicalize(value5[key], stack);
            });
          });
          break;
        case "date":
        case "number":
        case "regexp":
        case "boolean":
        case "symbol":
          canonicalizedObj = value5;
          break;
        default:
          canonicalizedObj = value5 + "";
      }
      return canonicalizedObj;
    }, "canonicalize");
    exports.stackTraceFilter = function() {
      var is = typeof document === "undefined" ? {
        node: true
      } : {
        browser: true
      };
      var slash = path1.sep;
      var cwd;
      if (is.node) cwd = exports.cwd() + slash;
      else {
        cwd = (typeof location === "undefined" ? window.location : location).href.replace(/\/[^/]*$/, "/");
        slash = "/";
      }
      function isMochaInternal(line) {
        return ~line.indexOf("node_modules" + slash + "mocha" + slash) || ~line.indexOf(slash + "mocha.js") || ~line.indexOf(slash + "mocha.min.js");
      }
      __name(isMochaInternal, "isMochaInternal");
      function isNodeInternal(line) {
        return ~line.indexOf("(timers.js:") || ~line.indexOf("(events.js:") || ~line.indexOf("(node.js:") || ~line.indexOf("(module.js:") || ~line.indexOf("GeneratorFunctionPrototype.next (native)") || false;
      }
      __name(isNodeInternal, "isNodeInternal");
      return function(stack) {
        stack = stack.split("\n");
        stack = stack.reduce(function(list, line) {
          if (isMochaInternal(line)) return list;
          if (is.node && isNodeInternal(line)) return list;
          if (/:\d+:\d+\)?$/.test(line)) line = line.replace("(" + cwd, "(");
          list.push(line);
          return list;
        }, []);
        return stack.join("\n");
      };
    };
    exports.isPromise = /* @__PURE__ */ __name(function isPromise(value) {
      return typeof value === "object" && value !== null && typeof value.then === "function";
    }, "isPromise");
    exports.clamp = /* @__PURE__ */ __name(function clamp(value, range) {
      return Math.min(Math.max(value, range[0]), range[1]);
    }, "clamp");
    exports.noop = function() {
    };
    exports.createMap = function(obj) {
      return Object.assign.apply(null, [
        /* @__PURE__ */ Object.create(null)
      ].concat(Array.prototype.slice.call(arguments)));
    };
    exports.defineConstants = function(obj) {
      if (canonicalType(obj) !== "object" || !Object.keys(obj).length) throw new TypeError("Invalid argument; expected a non-empty object");
      return Object.freeze(exports.createMap(obj));
    };
    exports.cwd = /* @__PURE__ */ __name(function cwd() {
      return process$1.cwd();
    }, "cwd");
    exports.isBrowser = /* @__PURE__ */ __name(function isBrowser() {
      return Boolean(browser$2);
    }, "isBrowser");
    exports.castArray = /* @__PURE__ */ __name(function castArray(value) {
      if (value === void 0) return [];
      if (value === null) return [
        null
      ];
      if (typeof value === "object" && (typeof value[Symbol.iterator] === "function" || value.length !== void 0)) return Array.from(value);
      return [
        value
      ];
    }, "castArray");
    exports.constants = exports.defineConstants({
      MOCHA_ID_PROP_NAME
    });
    exports.uniqueID = () => nanoid();
    exports.assignNewMochaID = (obj) => {
      const id = exports.uniqueID();
      Object.defineProperty(obj, MOCHA_ID_PROP_NAME, {
        get() {
          return id;
        }
      });
      return obj;
    };
    exports.getMochaID = (obj) => obj && typeof obj === "object" ? obj[MOCHA_ID_PROP_NAME] : void 0;
  });
  var _nodeResolve_empty = {};
  var _nodeResolve_empty$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    "default": _nodeResolve_empty
  });
  var browser$1 = {
    info: "\u2139\uFE0F",
    success: "\u2705",
    warning: "\u26A0\uFE0F",
    error: "\u274C\uFE0F"
  };
  var pending1 = Pending;
  function Pending(message) {
    this.message = message;
  }
  __name(Pending, "Pending");
  var s1 = 1e3;
  var m1 = s1 * 60;
  var h = m1 * 60;
  var d1 = h * 24;
  var w1 = d1 * 7;
  var y1 = d1 * 365.25;
  var ms1 = /* @__PURE__ */ __name(function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) return parse(val);
    else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  }, "ms1");
  function parse(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y1;
      case "weeks":
      case "week":
      case "w":
        return n2 * w1;
      case "days":
      case "day":
      case "d":
        return n2 * d1;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m1;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s1;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  __name(parse, "parse");
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d1) return Math.round(ms / d1) + "d";
    if (msAbs >= h) return Math.round(ms / h) + "h";
    if (msAbs >= m1) return Math.round(ms / m1) + "m";
    if (msAbs >= s1) return Math.round(ms / s1) + "s";
    return ms + "ms";
  }
  __name(fmtShort, "fmtShort");
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d1) return plural(ms, msAbs, d1, "day");
    if (msAbs >= h) return plural(ms, msAbs, h, "hour");
    if (msAbs >= m1) return plural(ms, msAbs, m1, "minute");
    if (msAbs >= s1) return plural(ms, msAbs, s1, "second");
    return ms + " ms";
  }
  __name(fmtLong, "fmtLong");
  function plural(ms, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
  }
  __name(plural, "plural");
  function setup2(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms1;
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    __name(selectColor, "selectColor");
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) return;
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string")
          args.unshift("%O");
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") return "%";
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      __name(debug, "debug");
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: /* @__PURE__ */ __name(() => {
          if (enableOverride !== null) return enableOverride;
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        }, "get"),
        set: /* @__PURE__ */ __name((v) => {
          enableOverride = v;
        }, "set")
      });
      if (typeof createDebug.init === "function") createDebug.init(debug);
      return debug;
    }
    __name(createDebug, "createDebug");
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    __name(extend, "extend");
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0; i2 < len; i2++) {
        if (!split[i2]) continue;
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        else createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
    __name(enable, "enable");
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map(
          (namespace) => "-" + namespace
        )
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    __name(disable, "disable");
    function enabled(name) {
      if (name[name.length - 1] === "*") return true;
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
        if (createDebug.skips[i2].test(name)) return false;
      }
      for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
        if (createDebug.names[i2].test(name)) return true;
      }
      return false;
    }
    __name(enabled, "enabled");
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    __name(toNamespace, "toNamespace");
    function coerce2(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
    __name(coerce2, "coerce");
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    __name(destroy, "destroy");
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  __name(setup2, "setup");
  var common$11 = setup2;
  var browser = createCommonjsModule(function(module, exports) {
    exports.formatArgs = formatArgs2;
    exports.save = save2;
    exports.load = load2;
    exports.useColors = useColors2;
    exports.storage = localstorage2();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors2() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors2, "useColors");
    function formatArgs2(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) return;
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") return;
        index++;
        if (match === "%c")
          lastC = index;
      });
      args.splice(lastC, 0, c2);
    }
    __name(formatArgs2, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save2(namespaces) {
      try {
        if (namespaces) exports.storage.setItem("debug", namespaces);
        else exports.storage.removeItem("debug");
      } catch (error) {
      }
    }
    __name(save2, "save");
    function load2() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process$1 !== "undefined" && "env" in process$1) r2 = process$1.env.DEBUG;
      return r2;
    }
    __name(load2, "load");
    function localstorage2() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage2, "localstorage");
    module.exports = common$11(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  });
  const { format: format1 } = util;
  const emitWarning = /* @__PURE__ */ __name((msg, type) => {
    if (process$1.emitWarning) process$1.emitWarning(msg, type);
    else nextTick$1(function() {
      console.warn(type + ": " + msg);
    });
  }, "emitWarning");
  const deprecate = /* @__PURE__ */ __name((msg) => {
    msg = String(msg);
    if (msg && !deprecate.cache[msg]) {
      deprecate.cache[msg] = true;
      emitWarning(msg, "DeprecationWarning");
    }
  }, "deprecate");
  deprecate.cache = {};
  const warn1 = /* @__PURE__ */ __name((msg) => {
    if (msg) emitWarning(msg);
  }, "warn1");
  var constants$4 = {
    /**
    * An unrecoverable error.
    * @constant
    * @default
    */
    FATAL: "ERR_MOCHA_FATAL",
    /**
    * The type of an argument to a function call is invalid
    * @constant
    * @default
    */
    INVALID_ARG_TYPE: "ERR_MOCHA_INVALID_ARG_TYPE",
    /**
    * The value of an argument to a function call is invalid
    * @constant
    * @default
    */
    INVALID_ARG_VALUE: "ERR_MOCHA_INVALID_ARG_VALUE",
    /**
    * Something was thrown, but it wasn't an `Error`
    * @constant
    * @default
    */
    INVALID_EXCEPTION: "ERR_MOCHA_INVALID_EXCEPTION",
    /**
    * An interface (e.g., `Mocha.interfaces`) is unknown or invalid
    * @constant
    * @default
    */
    INVALID_INTERFACE: "ERR_MOCHA_INVALID_INTERFACE",
    /**
    * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid
    * @constant
    * @default
    */
    INVALID_REPORTER: "ERR_MOCHA_INVALID_REPORTER",
    /**
    * `done()` was called twice in a `Test` or `Hook` callback
    * @constant
    * @default
    */
    MULTIPLE_DONE: "ERR_MOCHA_MULTIPLE_DONE",
    /**
    * No files matched the pattern provided by the user
    * @constant
    * @default
    */
    NO_FILES_MATCH_PATTERN: "ERR_MOCHA_NO_FILES_MATCH_PATTERN",
    /**
    * Known, but unsupported behavior of some kind
    * @constant
    * @default
    */
    UNSUPPORTED: "ERR_MOCHA_UNSUPPORTED",
    /**
    * Invalid state transition occurring in `Mocha` instance
    * @constant
    * @default
    */
    INSTANCE_ALREADY_RUNNING: "ERR_MOCHA_INSTANCE_ALREADY_RUNNING",
    /**
    * Invalid state transition occurring in `Mocha` instance
    * @constant
    * @default
    */
    INSTANCE_ALREADY_DISPOSED: "ERR_MOCHA_INSTANCE_ALREADY_DISPOSED",
    /**
    * Use of `only()` w/ `--forbid-only` results in this error.
    * @constant
    * @default
    */
    FORBIDDEN_EXCLUSIVITY: "ERR_MOCHA_FORBIDDEN_EXCLUSIVITY",
    /**
    * To be thrown when a user-defined plugin implementation (e.g., `mochaHooks`) is invalid
    * @constant
    * @default
    */
    INVALID_PLUGIN_IMPLEMENTATION: "ERR_MOCHA_INVALID_PLUGIN_IMPLEMENTATION",
    /**
    * To be thrown when a builtin or third-party plugin definition (the _definition_ of `mochaHooks`) is invalid
    * @constant
    * @default
    */
    INVALID_PLUGIN_DEFINITION: "ERR_MOCHA_INVALID_PLUGIN_DEFINITION",
    /**
    * When a runnable exceeds its allowed run time.
    * @constant
    * @default
    */
    TIMEOUT: "ERR_MOCHA_TIMEOUT",
    /**
    * Input file is not able to be parsed
    * @constant
    * @default
    */
    UNPARSABLE_FILE: "ERR_MOCHA_UNPARSABLE_FILE"
  };
  const MOCHA_ERRORS = new Set(Object.values(constants$4));
  function createNoFilesMatchPatternError(message, pattern) {
    var err = new Error(message);
    err.code = constants$4.NO_FILES_MATCH_PATTERN;
    err.pattern = pattern;
    return err;
  }
  __name(createNoFilesMatchPatternError, "createNoFilesMatchPatternError");
  function createInvalidReporterError1(message, reporter) {
    var err = new TypeError(message);
    err.code = constants$4.INVALID_REPORTER;
    err.reporter = reporter;
    return err;
  }
  __name(createInvalidReporterError1, "createInvalidReporterError1");
  function createInvalidInterfaceError1(message, ui) {
    var err = new Error(message);
    err.code = constants$4.INVALID_INTERFACE;
    err.interface = ui;
    return err;
  }
  __name(createInvalidInterfaceError1, "createInvalidInterfaceError1");
  function createUnsupportedError$2(message) {
    var err = new Error(message);
    err.code = constants$4.UNSUPPORTED;
    return err;
  }
  __name(createUnsupportedError$2, "createUnsupportedError$2");
  function createMissingArgumentError$1(message, argument, expected) {
    return createInvalidArgumentTypeError$1(message, argument, expected);
  }
  __name(createMissingArgumentError$1, "createMissingArgumentError$1");
  function createInvalidArgumentTypeError$1(message, argument, expected) {
    var err = new TypeError(message);
    err.code = constants$4.INVALID_ARG_TYPE;
    err.argument = argument;
    err.expected = expected;
    err.actual = typeof argument;
    return err;
  }
  __name(createInvalidArgumentTypeError$1, "createInvalidArgumentTypeError$1");
  function createInvalidArgumentValueError(message, argument, value, reason) {
    var err = new TypeError(message);
    err.code = constants$4.INVALID_ARG_VALUE;
    err.argument = argument;
    err.value = value;
    err.reason = typeof reason !== "undefined" ? reason : "is invalid";
    return err;
  }
  __name(createInvalidArgumentValueError, "createInvalidArgumentValueError");
  function createInvalidExceptionError$2(message, value) {
    var err = new Error(message);
    err.code = constants$4.INVALID_EXCEPTION;
    err.valueType = typeof value;
    err.value = value;
    return err;
  }
  __name(createInvalidExceptionError$2, "createInvalidExceptionError$2");
  function createFatalError$1(message, value) {
    var err = new Error(message);
    err.code = constants$4.FATAL;
    err.valueType = typeof value;
    err.value = value;
    return err;
  }
  __name(createFatalError$1, "createFatalError$1");
  function createInvalidLegacyPluginError(message, pluginType, pluginId) {
    switch (pluginType) {
      case "reporter":
        return createInvalidReporterError1(message, pluginId);
      case "ui":
        return createInvalidInterfaceError1(message, pluginId);
      default:
        throw new Error('unknown pluginType "' + pluginType + '"');
    }
  }
  __name(createInvalidLegacyPluginError, "createInvalidLegacyPluginError");
  function createInvalidPluginError(...args) {
    deprecate("Use createInvalidLegacyPluginError() instead");
    return createInvalidLegacyPluginError(...args);
  }
  __name(createInvalidPluginError, "createInvalidPluginError");
  function createMochaInstanceAlreadyDisposedError1(message, cleanReferencesAfterRun, instance) {
    var err = new Error(message);
    err.code = constants$4.INSTANCE_ALREADY_DISPOSED;
    err.cleanReferencesAfterRun = cleanReferencesAfterRun;
    err.instance = instance;
    return err;
  }
  __name(createMochaInstanceAlreadyDisposedError1, "createMochaInstanceAlreadyDisposedError1");
  function createMochaInstanceAlreadyRunningError1(message, instance) {
    var err = new Error(message);
    err.code = constants$4.INSTANCE_ALREADY_RUNNING;
    err.instance = instance;
    return err;
  }
  __name(createMochaInstanceAlreadyRunningError1, "createMochaInstanceAlreadyRunningError1");
  function createMultipleDoneError$1(runnable, originalErr) {
    var title;
    try {
      title = format1("<%s>", runnable.fullTitle());
      if (runnable.parent.root) title += " (of root suite)";
    } catch (ignored) {
      title = format1("<%s> (of unknown suite)", runnable.title);
    }
    var message = format1("done() called multiple times in %s %s", runnable.type ? runnable.type : "unknown runnable", title);
    if (runnable.file) message += format1(" of file %s", runnable.file);
    if (originalErr) message += format1("; in addition, done() received error: %s", originalErr);
    var err = new Error(message);
    err.code = constants$4.MULTIPLE_DONE;
    err.valueType = typeof originalErr;
    err.value = originalErr;
    return err;
  }
  __name(createMultipleDoneError$1, "createMultipleDoneError$1");
  function createForbiddenExclusivityError$1(mocha) {
    var err = new Error(mocha.isWorker ? "`.only` is not supported in parallel mode" : "`.only` forbidden by --forbid-only");
    err.code = constants$4.FORBIDDEN_EXCLUSIVITY;
    return err;
  }
  __name(createForbiddenExclusivityError$1, "createForbiddenExclusivityError$1");
  function createInvalidPluginDefinitionError(msg, pluginDef) {
    const err = new Error(msg);
    err.code = constants$4.INVALID_PLUGIN_DEFINITION;
    err.pluginDef = pluginDef;
    return err;
  }
  __name(createInvalidPluginDefinitionError, "createInvalidPluginDefinitionError");
  function createInvalidPluginImplementationError(msg, { pluginDef, pluginImpl } = {}) {
    const err = new Error(msg);
    err.code = constants$4.INVALID_PLUGIN_IMPLEMENTATION;
    err.pluginDef = pluginDef;
    err.pluginImpl = pluginImpl;
    return err;
  }
  __name(createInvalidPluginImplementationError, "createInvalidPluginImplementationError");
  function createTimeoutError$1(msg, timeout, file) {
    const err = new Error(msg);
    err.code = constants$4.TIMEOUT;
    err.timeout = timeout;
    err.file = file;
    return err;
  }
  __name(createTimeoutError$1, "createTimeoutError$1");
  function createUnparsableFileError(message, filename) {
    var err = new Error(message);
    err.code = constants$4.UNPARSABLE_FILE;
    return err;
  }
  __name(createUnparsableFileError, "createUnparsableFileError");
  const isMochaError$1 = /* @__PURE__ */ __name((err) => Boolean(err && typeof err === "object" && MOCHA_ERRORS.has(err.code)), "isMochaError$1");
  var errors = {
    constants: constants$4,
    createFatalError: createFatalError$1,
    createForbiddenExclusivityError: createForbiddenExclusivityError$1,
    createInvalidArgumentTypeError: createInvalidArgumentTypeError$1,
    createInvalidArgumentValueError,
    createInvalidExceptionError: createInvalidExceptionError$2,
    createInvalidInterfaceError: createInvalidInterfaceError1,
    createInvalidLegacyPluginError,
    createInvalidPluginDefinitionError,
    createInvalidPluginError,
    createInvalidPluginImplementationError,
    createInvalidReporterError: createInvalidReporterError1,
    createMissingArgumentError: createMissingArgumentError$1,
    createMochaInstanceAlreadyDisposedError: createMochaInstanceAlreadyDisposedError1,
    createMochaInstanceAlreadyRunningError: createMochaInstanceAlreadyRunningError1,
    createMultipleDoneError: createMultipleDoneError$1,
    createNoFilesMatchPatternError,
    createTimeoutError: createTimeoutError$1,
    createUnparsableFileError,
    createUnsupportedError: createUnsupportedError$2,
    deprecate,
    isMochaError: isMochaError$1,
    warn: warn1
  };
  var EventEmitter$1 = EventEmitter$2.EventEmitter;
  var debug$1 = browser("mocha:runnable");
  const { createInvalidExceptionError: createInvalidExceptionError$1, createMultipleDoneError, createTimeoutError } = errors;
  var Date$4 = commonjsGlobal.Date;
  var setTimeout$3 = commonjsGlobal.setTimeout;
  var clearTimeout$1 = commonjsGlobal.clearTimeout;
  var toString2 = Object.prototype.toString;
  var runnable1 = Runnable;
  function Runnable(title, fn) {
    this.title = title;
    this.fn = fn;
    this.body = (fn || "").toString();
    this.async = fn && fn.length;
    this.sync = !this.async;
    this._timeout = 2e3;
    this._slow = 75;
    this._retries = -1;
    utils.assignNewMochaID(this);
    Object.defineProperty(this, "id", {
      get() {
        return utils.getMochaID(this);
      }
    });
    this.reset();
  }
  __name(Runnable, "Runnable");
  utils.inherits(Runnable, EventEmitter$1);
  Runnable.prototype.reset = function() {
    this.timedOut = false;
    this._currentRetry = 0;
    this.pending = false;
    delete this.state;
    delete this.err;
  };
  Runnable.prototype.timeout = function(ms) {
    if (!arguments.length) return this._timeout;
    if (typeof ms === "string") ms = ms$1(ms);
    var INT_MAX = Math.pow(2, 31) - 1;
    var range = [
      0,
      INT_MAX
    ];
    ms = utils.clamp(ms, range);
    if (ms === range[0] || ms === range[1]) this._timeout = 0;
    else this._timeout = ms;
    debug$1("timeout %d", this._timeout);
    if (this.timer) this.resetTimeout();
    return this;
  };
  Runnable.prototype.slow = function(ms) {
    if (!arguments.length || typeof ms === "undefined") return this._slow;
    if (typeof ms === "string") ms = ms$1(ms);
    debug$1("slow %d", ms);
    this._slow = ms;
    return this;
  };
  Runnable.prototype.skip = function() {
    this.pending = true;
    throw new pending1("sync skip; aborting execution");
  };
  Runnable.prototype.isPending = function() {
    return this.pending || this.parent && this.parent.isPending();
  };
  Runnable.prototype.isFailed = function() {
    return !this.isPending() && this.state === constants$3.STATE_FAILED;
  };
  Runnable.prototype.isPassed = function() {
    return !this.isPending() && this.state === constants$3.STATE_PASSED;
  };
  Runnable.prototype.retries = function(n2) {
    if (!arguments.length) return this._retries;
    this._retries = n2;
  };
  Runnable.prototype.currentRetry = function(n2) {
    if (!arguments.length) return this._currentRetry;
    this._currentRetry = n2;
  };
  Runnable.prototype.fullTitle = function() {
    return this.titlePath().join(" ");
  };
  Runnable.prototype.titlePath = function() {
    return this.parent.titlePath().concat([
      this.title
    ]);
  };
  Runnable.prototype.clearTimeout = function() {
    clearTimeout$1(this.timer);
  };
  Runnable.prototype.resetTimeout = function() {
    var self2 = this;
    var ms = this.timeout();
    if (ms === 0) return;
    this.clearTimeout();
    this.timer = setTimeout$3(function() {
      if (self2.timeout() === 0) return;
      self2.callback(self2._timeoutError(ms));
      self2.timedOut = true;
    }, ms);
  };
  Runnable.prototype.globals = function(globals) {
    if (!arguments.length) return this._allowedGlobals;
    this._allowedGlobals = globals;
  };
  Runnable.prototype.run = function(fn1) {
    var self2 = this;
    var start = new Date$4();
    var ctx = this.ctx;
    var finished;
    var errorWasHandled = false;
    if (this.isPending()) return fn1();
    if (ctx && ctx.runnable) ctx.runnable(this);
    function multiple(err) {
      if (errorWasHandled) return;
      errorWasHandled = true;
      self2.emit("error", createMultipleDoneError(self2, err));
    }
    __name(multiple, "multiple");
    function done(err) {
      var ms = self2.timeout();
      if (self2.timedOut) return;
      if (finished) return multiple(err);
      self2.clearTimeout();
      self2.duration = new Date$4() - start;
      finished = true;
      if (!err && self2.duration > ms && ms > 0) err = self2._timeoutError(ms);
      fn1(err);
    }
    __name(done, "done");
    this.callback = done;
    if (this.fn && typeof this.fn.call !== "function") {
      done(new TypeError("A runnable must be passed a function as its second argument."));
      return;
    }
    if (this.async) {
      this.resetTimeout();
      this.skip = /* @__PURE__ */ __name(function asyncSkip() {
        this.pending = true;
        done();
        throw new pending1("async skip; aborting execution");
      }, "asyncSkip");
      try {
        callFnAsync(this.fn);
      } catch (err) {
        errorWasHandled = true;
        if (err instanceof pending1) return;
        else if (this.allowUncaught) throw err;
        done(Runnable.toValueOrError(err));
      }
      return;
    }
    try {
      callFn(this.fn);
    } catch (err2) {
      errorWasHandled = true;
      if (err2 instanceof pending1) return done();
      else if (this.allowUncaught) throw err2;
      done(Runnable.toValueOrError(err2));
    }
    function callFn(fn) {
      var result = fn.call(ctx);
      if (result && typeof result.then === "function") {
        self2.resetTimeout();
        result.then(function() {
          done();
          return null;
        }, function(reason) {
          done(reason || new Error("Promise rejected with no or falsy reason"));
        });
      } else {
        if (self2.asyncOnly) return done(new Error("--async-only option in use without declaring `done()` or returning a promise"));
        done();
      }
    }
    __name(callFn, "callFn");
    function callFnAsync(fn) {
      var result = fn.call(ctx, function(err) {
        if (err instanceof Error || toString2.call(err) === "[object Error]") return done(err);
        if (err) {
          if (Object.prototype.toString.call(err) === "[object Object]") return done(new Error("done() invoked with non-Error: " + JSON.stringify(err)));
          return done(new Error("done() invoked with non-Error: " + err));
        }
        if (result && utils.isPromise(result)) return done(new Error("Resolution method is overspecified. Specify a callback *or* return a Promise; not both."));
        done();
      });
    }
    __name(callFnAsync, "callFnAsync");
  };
  Runnable.prototype._timeoutError = function(ms) {
    let msg = `Timeout of ${ms}ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.`;
    if (this.file) msg += " (" + this.file + ")";
    return createTimeoutError(msg, ms, this.file);
  };
  var constants$3 = utils.defineConstants(
    /**
    * {@link Runnable}-related constants.
    * @public
    * @memberof Runnable
    * @readonly
    * @static
    * @alias constants
    * @enum {string}
    */
    {
      /**
      * Value of `state` prop when a `Runnable` has failed
      */
      STATE_FAILED: "failed",
      /**
      * Value of `state` prop when a `Runnable` has passed
      */
      STATE_PASSED: "passed",
      /**
      * Value of `state` prop when a `Runnable` has been skipped by user
      */
      STATE_PENDING: "pending"
    }
  );
  Runnable.toValueOrError = function(value) {
    return value || createInvalidExceptionError$1("Runnable failed with falsy or undefined exception. Please throw an Error instead.", value);
  };
  Runnable.constants = constants$3;
  const { inherits: inherits1, constants: constants$2 } = utils;
  const { MOCHA_ID_PROP_NAME: MOCHA_ID_PROP_NAME$1 } = constants$2;
  var hook1 = Hook;
  function Hook(title, fn) {
    runnable1.call(this, title, fn);
    this.type = "hook";
  }
  __name(Hook, "Hook");
  inherits1(Hook, runnable1);
  Hook.prototype.reset = function() {
    runnable1.prototype.reset.call(this);
    delete this._error;
  };
  Hook.prototype.error = function(err) {
    if (!arguments.length) {
      err = this._error;
      this._error = null;
      return err;
    }
    this._error = err;
  };
  Hook.prototype.serialize = /* @__PURE__ */ __name(function serialize() {
    return {
      $$currentRetry: this.currentRetry(),
      $$fullTitle: this.fullTitle(),
      $$isPending: Boolean(this.isPending()),
      $$titlePath: this.titlePath(),
      ctx: this.ctx && this.ctx.currentTest ? {
        currentTest: {
          title: this.ctx.currentTest.title,
          [MOCHA_ID_PROP_NAME$1]: this.ctx.currentTest.id
        }
      } : {},
      duration: this.duration,
      file: this.file,
      parent: {
        $$fullTitle: this.parent.fullTitle(),
        [MOCHA_ID_PROP_NAME$1]: this.parent.id
      },
      state: this.state,
      title: this.title,
      type: this.type,
      [MOCHA_ID_PROP_NAME$1]: this.id
    };
  }, "serialize");
  var suite1 = createCommonjsModule(function(module, exports) {
    const { EventEmitter } = EventEmitter$2;
    var { assignNewMochaID, clamp, constants: utilsConstants, defineConstants, getMochaID, inherits, isString } = utils;
    const debug = browser("mocha:suite");
    const { MOCHA_ID_PROP_NAME } = utilsConstants;
    module.exports = Suite;
    Suite.create = function(parent, title) {
      var suite = new Suite(title, parent.ctx);
      suite.parent = parent;
      title = suite.fullTitle();
      parent.addSuite(suite);
      return suite;
    };
    function Suite(title, parentContext, isRoot) {
      if (!isString(title)) throw errors.createInvalidArgumentTypeError('Suite argument "title" must be a string. Received type "' + typeof title + '"', "title", "string");
      this.title = title;
      function Context() {
      }
      __name(Context, "Context");
      Context.prototype = parentContext;
      this.ctx = new Context();
      this.suites = [];
      this.tests = [];
      this.root = isRoot === true;
      this.pending = false;
      this._retries = -1;
      this._beforeEach = [];
      this._beforeAll = [];
      this._afterEach = [];
      this._afterAll = [];
      this._timeout = 2e3;
      this._slow = 75;
      this._bail = false;
      this._onlyTests = [];
      this._onlySuites = [];
      assignNewMochaID(this);
      Object.defineProperty(this, "id", {
        get() {
          return getMochaID(this);
        }
      });
      this.reset();
    }
    __name(Suite, "Suite");
    inherits(Suite, EventEmitter);
    Suite.prototype.reset = function() {
      this.delayed = false;
      function doReset(thingToReset) {
        thingToReset.reset();
      }
      __name(doReset, "doReset");
      this.suites.forEach(doReset);
      this.tests.forEach(doReset);
      this._beforeEach.forEach(doReset);
      this._afterEach.forEach(doReset);
      this._beforeAll.forEach(doReset);
      this._afterAll.forEach(doReset);
    };
    Suite.prototype.clone = function() {
      var suite = new Suite(this.title);
      debug("clone");
      suite.ctx = this.ctx;
      suite.root = this.root;
      suite.timeout(this.timeout());
      suite.retries(this.retries());
      suite.slow(this.slow());
      suite.bail(this.bail());
      return suite;
    };
    Suite.prototype.timeout = function(ms) {
      if (!arguments.length) return this._timeout;
      if (typeof ms === "string") ms = ms$1(ms);
      var INT_MAX = Math.pow(2, 31) - 1;
      var range = [
        0,
        INT_MAX
      ];
      ms = clamp(ms, range);
      debug("timeout %d", ms);
      this._timeout = parseInt(ms, 10);
      return this;
    };
    Suite.prototype.retries = function(n2) {
      if (!arguments.length) return this._retries;
      debug("retries %d", n2);
      this._retries = parseInt(n2, 10) || 0;
      return this;
    };
    Suite.prototype.slow = function(ms) {
      if (!arguments.length) return this._slow;
      if (typeof ms === "string") ms = ms$1(ms);
      debug("slow %d", ms);
      this._slow = ms;
      return this;
    };
    Suite.prototype.bail = function(bail) {
      if (!arguments.length) return this._bail;
      debug("bail %s", bail);
      this._bail = bail;
      return this;
    };
    Suite.prototype.isPending = function() {
      return this.pending || this.parent && this.parent.isPending();
    };
    Suite.prototype._createHook = function(title, fn) {
      var hook$1 = new hook1(title, fn);
      hook$1.parent = this;
      hook$1.timeout(this.timeout());
      hook$1.retries(this.retries());
      hook$1.slow(this.slow());
      hook$1.ctx = this.ctx;
      hook$1.file = this.file;
      return hook$1;
    };
    Suite.prototype.beforeAll = function(title, fn) {
      if (this.isPending()) return this;
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"before all" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._beforeAll.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook);
      return this;
    };
    Suite.prototype.afterAll = function(title, fn) {
      if (this.isPending()) return this;
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"after all" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._afterAll.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook);
      return this;
    };
    Suite.prototype.beforeEach = function(title, fn) {
      if (this.isPending()) return this;
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"before each" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._beforeEach.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook);
      return this;
    };
    Suite.prototype.afterEach = function(title, fn) {
      if (this.isPending()) return this;
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"after each" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._afterEach.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook);
      return this;
    };
    Suite.prototype.addSuite = function(suite) {
      suite.parent = this;
      suite.root = false;
      suite.timeout(this.timeout());
      suite.retries(this.retries());
      suite.slow(this.slow());
      suite.bail(this.bail());
      this.suites.push(suite);
      this.emit(constants.EVENT_SUITE_ADD_SUITE, suite);
      return this;
    };
    Suite.prototype.addTest = function(test2) {
      test2.parent = this;
      test2.timeout(this.timeout());
      test2.retries(this.retries());
      test2.slow(this.slow());
      test2.ctx = this.ctx;
      this.tests.push(test2);
      this.emit(constants.EVENT_SUITE_ADD_TEST, test2);
      return this;
    };
    Suite.prototype.fullTitle = function() {
      return this.titlePath().join(" ");
    };
    Suite.prototype.titlePath = function() {
      var result = [];
      if (this.parent) result = result.concat(this.parent.titlePath());
      if (!this.root) result.push(this.title);
      return result;
    };
    Suite.prototype.total = function() {
      return this.suites.reduce(function(sum, suite) {
        return sum + suite.total();
      }, 0) + this.tests.length;
    };
    Suite.prototype.eachTest = function(fn) {
      this.tests.forEach(fn);
      this.suites.forEach(function(suite) {
        suite.eachTest(fn);
      });
      return this;
    };
    Suite.prototype.run = /* @__PURE__ */ __name(function run() {
      if (this.root) this.emit(constants.EVENT_ROOT_SUITE_RUN);
    }, "run");
    Suite.prototype.hasOnly = /* @__PURE__ */ __name(function hasOnly() {
      return this._onlyTests.length > 0 || this._onlySuites.length > 0 || this.suites.some(function(suite) {
        return suite.hasOnly();
      });
    }, "hasOnly");
    Suite.prototype.filterOnly = /* @__PURE__ */ __name(function filterOnly() {
      if (this._onlyTests.length) {
        this.tests = this._onlyTests;
        this.suites = [];
      } else {
        this.tests = [];
        this._onlySuites.forEach(function(onlySuite) {
          if (onlySuite.hasOnly()) onlySuite.filterOnly();
        });
        var onlySuites = this._onlySuites;
        this.suites = this.suites.filter(function(childSuite) {
          return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();
        });
      }
      return this.tests.length > 0 || this.suites.length > 0;
    }, "filterOnly");
    Suite.prototype.appendOnlySuite = function(suite) {
      this._onlySuites.push(suite);
    };
    Suite.prototype.markOnly = function() {
      this.parent && this.parent.appendOnlySuite(this);
    };
    Suite.prototype.appendOnlyTest = function(test2) {
      this._onlyTests.push(test2);
    };
    Suite.prototype.getHooks = /* @__PURE__ */ __name(function getHooks(name) {
      return this["_" + name];
    }, "getHooks");
    Suite.prototype.dispose = function() {
      this.suites.forEach(function(suite) {
        suite.dispose();
      });
      this.cleanReferences();
    };
    Suite.prototype.cleanReferences = /* @__PURE__ */ __name(function cleanReferences() {
      function cleanArrReferences(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) delete arr[i2].fn;
      }
      __name(cleanArrReferences, "cleanArrReferences");
      if (Array.isArray(this._beforeAll)) cleanArrReferences(this._beforeAll);
      if (Array.isArray(this._beforeEach)) cleanArrReferences(this._beforeEach);
      if (Array.isArray(this._afterAll)) cleanArrReferences(this._afterAll);
      if (Array.isArray(this._afterEach)) cleanArrReferences(this._afterEach);
      for (var i4 = 0; i4 < this.tests.length; i4++) delete this.tests[i4].fn;
    }, "cleanReferences");
    Suite.prototype.serialize = /* @__PURE__ */ __name(function serialize() {
      return {
        _bail: this._bail,
        $$fullTitle: this.fullTitle(),
        $$isPending: Boolean(this.isPending()),
        root: this.root,
        title: this.title,
        [MOCHA_ID_PROP_NAME]: this.id,
        parent: this.parent ? {
          [MOCHA_ID_PROP_NAME]: this.parent.id
        } : null
      };
    }, "serialize");
    var constants = defineConstants(
      /**
      * {@link Suite}-related constants.
      * @public
      * @memberof Suite
      * @alias constants
      * @readonly
      * @static
      * @enum {string}
      */
      {
        /**
        * Event emitted after a test file has been loaded. Not emitted in browser.
        */
        EVENT_FILE_POST_REQUIRE: "post-require",
        /**
        * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.
        */
        EVENT_FILE_PRE_REQUIRE: "pre-require",
        /**
        * Event emitted immediately after a test file has been loaded. Not emitted in browser.
        */
        EVENT_FILE_REQUIRE: "require",
        /**
        * Event emitted when `global.run()` is called (use with `delay` option).
        */
        EVENT_ROOT_SUITE_RUN: "run",
        /**
        * Namespace for collection of a `Suite`'s "after all" hooks.
        */
        HOOK_TYPE_AFTER_ALL: "afterAll",
        /**
        * Namespace for collection of a `Suite`'s "after each" hooks.
        */
        HOOK_TYPE_AFTER_EACH: "afterEach",
        /**
        * Namespace for collection of a `Suite`'s "before all" hooks.
        */
        HOOK_TYPE_BEFORE_ALL: "beforeAll",
        /**
        * Namespace for collection of a `Suite`'s "before each" hooks.
        */
        HOOK_TYPE_BEFORE_EACH: "beforeEach",
        /**
        * Emitted after a child `Suite` has been added to a `Suite`.
        */
        EVENT_SUITE_ADD_SUITE: "suite",
        /**
        * Emitted after an "after all" `Hook` has been added to a `Suite`.
        */
        EVENT_SUITE_ADD_HOOK_AFTER_ALL: "afterAll",
        /**
        * Emitted after an "after each" `Hook` has been added to a `Suite`.
        */
        EVENT_SUITE_ADD_HOOK_AFTER_EACH: "afterEach",
        /**
        * Emitted after an "before all" `Hook` has been added to a `Suite`.
        */
        EVENT_SUITE_ADD_HOOK_BEFORE_ALL: "beforeAll",
        /**
        * Emitted after an "before each" `Hook` has been added to a `Suite`.
        */
        EVENT_SUITE_ADD_HOOK_BEFORE_EACH: "beforeEach",
        /**
        * Emitted after a `Test` has been added to a `Suite`.
        */
        EVENT_SUITE_ADD_TEST: "test"
      }
    );
    Suite.constants = constants;
  });
  var EventEmitter1 = EventEmitter$2.EventEmitter;
  var debug1 = browser("mocha:runner");
  var HOOK_TYPE_BEFORE_EACH = suite1.constants.HOOK_TYPE_BEFORE_EACH;
  var HOOK_TYPE_AFTER_EACH = suite1.constants.HOOK_TYPE_AFTER_EACH;
  var HOOK_TYPE_AFTER_ALL = suite1.constants.HOOK_TYPE_AFTER_ALL;
  var HOOK_TYPE_BEFORE_ALL = suite1.constants.HOOK_TYPE_BEFORE_ALL;
  var EVENT_ROOT_SUITE_RUN = suite1.constants.EVENT_ROOT_SUITE_RUN;
  var STATE_FAILED1 = runnable1.constants.STATE_FAILED;
  var STATE_PASSED = runnable1.constants.STATE_PASSED;
  var STATE_PENDING = runnable1.constants.STATE_PENDING;
  var stackFilter = utils.stackTraceFilter();
  var stringify = utils.stringify;
  const { createInvalidExceptionError, createUnsupportedError: createUnsupportedError$1, createFatalError, isMochaError, constants: errorConstants } = errors;
  var globals1 = [
    "setTimeout",
    "clearTimeout",
    "setInterval",
    "clearInterval",
    "XMLHttpRequest",
    "Date",
    "setImmediate",
    "clearImmediate"
  ];
  var constants$1 = utils.defineConstants(
    /**
    * {@link Runner}-related constants.
    * @public
    * @memberof Runner
    * @readonly
    * @alias constants
    * @static
    * @enum {string}
    */
    {
      /**
      * Emitted when {@link Hook} execution begins
      */
      EVENT_HOOK_BEGIN: "hook",
      /**
      * Emitted when {@link Hook} execution ends
      */
      EVENT_HOOK_END: "hook end",
      /**
      * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)
      */
      EVENT_RUN_BEGIN: "start",
      /**
      * Emitted when Root {@link Suite} execution has been delayed via `delay` option
      */
      EVENT_DELAY_BEGIN: "waiting",
      /**
      * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`
      */
      EVENT_DELAY_END: "ready",
      /**
      * Emitted when Root {@link Suite} execution ends
      */
      EVENT_RUN_END: "end",
      /**
      * Emitted when {@link Suite} execution begins
      */
      EVENT_SUITE_BEGIN: "suite",
      /**
      * Emitted when {@link Suite} execution ends
      */
      EVENT_SUITE_END: "suite end",
      /**
      * Emitted when {@link Test} execution begins
      */
      EVENT_TEST_BEGIN: "test",
      /**
      * Emitted when {@link Test} execution ends
      */
      EVENT_TEST_END: "test end",
      /**
      * Emitted when {@link Test} execution fails
      */
      EVENT_TEST_FAIL: "fail",
      /**
      * Emitted when {@link Test} execution succeeds
      */
      EVENT_TEST_PASS: "pass",
      /**
      * Emitted when {@link Test} becomes pending
      */
      EVENT_TEST_PENDING: "pending",
      /**
      * Emitted when {@link Test} execution has failed, but will retry
      */
      EVENT_TEST_RETRY: "retry",
      /**
      * Initial state of Runner
      */
      STATE_IDLE: "idle",
      /**
      * State set to this value when the Runner has started running
      */
      STATE_RUNNING: "running",
      /**
      * State set to this value when the Runner has stopped
      */
      STATE_STOPPED: "stopped"
    }
  );
  class Runner extends EventEmitter1 {
    static {
      __name(this, "Runner");
    }
    /**
    * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.
    *
    * @extends external:EventEmitter
    * @public
    * @class
    * @param {Suite} suite - Root suite
    * @param {Object|boolean} [opts] - Options. If `boolean` (deprecated), whether to delay execution of root suite until ready.
    * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.
    * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.
    * @param {boolean} [opts.dryRun] - Whether to report tests without running them.
    * @param {boolean} [options.failZero] - Whether to fail test run if zero tests encountered.
    */
    constructor(suite, opts) {
      super();
      if (opts === void 0) opts = {};
      if (typeof opts === "boolean") {
        errors.deprecate('"Runner(suite: Suite, delay: boolean)" is deprecated. Use "Runner(suite: Suite, {delay: boolean})" instead.');
        this._delay = opts;
        opts = {};
      } else this._delay = opts.delay;
      var self2 = this;
      this._globals = [];
      this._abort = false;
      this.suite = suite;
      this._opts = opts;
      this.state = constants$1.STATE_IDLE;
      this.total = suite.total();
      this.failures = 0;
      this._eventListeners = /* @__PURE__ */ new Map();
      this.on(constants$1.EVENT_TEST_END, function(test2) {
        if (test2.type === "test" && test2.retriedTest() && test2.parent) {
          var idx = test2.parent.tests && test2.parent.tests.indexOf(test2.retriedTest());
          if (idx > -1) test2.parent.tests[idx] = test2;
        }
        self2.checkGlobals(test2);
      });
      this.on(constants$1.EVENT_HOOK_END, function(hook) {
        self2.checkGlobals(hook);
      });
      this._defaultGrep = /.*/;
      this.grep(this._defaultGrep);
      this.globals(this.globalProps());
      this.uncaught = this._uncaught.bind(this);
      this.unhandled = (reason, promise) => {
        if (isMochaError(reason)) {
          debug1("trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:", reason);
          this.uncaught(reason);
        } else {
          debug1("trapped unhandled rejection from (probably) user code; re-emitting on process");
          this._removeEventListener(process$1, "unhandledRejection", this.unhandled);
          try {
            process$1.emit("unhandledRejection", reason, promise);
          } finally {
            this._addEventListener(process$1, "unhandledRejection", this.unhandled);
          }
        }
      };
    }
  }
  Runner.immediately = commonjsGlobal.setImmediate || nextTick$1;
  Runner.prototype._addEventListener = function(target, eventName, listener) {
    debug1("_addEventListener(): adding for event %s; %d current listeners", eventName, target.listenerCount(eventName));
    if (this._eventListeners.has(target) && this._eventListeners.get(target).has(eventName) && this._eventListeners.get(target).get(eventName).has(listener)) {
      debug1("warning: tried to attach duplicate event listener for %s", eventName);
      return;
    }
    target.on(eventName, listener);
    const targetListeners = this._eventListeners.has(target) ? this._eventListeners.get(target) : /* @__PURE__ */ new Map();
    const targetEventListeners = targetListeners.has(eventName) ? targetListeners.get(eventName) : /* @__PURE__ */ new Set();
    targetEventListeners.add(listener);
    targetListeners.set(eventName, targetEventListeners);
    this._eventListeners.set(target, targetListeners);
  };
  Runner.prototype._removeEventListener = function(target, eventName, listener) {
    target.removeListener(eventName, listener);
    if (this._eventListeners.has(target)) {
      const targetListeners = this._eventListeners.get(target);
      if (targetListeners.has(eventName)) {
        const targetEventListeners = targetListeners.get(eventName);
        targetEventListeners.delete(listener);
        if (!targetEventListeners.size) targetListeners.delete(eventName);
      }
      if (!targetListeners.size) this._eventListeners.delete(target);
    } else debug1("trying to remove listener for untracked object %s", target);
  };
  Runner.prototype.dispose = function() {
    this.removeAllListeners();
    this._eventListeners.forEach((targetListeners, target) => {
      targetListeners.forEach((targetEventListeners, eventName) => {
        targetEventListeners.forEach((listener) => {
          target.removeListener(eventName, listener);
        });
      });
    });
    this._eventListeners.clear();
  };
  Runner.prototype.grep = function(re, invert) {
    debug1("grep(): setting to %s", re);
    this._grep = re;
    this._invert = invert;
    this.total = this.grepTotal(this.suite);
    return this;
  };
  Runner.prototype.grepTotal = function(suite) {
    var self2 = this;
    var total = 0;
    suite.eachTest(function(test2) {
      var match = self2._grep.test(test2.fullTitle());
      if (self2._invert) match = !match;
      if (match) total++;
    });
    return total;
  };
  Runner.prototype.globalProps = function() {
    var props = Object.keys(commonjsGlobal);
    for (var i2 = 0; i2 < globals1.length; ++i2) {
      if (~props.indexOf(globals1[i2])) continue;
      props.push(globals1[i2]);
    }
    return props;
  };
  Runner.prototype.globals = function(arr) {
    if (!arguments.length) return this._globals;
    debug1("globals(): setting to %O", arr);
    this._globals = this._globals.concat(arr);
    return this;
  };
  Runner.prototype.checkGlobals = function(test2) {
    if (!this.checkLeaks) return;
    var ok = this._globals;
    var globals = this.globalProps();
    var leaks;
    if (test2) ok = ok.concat(test2._allowedGlobals || []);
    if (this.prevGlobalsLength === globals.length) return;
    this.prevGlobalsLength = globals.length;
    leaks = filterLeaks(ok, globals);
    this._globals = this._globals.concat(leaks);
    if (leaks.length) {
      var msg = `global leak(s) detected: ${leaks.map(
        (e2) => `'${e2}'`
      ).join(", ")}`;
      this.fail(test2, new Error(msg));
    }
  };
  Runner.prototype.fail = function(test2, err, force) {
    force = force === true;
    if (test2.isPending() && !force) return;
    if (this.state === constants$1.STATE_STOPPED) {
      if (err.code === errorConstants.MULTIPLE_DONE) throw err;
      throw createFatalError("Test failed after root suite execution completed!", err);
    }
    ++this.failures;
    debug1("total number of failures: %d", this.failures);
    test2.state = STATE_FAILED1;
    if (!isError(err)) err = thrown2Error(err);
    try {
      err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);
    } catch (ignore) {
    }
    this.emit(constants$1.EVENT_TEST_FAIL, test2, err);
  };
  Runner.prototype.hook = function(name, fn) {
    if (this._opts.dryRun) return fn();
    var suite2 = this.suite;
    var hooks = suite2.getHooks(name);
    var self2 = this;
    function next(i2) {
      var hook2 = hooks[i2];
      if (!hook2) return fn();
      self2.currentRunnable = hook2;
      if (name === HOOK_TYPE_BEFORE_ALL) hook2.ctx.currentTest = hook2.parent.tests[0];
      else if (name === HOOK_TYPE_AFTER_ALL) hook2.ctx.currentTest = hook2.parent.tests[hook2.parent.tests.length - 1];
      else hook2.ctx.currentTest = self2.test;
      setHookTitle(hook2);
      hook2.allowUncaught = self2.allowUncaught;
      self2.emit(constants$1.EVENT_HOOK_BEGIN, hook2);
      if (!hook2.listeners("error").length) self2._addEventListener(hook2, "error", function(err) {
        self2.fail(hook2, err);
      });
      hook2.run(/* @__PURE__ */ __name(function cbHookRun(err) {
        var testError = hook2.error();
        if (testError) self2.fail(self2.test, testError);
        if (hook2.pending) {
          if (name === HOOK_TYPE_AFTER_EACH) {
            if (self2.test) self2.test.pending = true;
          } else if (name === HOOK_TYPE_BEFORE_EACH) {
            if (self2.test) self2.test.pending = true;
            self2.emit(constants$1.EVENT_HOOK_END, hook2);
            hook2.pending = false;
            return fn(new Error("abort hookDown"));
          } else if (name === HOOK_TYPE_BEFORE_ALL) {
            suite2.tests.forEach(function(test2) {
              test2.pending = true;
            });
            suite2.suites.forEach(function(suite) {
              suite.pending = true;
            });
            hooks = [];
          } else {
            hook2.pending = false;
            var errForbid = createUnsupportedError$1("`this.skip` forbidden");
            self2.fail(hook2, errForbid);
            return fn(errForbid);
          }
        } else if (err) {
          self2.fail(hook2, err);
          return fn(err);
        }
        self2.emit(constants$1.EVENT_HOOK_END, hook2);
        delete hook2.ctx.currentTest;
        setHookTitle(hook2);
        next(++i2);
      }, "cbHookRun"));
      function setHookTitle(hook) {
        hook.originalTitle = hook.originalTitle || hook.title;
        if (hook.ctx && hook.ctx.currentTest) hook.title = `${hook.originalTitle} for "${hook.ctx.currentTest.title}"`;
        else {
          var parentTitle;
          if (hook.parent.title) parentTitle = hook.parent.title;
          else parentTitle = hook.parent.root ? "{root}" : "";
          hook.title = `${hook.originalTitle} in "${parentTitle}"`;
        }
      }
      __name(setHookTitle, "setHookTitle");
    }
    __name(next, "next");
    Runner.immediately(function() {
      next(0);
    });
  };
  Runner.prototype.hooks = function(name, suites, fn) {
    var self2 = this;
    var orig = this.suite;
    function next(suite) {
      self2.suite = suite;
      if (!suite) {
        self2.suite = orig;
        return fn();
      }
      self2.hook(name, function(err) {
        if (err) {
          var errSuite = self2.suite;
          self2.suite = orig;
          return fn(err, errSuite);
        }
        next(suites.pop());
      });
    }
    __name(next, "next");
    next(suites.pop());
  };
  Runner.prototype.hookUp = function(name, fn) {
    var suites = [
      this.suite
    ].concat(this.parents()).reverse();
    this.hooks(name, suites, fn);
  };
  Runner.prototype.hookDown = function(name, fn) {
    var suites = [
      this.suite
    ].concat(this.parents());
    this.hooks(name, suites, fn);
  };
  Runner.prototype.parents = function() {
    var suite = this.suite;
    var suites = [];
    while (suite.parent) {
      suite = suite.parent;
      suites.push(suite);
    }
    return suites;
  };
  Runner.prototype.runTest = function(fn) {
    if (this._opts.dryRun) return fn();
    var self2 = this;
    var test2 = this.test;
    if (!test2) return;
    if (this.asyncOnly) test2.asyncOnly = true;
    this._addEventListener(test2, "error", function(err) {
      self2.fail(test2, err);
    });
    if (this.allowUncaught) {
      test2.allowUncaught = true;
      return test2.run(fn);
    }
    try {
      test2.run(fn);
    } catch (err) {
      fn(err);
    }
  };
  Runner.prototype.runTests = function(suite, fn) {
    var self2 = this;
    var tests2 = suite.tests.slice();
    var test2;
    function hookErr(_, errSuite, after) {
      var orig = self2.suite;
      self2.suite = after ? errSuite.parent : errSuite;
      if (self2.suite) self2.hookUp(HOOK_TYPE_AFTER_EACH, function(err2, errSuite2) {
        self2.suite = orig;
        if (err2) return hookErr(err2, errSuite2, true);
        fn(errSuite);
      });
      else {
        self2.suite = orig;
        fn(errSuite);
      }
    }
    __name(hookErr, "hookErr");
    function next(err3, errSuite1) {
      if (self2.failures && suite._bail) tests2 = [];
      if (self2._abort) return fn();
      if (err3) return hookErr(err3, errSuite1, true);
      test2 = tests2.shift();
      if (!test2) return fn();
      var match = self2._grep.test(test2.fullTitle());
      if (self2._invert) match = !match;
      if (!match) {
        if (self2._grep !== self2._defaultGrep) Runner.immediately(next);
        else next();
        return;
      }
      if (test2.isPending()) {
        if (self2.forbidPending) self2.fail(test2, new Error("Pending test forbidden"), true);
        else {
          test2.state = STATE_PENDING;
          self2.emit(constants$1.EVENT_TEST_PENDING, test2);
        }
        self2.emit(constants$1.EVENT_TEST_END, test2);
        return next();
      }
      self2.emit(constants$1.EVENT_TEST_BEGIN, self2.test = test2);
      self2.hookDown(HOOK_TYPE_BEFORE_EACH, function(err4, errSuite) {
        if (test2.isPending()) {
          if (self2.forbidPending) self2.fail(test2, new Error("Pending test forbidden"), true);
          else {
            test2.state = STATE_PENDING;
            self2.emit(constants$1.EVENT_TEST_PENDING, test2);
          }
          self2.emit(constants$1.EVENT_TEST_END, test2);
          var origSuite = self2.suite;
          self2.suite = errSuite || self2.suite;
          return self2.hookUp(HOOK_TYPE_AFTER_EACH, function(e2, eSuite) {
            self2.suite = origSuite;
            next(e2, eSuite);
          });
        }
        if (err4) return hookErr(err4, errSuite, false);
        self2.currentRunnable = self2.test;
        self2.runTest(function(err) {
          test2 = self2.test;
          if (test2.pending) {
            if (self2.forbidPending) self2.fail(test2, new Error("Pending test forbidden"), true);
            else {
              test2.state = STATE_PENDING;
              self2.emit(constants$1.EVENT_TEST_PENDING, test2);
            }
            self2.emit(constants$1.EVENT_TEST_END, test2);
            return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
          } else if (err) {
            var retry = test2.currentRetry();
            if (retry < test2.retries()) {
              var clonedTest = test2.clone();
              clonedTest.currentRetry(retry + 1);
              tests2.unshift(clonedTest);
              self2.emit(constants$1.EVENT_TEST_RETRY, test2, err);
              return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
            } else self2.fail(test2, err);
            self2.emit(constants$1.EVENT_TEST_END, test2);
            return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
          }
          test2.state = STATE_PASSED;
          self2.emit(constants$1.EVENT_TEST_PASS, test2);
          self2.emit(constants$1.EVENT_TEST_END, test2);
          self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
        });
      });
    }
    __name(next, "next");
    this.next = next;
    this.hookErr = hookErr;
    next();
  };
  Runner.prototype.runSuite = function(suite, fn) {
    var i2 = 0;
    var self2 = this;
    var total = this.grepTotal(suite);
    debug1("runSuite(): running %s", suite.fullTitle());
    if (!total || self2.failures && suite._bail) {
      debug1("runSuite(): bailing");
      return fn();
    }
    this.emit(constants$1.EVENT_SUITE_BEGIN, this.suite = suite);
    function next(errSuite) {
      if (errSuite) {
        if (errSuite === suite)
          return done();
        return done(errSuite);
      }
      if (self2._abort) return done();
      var curr = suite.suites[i2++];
      if (!curr) return done();
      if (self2._grep !== self2._defaultGrep) Runner.immediately(function() {
        self2.runSuite(curr, next);
      });
      else self2.runSuite(curr, next);
    }
    __name(next, "next");
    function done(errSuite) {
      self2.suite = suite;
      self2.nextSuite = next;
      delete self2.test;
      self2.hook(HOOK_TYPE_AFTER_ALL, function() {
        self2.emit(constants$1.EVENT_SUITE_END, suite);
        fn(errSuite);
      });
    }
    __name(done, "done");
    this.nextSuite = next;
    this.hook(HOOK_TYPE_BEFORE_ALL, function(err) {
      if (err) return done();
      self2.runTests(suite, next);
    });
  };
  Runner.prototype._uncaught = function(err) {
    if (!(this instanceof Runner)) throw createFatalError("Runner#uncaught() called with invalid context", this);
    if (err instanceof pending1) {
      debug1("uncaught(): caught a Pending");
      return;
    }
    if (this.allowUncaught && !utils.isBrowser()) {
      debug1("uncaught(): bubbling exception due to --allow-uncaught");
      throw err;
    }
    if (this.state === constants$1.STATE_STOPPED) {
      debug1("uncaught(): throwing after run has completed!");
      throw err;
    }
    if (err) debug1("uncaught(): got truthy exception %O", err);
    else {
      debug1("uncaught(): undefined/falsy exception");
      err = createInvalidExceptionError("Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger", err);
    }
    if (!isError(err)) {
      err = thrown2Error(err);
      debug1('uncaught(): converted "error" %o to Error', err);
    }
    err.uncaught = true;
    var runnable$1 = this.currentRunnable;
    if (!runnable$1) {
      runnable$1 = new runnable1("Uncaught error outside test suite");
      debug1("uncaught(): no current Runnable; created a phony one");
      runnable$1.parent = this.suite;
      if (this.state === constants$1.STATE_RUNNING) {
        debug1("uncaught(): failing gracefully");
        this.fail(runnable$1, err);
      } else {
        debug1("uncaught(): test run has not yet started; unrecoverable");
        this.emit(constants$1.EVENT_RUN_BEGIN);
        this.fail(runnable$1, err);
        this.emit(constants$1.EVENT_RUN_END);
      }
      return;
    }
    runnable$1.clearTimeout();
    if (runnable$1.isFailed()) {
      debug1("uncaught(): Runnable has already failed");
      return;
    } else if (runnable$1.isPending()) {
      debug1("uncaught(): pending Runnable wound up failing!");
      this.fail(runnable$1, err, true);
      return;
    }
    if (runnable$1.isPassed()) {
      debug1("uncaught(): Runnable has already passed; bailing gracefully");
      this.fail(runnable$1, err);
      this.abort();
    } else {
      debug1("uncaught(): forcing Runnable to complete with Error");
      return runnable$1.callback(err);
    }
  };
  Runner.prototype.run = function(fn, opts = {}) {
    var rootSuite = this.suite;
    var options = opts.options || {};
    debug1("run(): got options: %O", options);
    fn = fn || function() {
    };
    const end = /* @__PURE__ */ __name(() => {
      if (!this.total && this._opts.failZero) this.failures = 1;
      debug1("run(): root suite completed; emitting %s", constants$1.EVENT_RUN_END);
      this.emit(constants$1.EVENT_RUN_END);
    }, "end");
    const begin = /* @__PURE__ */ __name(() => {
      debug1("run(): emitting %s", constants$1.EVENT_RUN_BEGIN);
      this.emit(constants$1.EVENT_RUN_BEGIN);
      debug1("run(): emitted %s", constants$1.EVENT_RUN_BEGIN);
      this.runSuite(rootSuite, end);
    }, "begin");
    const prepare = /* @__PURE__ */ __name(() => {
      debug1("run(): starting");
      if (rootSuite.hasOnly()) {
        rootSuite.filterOnly();
        debug1("run(): filtered exclusive Runnables");
      }
      this.state = constants$1.STATE_RUNNING;
      if (this._delay) {
        this.emit(constants$1.EVENT_DELAY_END);
        debug1('run(): "delay" ended');
      }
      return begin();
    }, "prepare");
    if (this._opts.cleanReferencesAfterRun) this.on(constants$1.EVENT_SUITE_END, (suite) => {
      suite.cleanReferences();
    });
    this.on(constants$1.EVENT_RUN_END, function() {
      this.state = constants$1.STATE_STOPPED;
      debug1("run(): emitted %s", constants$1.EVENT_RUN_END);
      fn(this.failures);
    });
    this._removeEventListener(process$1, "uncaughtException", this.uncaught);
    this._removeEventListener(process$1, "unhandledRejection", this.unhandled);
    this._addEventListener(process$1, "uncaughtException", this.uncaught);
    this._addEventListener(process$1, "unhandledRejection", this.unhandled);
    if (this._delay) {
      this.emit(constants$1.EVENT_DELAY_BEGIN, rootSuite);
      rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);
      debug1("run(): waiting for green light due to --delay");
    } else Runner.immediately(prepare);
    return this;
  };
  Runner.prototype.linkPartialObjects = function(value) {
    return this;
  };
  Runner.prototype.runAsync = /* @__PURE__ */ __name(async function runAsync(opts = {}) {
    return new Promise((resolve) => {
      this.run(resolve, opts);
    });
  }, "runAsync");
  Runner.prototype.abort = function() {
    debug1("abort(): aborting");
    this._abort = true;
    return this;
  };
  Runner.prototype.isParallelMode = /* @__PURE__ */ __name(function isParallelMode() {
    return false;
  }, "isParallelMode");
  Runner.prototype.workerReporter = function() {
    throw createUnsupportedError$1("workerReporter() not supported in serial mode");
  };
  function filterLeaks(ok1, globals) {
    return globals.filter(function(key) {
      if (/^\d+/.test(key)) return false;
      if (commonjsGlobal.navigator && /^getInterface/.test(key)) return false;
      if (commonjsGlobal.navigator && /^\d+/.test(key)) return false;
      if (/^mocha-/.test(key)) return false;
      var matched = ok1.filter(function(ok) {
        if (~ok.indexOf("*")) return key.indexOf(ok.split("*")[0]) === 0;
        return key === ok;
      });
      return !matched.length && (!commonjsGlobal.navigator || key !== "onerror");
    });
  }
  __name(filterLeaks, "filterLeaks");
  function isError(err) {
    return err instanceof Error || err && typeof err.message === "string";
  }
  __name(isError, "isError");
  function thrown2Error(err) {
    return new Error(`the ${utils.canonicalType(err)} ${stringify(err)} was thrown, throw an Error :)`);
  }
  __name(thrown2Error, "thrown2Error");
  Runner.constants = constants$1;
  var runner1 = Runner;
  var require$$10 = getCjsExportFromNamespace(_nodeResolve_empty$1);
  var base1 = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    const isBrowser = utils.isBrowser();
    function getBrowserWindowSize() {
      if ("innerHeight" in commonjsGlobal) return [
        commonjsGlobal.innerHeight,
        commonjsGlobal.innerWidth
      ];
      return [
        640,
        480
      ];
    }
    __name(getBrowserWindowSize, "getBrowserWindowSize");
    exports = module.exports = Base;
    var isatty = isBrowser || process$1.stdout.isTTY && process$1.stderr.isTTY;
    var consoleLog = console.log;
    exports.useColors = !isBrowser && (require$$10.stdout || process$1.env.MOCHA_COLORS !== void 0);
    exports.inlineDiffs = false;
    exports.colors = {
      pass: 90,
      fail: 31,
      "bright pass": 92,
      "bright fail": 91,
      "bright yellow": 93,
      pending: 36,
      suite: 0,
      "error title": 0,
      "error message": 31,
      "error stack": 90,
      checkmark: 32,
      fast: 90,
      medium: 33,
      slow: 31,
      green: 32,
      light: 90,
      "diff gutter": 90,
      "diff added": 32,
      "diff removed": 31,
      "diff added inline": "30;42",
      "diff removed inline": "30;41"
    };
    exports.symbols = {
      ok: browser$1.success,
      err: browser$1.error,
      dot: ".",
      comma: ",",
      bang: "!"
    };
    var color = exports.color = function(type, str) {
      if (!exports.useColors) return String(str);
      return "\x1B[" + exports.colors[type] + "m" + str + "\x1B[0m";
    };
    exports.window = {
      width: 75
    };
    if (isatty) {
      if (isBrowser) exports.window.width = getBrowserWindowSize()[1];
      else exports.window.width = process$1.stdout.getWindowSize(1)[0];
    }
    exports.cursor = {
      hide: /* @__PURE__ */ __name(function() {
        isatty && process$1.stdout.write("\x1B[?25l");
      }, "hide"),
      show: /* @__PURE__ */ __name(function() {
        isatty && process$1.stdout.write("\x1B[?25h");
      }, "show"),
      deleteLine: /* @__PURE__ */ __name(function() {
        isatty && process$1.stdout.write("\x1B[2K");
      }, "deleteLine"),
      beginningOfLine: /* @__PURE__ */ __name(function() {
        isatty && process$1.stdout.write("\x1B[0G");
      }, "beginningOfLine"),
      CR: /* @__PURE__ */ __name(function() {
        if (isatty) {
          exports.cursor.deleteLine();
          exports.cursor.beginningOfLine();
        } else process$1.stdout.write("\r");
      }, "CR")
    };
    var showDiff = exports.showDiff = function(err) {
      return err && err.showDiff !== false && sameType(err.actual, err.expected) && err.expected !== void 0;
    };
    function stringifyDiffObjs(err) {
      if (!utils.isString(err.actual) || !utils.isString(err.expected)) {
        err.actual = utils.stringify(err.actual);
        err.expected = utils.stringify(err.expected);
      }
    }
    __name(stringifyDiffObjs, "stringifyDiffObjs");
    var generateDiff = exports.generateDiff = function(actual, expected) {
      try {
        const diffSize = 2048;
        if (actual.length > diffSize) actual = actual.substring(0, diffSize) + " ... Lines skipped";
        if (expected.length > diffSize) expected = expected.substring(0, diffSize) + " ... Lines skipped";
        return exports.inlineDiffs ? inlineDiff(actual, expected) : unifiedDiff(actual, expected);
      } catch (err) {
        var msg = "\n      " + color("diff added", "+ expected") + " " + color("diff removed", "- actual:  failed to generate Mocha diff") + "\n";
        return msg;
      }
    };
    exports.list = function(failures) {
      var multipleErr, multipleTest;
      Base.consoleLog();
      failures.forEach(function(test2, i5) {
        var fmt = color("error title", "  %s) %s:\n") + color("error message", "     %s") + color("error stack", "\n%s\n");
        var msg;
        var err;
        if (test2.err && test2.err.multiple) {
          if (multipleTest !== test2) {
            multipleTest = test2;
            multipleErr = [
              test2.err
            ].concat(test2.err.multiple);
          }
          err = multipleErr.shift();
        } else err = test2.err;
        var message;
        if (typeof err.inspect === "function") message = err.inspect() + "";
        else if (err.message && typeof err.message.toString === "function") message = err.message + "";
        else message = "";
        var stack = err.stack || message;
        var index1 = message ? stack.indexOf(message) : -1;
        if (index1 === -1) msg = message;
        else {
          index1 += message.length;
          msg = stack.slice(0, index1);
          stack = stack.slice(index1 + 1);
        }
        if (err.uncaught) msg = "Uncaught " + msg;
        if (!exports.hideDiff && showDiff(err)) {
          stringifyDiffObjs(err);
          fmt = color("error title", "  %s) %s:\n%s") + color("error stack", "\n%s\n");
          var match = message.match(/^([^:]+): expected/);
          msg = "\n      " + color("error message", match ? match[1] : msg);
          msg += generateDiff(err.actual, err.expected);
        }
        stack = stack.replace(/^/gm, "  ");
        var testTitle = "";
        test2.titlePath().forEach(function(str, index) {
          if (index !== 0) testTitle += "\n     ";
          for (var i2 = 0; i2 < index; i2++) testTitle += "  ";
          testTitle += str;
        });
        Base.consoleLog(fmt, i5 + 1, testTitle, msg, stack);
      });
    };
    function Base(runner, options) {
      var failures = this.failures = [];
      if (!runner) throw new TypeError("Missing runner argument");
      this.options = options || {};
      this.runner = runner;
      this.stats = runner.stats;
      runner.on(EVENT_TEST_PASS, function(test2) {
        if (test2.duration > test2.slow()) test2.speed = "slow";
        else if (test2.duration > test2.slow() / 2) test2.speed = "medium";
        else test2.speed = "fast";
      });
      runner.on(EVENT_TEST_FAIL, function(test2, err) {
        if (showDiff(err)) stringifyDiffObjs(err);
        if (test2.err && err instanceof Error) test2.err.multiple = (test2.err.multiple || []).concat(err);
        else test2.err = err;
        failures.push(test2);
      });
    }
    __name(Base, "Base");
    Base.prototype.epilogue = function() {
      var stats = this.stats;
      var fmt;
      Base.consoleLog();
      fmt = color("bright pass", " ") + color("green", " %d passing") + color("light", " (%s)");
      Base.consoleLog(fmt, stats.passes || 0, ms$1(stats.duration));
      if (stats.pending) {
        fmt = color("pending", " ") + color("pending", " %d pending");
        Base.consoleLog(fmt, stats.pending);
      }
      if (stats.failures) {
        fmt = color("fail", "  %d failing");
        Base.consoleLog(fmt, stats.failures);
        Base.list(this.failures);
        Base.consoleLog();
      }
      Base.consoleLog();
    };
    function pad(str, len) {
      str = String(str);
      return Array(len - str.length + 1).join(" ") + str;
    }
    __name(pad, "pad");
    function inlineDiff(actual, expected) {
      var msg = errorDiff(actual, expected);
      var lines = msg.split("\n");
      if (lines.length > 4) {
        var width = String(lines.length).length;
        msg = lines.map(function(str, i2) {
          return pad(++i2, width) + " | " + str;
        }).join("\n");
      }
      msg = "\n" + color("diff removed inline", "actual") + " " + color("diff added inline", "expected") + "\n\n" + msg + "\n";
      msg = msg.replace(/^/gm, "      ");
      return msg;
    }
    __name(inlineDiff, "inlineDiff");
    function unifiedDiff(actual, expected) {
      var indent = "      ";
      function cleanUp(line) {
        if (line[0] === "+") return indent + colorLines("diff added", line);
        if (line[0] === "-") return indent + colorLines("diff removed", line);
        if (line.match(/@@/)) return "--";
        if (line.match(/\\ No newline/)) return null;
        return indent + line;
      }
      __name(cleanUp, "cleanUp");
      function notBlank(line) {
        return typeof line !== "undefined" && line !== null;
      }
      __name(notBlank, "notBlank");
      var msg = diff$1.createPatch("string", actual, expected);
      var lines = msg.split("\n").splice(5);
      return "\n      " + colorLines("diff added", "+ expected") + " " + colorLines("diff removed", "- actual") + "\n\n" + lines.map(cleanUp).filter(notBlank).join("\n");
    }
    __name(unifiedDiff, "unifiedDiff");
    function errorDiff(actual, expected) {
      return diff$1.diffWordsWithSpace(actual, expected).map(function(str) {
        if (str.added) return colorLines("diff added inline", str.value);
        if (str.removed) return colorLines("diff removed inline", str.value);
        return str.value;
      }).join("");
    }
    __name(errorDiff, "errorDiff");
    function colorLines(name, str1) {
      return str1.split("\n").map(function(str) {
        return color(name, str);
      }).join("\n");
    }
    __name(colorLines, "colorLines");
    var objToString = Object.prototype.toString;
    function sameType(a2, b) {
      return objToString.call(a2) === objToString.call(b);
    }
    __name(sameType, "sameType");
    Base.consoleLog = consoleLog;
    Base.abstract = true;
  });
  var dot = createCommonjsModule(function(module, exports) {
    var inherits = utils.inherits;
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    module.exports = Dot;
    function Dot(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var width = base1.window.width * 0.75 | 0;
      var n2 = -1;
      runner.on(EVENT_RUN_BEGIN, function() {
        process$1.stdout.write("\n");
      });
      runner.on(EVENT_TEST_PENDING, function() {
        if (++n2 % width === 0) process$1.stdout.write("\n  ");
        process$1.stdout.write(base1.color("pending", base1.symbols.comma));
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        if (++n2 % width === 0) process$1.stdout.write("\n  ");
        if (test2.speed === "slow") process$1.stdout.write(base1.color("bright yellow", base1.symbols.dot));
        else process$1.stdout.write(base1.color(test2.speed, base1.symbols.dot));
      });
      runner.on(EVENT_TEST_FAIL, function() {
        if (++n2 % width === 0) process$1.stdout.write("\n  ");
        process$1.stdout.write(base1.color("fail", base1.symbols.bang));
      });
      runner.once(EVENT_RUN_END, function() {
        process$1.stdout.write("\n");
        self2.epilogue();
      });
    }
    __name(Dot, "Dot");
    inherits(Dot, base1);
    Dot.description = "dot matrix representation";
  });
  var doc = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    module.exports = Doc;
    function Doc(runner, options) {
      base1.call(this, runner, options);
      var indents = 2;
      function indent() {
        return Array(indents).join("  ");
      }
      __name(indent, "indent");
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        if (suite.root) return;
        ++indents;
        base1.consoleLog('%s<section class="suite">', indent());
        ++indents;
        base1.consoleLog("%s<h1>%s</h1>", indent(), utils.escape(suite.title));
        base1.consoleLog("%s<dl>", indent());
      });
      runner.on(EVENT_SUITE_END, function(suite) {
        if (suite.root) return;
        base1.consoleLog("%s</dl>", indent());
        --indents;
        base1.consoleLog("%s</section>", indent());
        --indents;
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        base1.consoleLog("%s  <dt>%s</dt>", indent(), utils.escape(test2.title));
        base1.consoleLog("%s  <dt>%s</dt>", indent(), utils.escape(test2.file));
        var code = utils.escape(utils.clean(test2.body));
        base1.consoleLog("%s  <dd><pre><code>%s</code></pre></dd>", indent(), code);
      });
      runner.on(EVENT_TEST_FAIL, function(test2, err) {
        base1.consoleLog('%s  <dt class="error">%s</dt>', indent(), utils.escape(test2.title));
        base1.consoleLog('%s  <dt class="error">%s</dt>', indent(), utils.escape(test2.file));
        var code = utils.escape(utils.clean(test2.body));
        base1.consoleLog('%s  <dd class="error"><pre><code>%s</code></pre></dd>', indent(), code);
        base1.consoleLog('%s  <dd class="error">%s</dd>', indent(), utils.escape(err));
      });
    }
    __name(Doc, "Doc");
    Doc.description = "HTML documentation";
  });
  var tap = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var inherits = utils.inherits;
    var sprintf = util.format;
    module.exports = TAP;
    function TAP(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var n2 = 1;
      var tapVersion = "12";
      if (options && options.reporterOptions) {
        if (options.reporterOptions.tapVersion) tapVersion = options.reporterOptions.tapVersion.toString();
      }
      this._producer = createProducer(tapVersion);
      runner.once(EVENT_RUN_BEGIN, function() {
        self2._producer.writeVersion();
      });
      runner.on(EVENT_TEST_END, function() {
        ++n2;
      });
      runner.on(EVENT_TEST_PENDING, function(test2) {
        self2._producer.writePending(n2, test2);
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        self2._producer.writePass(n2, test2);
      });
      runner.on(EVENT_TEST_FAIL, function(test2, err) {
        self2._producer.writeFail(n2, test2, err);
      });
      runner.once(EVENT_RUN_END, function() {
        self2._producer.writeEpilogue(runner.stats);
      });
    }
    __name(TAP, "TAP");
    inherits(TAP, base1);
    function title(test2) {
      return test2.fullTitle().replace(/#/g, "");
    }
    __name(title, "title");
    function println(format, varArgs) {
      var vargs = Array.from(arguments);
      vargs[0] += "\n";
      process$1.stdout.write(sprintf.apply(null, vargs));
    }
    __name(println, "println");
    function createProducer(tapVersion) {
      var producers = {
        "12": new TAP12Producer(),
        "13": new TAP13Producer()
      };
      var producer = producers[tapVersion];
      if (!producer) throw new Error("invalid or unsupported TAP version: " + JSON.stringify(tapVersion));
      return producer;
    }
    __name(createProducer, "createProducer");
    function TAPProducer() {
    }
    __name(TAPProducer, "TAPProducer");
    TAPProducer.prototype.writeVersion = function() {
    };
    TAPProducer.prototype.writePlan = function(ntests) {
      println("%d..%d", 1, ntests);
    };
    TAPProducer.prototype.writePass = function(n2, test2) {
      println("ok %d %s", n2, title(test2));
    };
    TAPProducer.prototype.writePending = function(n2, test2) {
      println("ok %d %s # SKIP -", n2, title(test2));
    };
    TAPProducer.prototype.writeFail = function(n2, test2, err) {
      println("not ok %d %s", n2, title(test2));
    };
    TAPProducer.prototype.writeEpilogue = function(stats) {
      println("# tests " + (stats.passes + stats.failures));
      println("# pass " + stats.passes);
      println("# fail " + stats.failures);
      this.writePlan(stats.passes + stats.failures + stats.pending);
    };
    function TAP12Producer() {
      this.writeFail = function(n2, test2, err) {
        TAPProducer.prototype.writeFail.call(this, n2, test2, err);
        if (err.message) println(err.message.replace(/^/gm, "  "));
        if (err.stack) println(err.stack.replace(/^/gm, "  "));
      };
    }
    __name(TAP12Producer, "TAP12Producer");
    inherits(TAP12Producer, TAPProducer);
    function TAP13Producer() {
      this.writeVersion = function() {
        println("TAP version 13");
      };
      this.writeFail = function(n2, test2, err) {
        TAPProducer.prototype.writeFail.call(this, n2, test2, err);
        var emitYamlBlock = err.message != null || err.stack != null;
        if (emitYamlBlock) {
          println(indent(1) + "---");
          if (err.message) {
            println(indent(2) + "message: |-");
            println(err.message.replace(/^/gm, indent(3)));
          }
          if (err.stack) {
            println(indent(2) + "stack: |-");
            println(err.stack.replace(/^/gm, indent(3)));
          }
          println(indent(1) + "...");
        }
      };
      function indent(level) {
        return Array(level + 1).join("  ");
      }
      __name(indent, "indent");
    }
    __name(TAP13Producer, "TAP13Producer");
    inherits(TAP13Producer, TAPProducer);
    TAP.description = "TAP-compatible output";
  });
  var fs = {};
  var json1 = createCommonjsModule(function(module, exports) {
    const createUnsupportedError = errors.createUnsupportedError;
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    module.exports = JSONReporter;
    function JSONReporter(runner, options = {}) {
      base1.call(this, runner, options);
      var self2 = this;
      var tests2 = [];
      var pending = [];
      var failures = [];
      var passes = [];
      var output;
      if (options.reporterOption && options.reporterOption.output) {
        if (utils.isBrowser()) throw createUnsupportedError("file output not supported in browser");
        output = options.reporterOption.output;
      }
      runner.on(EVENT_TEST_END, function(test2) {
        tests2.push(test2);
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        passes.push(test2);
      });
      runner.on(EVENT_TEST_FAIL, function(test2) {
        failures.push(test2);
      });
      runner.on(EVENT_TEST_PENDING, function(test2) {
        pending.push(test2);
      });
      runner.once(EVENT_RUN_END, function() {
        var obj = {
          stats: self2.stats,
          tests: tests2.map(clean),
          pending: pending.map(clean),
          failures: failures.map(clean),
          passes: passes.map(clean)
        };
        runner.testResults = obj;
        var json = JSON.stringify(obj, null, 2);
        if (output) try {
          fs.mkdirSync(path1.dirname(output), {
            recursive: true
          });
          fs.writeFileSync(output, json);
        } catch (err) {
          console.error(`${base1.symbols.err} [mocha] writing output to "${output}" failed: ${err.message}
`);
          process$1.stdout.write(json);
        }
        else process$1.stdout.write(json);
      });
    }
    __name(JSONReporter, "JSONReporter");
    function clean(test2) {
      var err = test2.err || {};
      if (err instanceof Error) err = errorJSON(err);
      return {
        title: test2.title,
        fullTitle: test2.fullTitle(),
        file: test2.file,
        duration: test2.duration,
        currentRetry: test2.currentRetry(),
        speed: test2.speed,
        err: cleanCycles(err)
      };
    }
    __name(clean, "clean");
    function cleanCycles(obj) {
      var cache = [];
      return JSON.parse(JSON.stringify(obj, function(key, value) {
        if (typeof value === "object" && value !== null) {
          if (cache.indexOf(value) !== -1)
            return "" + value;
          cache.push(value);
        }
        return value;
      }));
    }
    __name(cleanCycles, "cleanCycles");
    function errorJSON(err) {
      var res = {};
      Object.getOwnPropertyNames(err).forEach(function(key) {
        res[key] = err[key];
      }, err);
      return res;
    }
    __name(errorJSON, "errorJSON");
    JSONReporter.description = "single JSON object";
  });
  var progress$1 = Progress1;
  function Progress1() {
    this.percent = 0;
    this.size(0);
    this.fontSize(11);
    this.font("helvetica, arial, sans-serif");
  }
  __name(Progress1, "Progress1");
  Progress1.prototype.size = function(size) {
    this._size = size;
    return this;
  };
  Progress1.prototype.text = function(text) {
    this._text = text;
    return this;
  };
  Progress1.prototype.fontSize = function(size) {
    this._fontSize = size;
    return this;
  };
  Progress1.prototype.font = function(family) {
    this._font = family;
    return this;
  };
  Progress1.prototype.update = function(n2) {
    this.percent = n2;
    return this;
  };
  Progress1.prototype.draw = function(ctx) {
    try {
      var percent = Math.min(this.percent, 100);
      var size = this._size;
      var half = size / 2;
      var x = half;
      var y = half;
      var rad = half - 1;
      var fontSize = this._fontSize;
      ctx.fillStyle = "white";
      ctx.font = fontSize + "px " + this._font;
      var angle = Math.PI * 2 * (percent / 100);
      ctx.clearRect(0, 0, size, size);
      ctx.strokeStyle = "#9f9f9f";
      ctx.beginPath();
      ctx.arc(x, y, rad, 0, angle, false);
      ctx.stroke();
      ctx.strokeStyle = "#eee";
      ctx.beginPath();
      ctx.arc(x, y, rad - 1, 0, angle, true);
      ctx.stroke();
      var text = this._text || (percent | 0) + "%";
      var w = ctx.measureText(text).width;
      ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);
    } catch (ignore) {
    }
    return this;
  };
  var html1 = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var escape = utils.escape;
    var Date2 = commonjsGlobal.Date;
    module.exports = HTML;
    var statsTemplate = '<ul id="mocha-stats"><li class="progress"><canvas width="40" height="40"></canvas></li><li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li><li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li><li class="duration">duration: <em>0</em>s</li></ul>';
    var playIcon = "&#x2023;";
    function HTML(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var stats = this.stats;
      var stat = fragment(statsTemplate);
      var items = stat.getElementsByTagName("li");
      var passes = items[1].getElementsByTagName("em")[0];
      var passesLink = items[1].getElementsByTagName("a")[0];
      var failures = items[2].getElementsByTagName("em")[0];
      var failuresLink = items[2].getElementsByTagName("a")[0];
      var duration = items[3].getElementsByTagName("em")[0];
      var canvas = stat.getElementsByTagName("canvas")[0];
      var report = fragment('<ul id="mocha-report"></ul>');
      var stack = [
        report
      ];
      var progress;
      var ctx;
      var root2 = document.getElementById("mocha");
      if (canvas.getContext) {
        var ratio = window.devicePixelRatio || 1;
        canvas.style.width = canvas.width;
        canvas.style.height = canvas.height;
        canvas.width *= ratio;
        canvas.height *= ratio;
        ctx = canvas.getContext("2d");
        ctx.scale(ratio, ratio);
        progress = new progress$1();
      }
      if (!root2) return error("#mocha div missing, add it to your document");
      on(passesLink, "click", function(evt) {
        evt.preventDefault();
        unhide();
        var name = /pass/.test(report.className) ? "" : " pass";
        report.className = report.className.replace(/fail|pass/g, "") + name;
        if (report.className.trim()) hideSuitesWithout("test pass");
      });
      on(failuresLink, "click", function(evt) {
        evt.preventDefault();
        unhide();
        var name = /fail/.test(report.className) ? "" : " fail";
        report.className = report.className.replace(/fail|pass/g, "") + name;
        if (report.className.trim()) hideSuitesWithout("test fail");
      });
      root2.appendChild(stat);
      root2.appendChild(report);
      if (progress) progress.size(40);
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        if (suite.root) return;
        var url = self2.suiteURL(suite);
        var el = fragment('<li class="suite"><h1><a href="%s">%s</a></h1></li>', url, escape(suite.title));
        stack[0].appendChild(el);
        stack.unshift(document.createElement("ul"));
        el.appendChild(stack[0]);
      });
      runner.on(EVENT_SUITE_END, function(suite) {
        if (suite.root) {
          updateStats();
          return;
        }
        stack.shift();
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        var url = self2.testURL(test2);
        var markup = '<li class="test pass %e"><h2>%e<span class="duration">%ems</span> <a href="%s" class="replay">' + playIcon + "</a></h2></li>";
        var el = fragment(markup, test2.speed, test2.title, test2.duration, url);
        self2.addCodeToggle(el, test2.body);
        appendToStack(el);
        updateStats();
      });
      runner.on(EVENT_TEST_FAIL, function(test2) {
        var el = fragment('<li class="test fail"><h2>%e <a href="%e" class="replay">' + playIcon + "</a></h2></li>", test2.title, self2.testURL(test2));
        var stackString;
        var message = test2.err.toString();
        if (message === "[object Error]") message = test2.err.message;
        if (test2.err.stack) {
          var indexOfMessage = test2.err.stack.indexOf(test2.err.message);
          if (indexOfMessage === -1) stackString = test2.err.stack;
          else stackString = test2.err.stack.substr(test2.err.message.length + indexOfMessage);
        } else if (test2.err.sourceURL && test2.err.line !== void 0)
          stackString = "\n(" + test2.err.sourceURL + ":" + test2.err.line + ")";
        stackString = stackString || "";
        if (test2.err.htmlMessage && stackString) el.appendChild(fragment('<div class="html-error">%s\n<pre class="error">%e</pre></div>', test2.err.htmlMessage, stackString));
        else if (test2.err.htmlMessage) el.appendChild(fragment('<div class="html-error">%s</div>', test2.err.htmlMessage));
        else el.appendChild(fragment('<pre class="error">%e%e</pre>', message, stackString));
        self2.addCodeToggle(el, test2.body);
        appendToStack(el);
        updateStats();
      });
      runner.on(EVENT_TEST_PENDING, function(test2) {
        var el = fragment('<li class="test pass pending"><h2>%e</h2></li>', test2.title);
        appendToStack(el);
        updateStats();
      });
      function appendToStack(el) {
        if (stack[0]) stack[0].appendChild(el);
      }
      __name(appendToStack, "appendToStack");
      function updateStats() {
        var percent = stats.tests / runner.total * 100 | 0;
        if (progress) progress.update(percent).draw(ctx);
        var ms = new Date2() - stats.start;
        text(passes, stats.passes);
        text(failures, stats.failures);
        text(duration, (ms / 1e3).toFixed(2));
      }
      __name(updateStats, "updateStats");
    }
    __name(HTML, "HTML");
    function makeUrl(s2) {
      var search = window.location.search;
      if (search) search = search.replace(/[?&]grep=[^&\s]*/g, "").replace(/^&/, "?");
      return window.location.pathname + (search ? search + "&" : "?") + "grep=" + encodeURIComponent(escapeStringRegexp(s2));
    }
    __name(makeUrl, "makeUrl");
    HTML.prototype.suiteURL = function(suite) {
      return makeUrl(suite.fullTitle());
    };
    HTML.prototype.testURL = function(test2) {
      return makeUrl(test2.fullTitle());
    };
    HTML.prototype.addCodeToggle = function(el, contents) {
      var h2 = el.getElementsByTagName("h2")[0];
      on(h2, "click", function() {
        pre.style.display = pre.style.display === "none" ? "block" : "none";
      });
      var pre = fragment("<pre><code>%e</code></pre>", utils.clean(contents));
      el.appendChild(pre);
      pre.style.display = "none";
    };
    function error(msg) {
      document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
    }
    __name(error, "error");
    function fragment(html) {
      var args = arguments;
      var div = document.createElement("div");
      var i2 = 1;
      div.innerHTML = html.replace(/%([se])/g, function(_, type) {
        switch (type) {
          case "s":
            return String(args[i2++]);
          case "e":
            return escape(args[i2++]);
        }
      });
      return div.firstChild;
    }
    __name(fragment, "fragment");
    function hideSuitesWithout(classname) {
      var suites = document.getElementsByClassName("suite");
      for (var i2 = 0; i2 < suites.length; i2++) {
        var els = suites[i2].getElementsByClassName(classname);
        if (!els.length) suites[i2].className += " hidden";
      }
    }
    __name(hideSuitesWithout, "hideSuitesWithout");
    function unhide() {
      var els = document.getElementsByClassName("suite hidden");
      while (els.length > 0) els[0].className = els[0].className.replace("suite hidden", "suite");
    }
    __name(unhide, "unhide");
    function text(el, contents) {
      if (el.textContent) el.textContent = contents;
      else el.innerText = contents;
    }
    __name(text, "text");
    function on(el, event, fn) {
      if (el.addEventListener) el.addEventListener(event, fn, false);
      else el.attachEvent("on" + event, fn);
    }
    __name(on, "on");
    HTML.browserOnly = true;
  });
  var list1 = createCommonjsModule(function(module, exports) {
    var inherits = utils.inherits;
    var constants = runner1.constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var color = base1.color;
    var cursor = base1.cursor;
    module.exports = List;
    function List(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var n2 = 0;
      runner.on(EVENT_RUN_BEGIN, function() {
        base1.consoleLog();
      });
      runner.on(EVENT_TEST_BEGIN, function(test2) {
        process$1.stdout.write(color("pass", "    " + test2.fullTitle() + ": "));
      });
      runner.on(EVENT_TEST_PENDING, function(test2) {
        var fmt = color("checkmark", "  -") + color("pending", " %s");
        base1.consoleLog(fmt, test2.fullTitle());
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        var fmt = color("checkmark", "  " + base1.symbols.ok) + color("pass", " %s: ") + color(test2.speed, "%dms");
        cursor.CR();
        base1.consoleLog(fmt, test2.fullTitle(), test2.duration);
      });
      runner.on(EVENT_TEST_FAIL, function(test2) {
        cursor.CR();
        base1.consoleLog(color("fail", "  %d) %s"), ++n2, test2.fullTitle());
      });
      runner.once(EVENT_RUN_END, self2.epilogue.bind(self2));
    }
    __name(List, "List");
    inherits(List, base1);
    List.description = 'like "spec" reporter but flat';
  });
  var min1 = createCommonjsModule(function(module, exports) {
    var inherits = utils.inherits;
    var constants = runner1.constants;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    module.exports = Min;
    function Min(runner, options) {
      base1.call(this, runner, options);
      runner.on(EVENT_RUN_BEGIN, function() {
        process$1.stdout.write("\x1B[2J");
        process$1.stdout.write("\x1B[1;3H");
      });
      runner.once(EVENT_RUN_END, this.epilogue.bind(this));
    }
    __name(Min, "Min");
    inherits(Min, base1);
    Min.description = "essentially just a summary";
  });
  var spec = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var inherits = utils.inherits;
    var color = base1.color;
    module.exports = Spec;
    function Spec(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var indents = 0;
      var n2 = 0;
      function indent() {
        return Array(indents).join("  ");
      }
      __name(indent, "indent");
      runner.on(EVENT_RUN_BEGIN, function() {
        base1.consoleLog();
      });
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        ++indents;
        base1.consoleLog(color("suite", "%s%s"), indent(), suite.title);
      });
      runner.on(EVENT_SUITE_END, function() {
        --indents;
        if (indents === 1) base1.consoleLog();
      });
      runner.on(EVENT_TEST_PENDING, function(test2) {
        var fmt = indent() + color("pending", "  - %s");
        base1.consoleLog(fmt, test2.title);
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        var fmt;
        if (test2.speed === "fast") {
          fmt = indent() + color("checkmark", "  " + base1.symbols.ok) + color("pass", " %s");
          base1.consoleLog(fmt, test2.title);
        } else {
          fmt = indent() + color("checkmark", "  " + base1.symbols.ok) + color("pass", " %s") + color(test2.speed, " (%dms)");
          base1.consoleLog(fmt, test2.title, test2.duration);
        }
      });
      runner.on(EVENT_TEST_FAIL, function(test2) {
        base1.consoleLog(indent() + color("fail", "  %d) %s"), ++n2, test2.title);
      });
      runner.once(EVENT_RUN_END, self2.epilogue.bind(self2));
    }
    __name(Spec, "Spec");
    inherits(Spec, base1);
    Spec.description = "hierarchical & verbose [default]";
  });
  var nyan = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var inherits = utils.inherits;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    module.exports = NyanCat;
    function NyanCat(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var width = base1.window.width * 0.75 | 0;
      var nyanCatWidth = this.nyanCatWidth = 11;
      this.colorIndex = 0;
      this.numberOfLines = 4;
      this.rainbowColors = self2.generateColors();
      this.scoreboardWidth = 5;
      this.tick = 0;
      this.trajectories = [
        [],
        [],
        [],
        []
      ];
      this.trajectoryWidthMax = width - nyanCatWidth;
      runner.on(EVENT_RUN_BEGIN, function() {
        base1.cursor.hide();
        self2.draw();
      });
      runner.on(EVENT_TEST_PENDING, function() {
        self2.draw();
      });
      runner.on(EVENT_TEST_PASS, function() {
        self2.draw();
      });
      runner.on(EVENT_TEST_FAIL, function() {
        self2.draw();
      });
      runner.once(EVENT_RUN_END, function() {
        base1.cursor.show();
        for (var i2 = 0; i2 < self2.numberOfLines; i2++) write("\n");
        self2.epilogue();
      });
    }
    __name(NyanCat, "NyanCat");
    inherits(NyanCat, base1);
    NyanCat.prototype.draw = function() {
      this.appendRainbow();
      this.drawScoreboard();
      this.drawRainbow();
      this.drawNyanCat();
      this.tick = !this.tick;
    };
    NyanCat.prototype.drawScoreboard = function() {
      var stats = this.stats;
      function draw(type, n2) {
        write(" ");
        write(base1.color(type, n2));
        write("\n");
      }
      __name(draw, "draw");
      draw("green", stats.passes);
      draw("fail", stats.failures);
      draw("pending", stats.pending);
      write("\n");
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.appendRainbow = function() {
      var segment = this.tick ? "_" : "-";
      var rainbowified = this.rainbowify(segment);
      for (var index = 0; index < this.numberOfLines; index++) {
        var trajectory = this.trajectories[index];
        if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();
        trajectory.push(rainbowified);
      }
    };
    NyanCat.prototype.drawRainbow = function() {
      var self2 = this;
      this.trajectories.forEach(function(line) {
        write("\x1B[" + self2.scoreboardWidth + "C");
        write(line.join(""));
        write("\n");
      });
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.drawNyanCat = function() {
      var self2 = this;
      var startWidth = this.scoreboardWidth + this.trajectories[0].length;
      var dist = "\x1B[" + startWidth + "C";
      var padding = "";
      write(dist);
      write("_,------,");
      write("\n");
      write(dist);
      padding = self2.tick ? "  " : "   ";
      write("_|" + padding + "/\\_/\\ ");
      write("\n");
      write(dist);
      padding = self2.tick ? "_" : "__";
      var tail = self2.tick ? "~" : "^";
      write(tail + "|" + padding + this.face() + " ");
      write("\n");
      write(dist);
      padding = self2.tick ? " " : "  ";
      write(padding + '""  "" ');
      write("\n");
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.face = function() {
      var stats = this.stats;
      if (stats.failures) return "( x .x)";
      else if (stats.pending) return "( o .o)";
      else if (stats.passes) return "( ^ .^)";
      return "( - .-)";
    };
    NyanCat.prototype.cursorUp = function(n2) {
      write("\x1B[" + n2 + "A");
    };
    NyanCat.prototype.cursorDown = function(n2) {
      write("\x1B[" + n2 + "B");
    };
    NyanCat.prototype.generateColors = function() {
      var colors2 = [];
      for (var i2 = 0; i2 < 42; i2++) {
        var pi3 = Math.floor(Math.PI / 3);
        var n2 = i2 * (1 / 6);
        var r2 = Math.floor(3 * Math.sin(n2) + 3);
        var g = Math.floor(3 * Math.sin(n2 + 2 * pi3) + 3);
        var b = Math.floor(3 * Math.sin(n2 + 4 * pi3) + 3);
        colors2.push(36 * r2 + 6 * g + b + 16);
      }
      return colors2;
    };
    NyanCat.prototype.rainbowify = function(str) {
      if (!base1.useColors) return str;
      var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
      this.colorIndex += 1;
      return "\x1B[38;5;" + color + "m" + str + "\x1B[0m";
    };
    function write(string) {
      process$1.stdout.write(string);
    }
    __name(write, "write");
    NyanCat.description = '"nyan cat"';
  });
  var xunit = createCommonjsModule(function(module, exports) {
    var createUnsupportedError = errors.createUnsupportedError;
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var STATE_FAILED = runnable1.constants.STATE_FAILED;
    var inherits = utils.inherits;
    var escape = utils.escape;
    var Date2 = commonjsGlobal.Date;
    module.exports = XUnit;
    function XUnit(runner, options) {
      base1.call(this, runner, options);
      var stats = this.stats;
      var tests2 = [];
      var self2 = this;
      var suiteName;
      var DEFAULT_SUITE_NAME = "Mocha Tests";
      if (options && options.reporterOptions) {
        if (options.reporterOptions.output) throw createUnsupportedError("file output not supported in browser");
        suiteName = options.reporterOptions.suiteName;
      }
      suiteName = suiteName || DEFAULT_SUITE_NAME;
      runner.on(EVENT_TEST_PENDING, function(test2) {
        tests2.push(test2);
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        tests2.push(test2);
      });
      runner.on(EVENT_TEST_FAIL, function(test2) {
        tests2.push(test2);
      });
      runner.once(EVENT_RUN_END, function() {
        self2.write(tag1("testsuite", {
          name: suiteName,
          tests: stats.tests,
          failures: 0,
          errors: stats.failures,
          skipped: stats.tests - stats.failures - stats.passes,
          timestamp: new Date2().toUTCString(),
          time: stats.duration / 1e3 || 0
        }, false));
        tests2.forEach(function(t2) {
          self2.test(t2);
        });
        self2.write("</testsuite>");
      });
    }
    __name(XUnit, "XUnit");
    inherits(XUnit, base1);
    XUnit.prototype.done = function(failures, fn) {
      if (this.fileStream) this.fileStream.end(function() {
        fn(failures);
      });
      else fn(failures);
    };
    XUnit.prototype.write = function(line) {
      if (this.fileStream) this.fileStream.write(line + "\n");
      else if (typeof process$1 === "object" && process$1.stdout) process$1.stdout.write(line + "\n");
      else base1.consoleLog(line);
    };
    XUnit.prototype.test = function(test2) {
      base1.useColors = false;
      var attrs = {
        classname: test2.parent.fullTitle(),
        name: test2.title,
        time: test2.duration / 1e3 || 0
      };
      if (test2.state === STATE_FAILED) {
        var err = test2.err;
        var diff = !base1.hideDiff && base1.showDiff(err) ? "\n" + base1.generateDiff(err.actual, err.expected) : "";
        this.write(tag1("testcase", attrs, false, tag1("failure", {}, false, escape(err.message) + escape(diff) + "\n" + escape(err.stack))));
      } else if (test2.isPending()) this.write(tag1("testcase", attrs, false, tag1("skipped", {}, true)));
      else this.write(tag1("testcase", attrs, true));
    };
    function tag1(name, attrs, close, content) {
      var end = close ? "/>" : ">";
      var pairs = [];
      var tag;
      for (var key in attrs) if (Object.prototype.hasOwnProperty.call(attrs, key)) pairs.push(key + '="' + escape(attrs[key]) + '"');
      tag = "<" + name + (pairs.length ? " " + pairs.join(" ") : "") + end;
      if (content) tag += content + "</" + name + end;
      return tag;
    }
    __name(tag1, "tag1");
    XUnit.description = "XUnit-compatible XML output";
  });
  var markdown = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var SUITE_PREFIX = "$";
    module.exports = Markdown;
    function Markdown(runner, options) {
      base1.call(this, runner, options);
      var level1 = 0;
      var buf1 = "";
      function title(str) {
        return Array(level1).join("#") + " " + str;
      }
      __name(title, "title");
      function mapTOC(suite3, obj) {
        var ret = obj;
        var key = SUITE_PREFIX + suite3.title;
        obj = obj[key] = obj[key] || {
          suite: suite3
        };
        suite3.suites.forEach(function(suite) {
          mapTOC(suite, obj);
        });
        return ret;
      }
      __name(mapTOC, "mapTOC");
      function stringifyTOC(obj, level) {
        ++level;
        var buf = "";
        var link;
        for (var key in obj) {
          if (key === "suite") continue;
          if (key !== SUITE_PREFIX) {
            link = " - [" + key.substring(1) + "]";
            link += "(#" + utils.slug(obj[key].suite.fullTitle()) + ")\n";
            buf += Array(level).join("  ") + link;
          }
          buf += stringifyTOC(obj[key], level);
        }
        return buf;
      }
      __name(stringifyTOC, "stringifyTOC");
      function generateTOC(suite) {
        var obj = mapTOC(suite, {});
        return stringifyTOC(obj, 0);
      }
      __name(generateTOC, "generateTOC");
      generateTOC(runner.suite);
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        ++level1;
        var slug = utils.slug(suite.fullTitle());
        buf1 += '<a name="' + slug + '"></a>\n';
        buf1 += title(suite.title) + "\n";
      });
      runner.on(EVENT_SUITE_END, function() {
        --level1;
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        var code = utils.clean(test2.body);
        buf1 += test2.title + ".\n";
        buf1 += "\n```js\n";
        buf1 += code + "\n";
        buf1 += "```\n\n";
      });
      runner.once(EVENT_RUN_END, function() {
        process$1.stdout.write("# TOC\n");
        process$1.stdout.write(generateTOC(runner.suite));
        process$1.stdout.write(buf1);
      });
    }
    __name(Markdown, "Markdown");
    Markdown.description = "GitHub Flavored Markdown";
  });
  var progress1 = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var inherits = utils.inherits;
    var color = base1.color;
    var cursor = base1.cursor;
    module.exports = Progress;
    base1.colors.progress = 90;
    function Progress(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var width = base1.window.width * 0.5 | 0;
      var total = runner.total;
      var complete = 0;
      var lastN = -1;
      options = options || {};
      var reporterOptions = options.reporterOptions || {};
      options.open = reporterOptions.open || "[";
      options.complete = reporterOptions.complete || "\u25AC";
      options.incomplete = reporterOptions.incomplete || base1.symbols.dot;
      options.close = reporterOptions.close || "]";
      options.verbose = reporterOptions.verbose || false;
      runner.on(EVENT_RUN_BEGIN, function() {
        process$1.stdout.write("\n");
        cursor.hide();
      });
      runner.on(EVENT_TEST_END, function() {
        complete++;
        var percent = complete / total;
        var n2 = width * percent | 0;
        var i2 = width - n2;
        if (n2 === lastN && !options.verbose)
          return;
        lastN = n2;
        cursor.CR();
        process$1.stdout.write("\x1B[J");
        process$1.stdout.write(color("progress", "  " + options.open));
        process$1.stdout.write(Array(n2).join(options.complete));
        process$1.stdout.write(Array(i2).join(options.incomplete));
        process$1.stdout.write(color("progress", options.close));
        if (options.verbose) process$1.stdout.write(color("progress", " " + complete + " of " + total));
      });
      runner.once(EVENT_RUN_END, function() {
        cursor.show();
        process$1.stdout.write("\n");
        self2.epilogue();
      });
    }
    __name(Progress, "Progress");
    inherits(Progress, base1);
    Progress.description = "a progress bar";
  });
  var landing = createCommonjsModule(function(module, exports) {
    var inherits = utils.inherits;
    var constants = runner1.constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var STATE_FAILED = runnable1.constants.STATE_FAILED;
    var cursor = base1.cursor;
    var color = base1.color;
    module.exports = Landing;
    base1.colors.plane = 0;
    base1.colors["plane crash"] = 31;
    base1.colors.runway = 90;
    function Landing(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var width = base1.window.width * 0.75 | 0;
      var stream = process$1.stdout;
      var plane = color("plane", "\u2708");
      var crashed = -1;
      var n2 = 0;
      var total = 0;
      function runway() {
        var buf = Array(width).join("-");
        return "  " + color("runway", buf);
      }
      __name(runway, "runway");
      runner.on(EVENT_RUN_BEGIN, function() {
        stream.write("\n\n\n  ");
        cursor.hide();
      });
      runner.on(EVENT_TEST_END, function(test2) {
        var col = crashed === -1 ? width * ++n2 / ++total | 0 : crashed;
        if (test2.state === STATE_FAILED) {
          plane = color("plane crash", "\u2708");
          crashed = col;
        }
        stream.write("\x1B[" + (width + 1) + "D\x1B[2A");
        stream.write(runway());
        stream.write("\n  ");
        stream.write(color("runway", Array(col).join("\u22C5")));
        stream.write(plane);
        stream.write(color("runway", Array(width - col).join("\u22C5") + "\n"));
        stream.write(runway());
        stream.write("\x1B[0m");
      });
      runner.once(EVENT_RUN_END, function() {
        cursor.show();
        process$1.stdout.write("\n");
        self2.epilogue();
      });
      process$1.once("SIGINT", function() {
        cursor.show();
        nextTick$1(function() {
          process$1.kill(process$1.pid, "SIGINT");
        });
      });
    }
    __name(Landing, "Landing");
    inherits(Landing, base1);
    Landing.description = "Unicode landing strip";
  });
  var jsonStream = createCommonjsModule(function(module, exports) {
    var constants = runner1.constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    module.exports = JSONStream;
    function JSONStream(runner, options) {
      base1.call(this, runner, options);
      var self2 = this;
      var total = runner.total;
      runner.once(EVENT_RUN_BEGIN, function() {
        writeEvent([
          "start",
          {
            total
          }
        ]);
      });
      runner.on(EVENT_TEST_PASS, function(test2) {
        writeEvent([
          "pass",
          clean(test2)
        ]);
      });
      runner.on(EVENT_TEST_FAIL, function(test2, err) {
        test2 = clean(test2);
        test2.err = err.message;
        test2.stack = err.stack || null;
        writeEvent([
          "fail",
          test2
        ]);
      });
      runner.once(EVENT_RUN_END, function() {
        writeEvent([
          "end",
          self2.stats
        ]);
      });
    }
    __name(JSONStream, "JSONStream");
    function writeEvent(event) {
      process$1.stdout.write(JSON.stringify(event) + "\n");
    }
    __name(writeEvent, "writeEvent");
    function clean(test2) {
      return {
        title: test2.title,
        fullTitle: test2.fullTitle(),
        file: test2.file,
        duration: test2.duration,
        currentRetry: test2.currentRetry(),
        speed: test2.speed
      };
    }
    __name(clean, "clean");
    JSONStream.description = "newline delimited JSON events";
  });
  var reporters = createCommonjsModule(function(module, exports) {
    exports.Base = exports.base = base1;
    exports.Dot = exports.dot = dot;
    exports.Doc = exports.doc = doc;
    exports.TAP = exports.tap = tap;
    exports.JSON = exports.json = json1;
    exports.HTML = exports.html = html1;
    exports.List = exports.list = list1;
    exports.Min = exports.min = min1;
    exports.Spec = exports.spec = spec;
    exports.Nyan = exports.nyan = nyan;
    exports.XUnit = exports.xunit = xunit;
    exports.Markdown = exports.markdown = markdown;
    exports.Progress = exports.progress = progress1;
    exports.Landing = exports.landing = landing;
    exports.JSONStream = exports["json-stream"] = jsonStream;
  });
  var name1 = "mocha";
  var version = "9.1.3";
  var homepage = "https://mochajs.org/";
  var notifyLogo = "https://ibin.co/4QuRuGjXvl36.png";
  var _package = {
    name: name1,
    version,
    homepage,
    notifyLogo
  };
  var _package$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    name: name1,
    version,
    homepage,
    notifyLogo,
    "default": _package
  });
  var require$$9 = getCjsExportFromNamespace(_package$1);
  var Date$3 = commonjsGlobal.Date;
  var setTimeout$2 = commonjsGlobal.setTimeout;
  var EVENT_RUN_END$1 = runner1.constants.EVENT_RUN_END;
  var isBrowser1 = utils.isBrowser;
  var isCapable = /* @__PURE__ */ __name(function() {
    var hasNotificationSupport = "Notification" in window;
    var hasPromiseSupport = typeof Promise === "function";
    return isBrowser1() && hasNotificationSupport && hasPromiseSupport;
  }, "isCapable");
  var notify = /* @__PURE__ */ __name(function(runner) {
    var promise = isPermitted();
    var sendNotification = /* @__PURE__ */ __name(function() {
      Promise.race([
        promise,
        Promise.resolve(void 0)
      ]).then(canNotify).then(function() {
        display(runner);
      }).catch(notPermitted);
    }, "sendNotification");
    runner.once(EVENT_RUN_END$1, sendNotification);
  }, "notify");
  function isPermitted() {
    var permitted = {
      granted: /* @__PURE__ */ __name(function allow() {
        return Promise.resolve(true);
      }, "allow"),
      denied: /* @__PURE__ */ __name(function deny() {
        return Promise.resolve(false);
      }, "deny"),
      default: /* @__PURE__ */ __name(function ask() {
        return Notification.requestPermission().then(function(permission) {
          return permission === "granted";
        });
      }, "ask")
    };
    return permitted[Notification.permission]();
  }
  __name(isPermitted, "isPermitted");
  function canNotify(value) {
    if (!value) {
      var why = value === false ? "blocked" : "unacknowledged";
      var reason = "not permitted by user (" + why + ")";
      return Promise.reject(new Error(reason));
    }
    return Promise.resolve();
  }
  __name(canNotify, "canNotify");
  function display(runner) {
    var stats = runner.stats;
    var symbol = {
      cross: "\u274C",
      tick: "\u2705"
    };
    var logo = require$$9.notifyLogo;
    var _message;
    var message;
    var title;
    if (stats.failures) {
      _message = stats.failures + " of " + stats.tests + " tests failed";
      message = symbol.cross + " " + _message;
      title = "Failed";
    } else {
      _message = stats.passes + " tests passed in " + stats.duration + "ms";
      message = symbol.tick + " " + _message;
      title = "Passed";
    }
    var options = {
      badge: logo,
      body: message,
      dir: "ltr",
      icon: logo,
      lang: "en-US",
      name: "mocha",
      requireInteraction: false,
      timestamp: Date$3.now()
    };
    var notification = new Notification(title, options);
    var FORCE_DURATION = 4e3;
    setTimeout$2(notification.close.bind(notification), FORCE_DURATION);
  }
  __name(display, "display");
  function notPermitted(err) {
    console.error("notification error:", err.message);
  }
  __name(notPermitted, "notPermitted");
  var growl = {
    isCapable,
    notify
  };
  var diff1 = true;
  var extension = [
    "js",
    "cjs",
    "mjs"
  ];
  var reporter1 = "spec";
  var slow = 75;
  var timeout1 = 2e3;
  var ui1 = "bdd";
  var mocharc$1 = {
    diff: diff1,
    extension,
    "package": "./package.json",
    reporter: reporter1,
    slow,
    timeout: timeout1,
    ui: ui1,
    "watch-ignore": [
      "node_modules",
      ".git"
    ]
  };
  var mocharc$2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    diff: diff1,
    extension,
    reporter: reporter1,
    slow,
    timeout: timeout1,
    ui: ui1,
    "default": mocharc$1
  });
  var constants1 = runner1.constants;
  var EVENT_TEST_PASS1 = constants1.EVENT_TEST_PASS;
  var EVENT_TEST_FAIL1 = constants1.EVENT_TEST_FAIL;
  var EVENT_SUITE_BEGIN1 = constants1.EVENT_SUITE_BEGIN;
  var EVENT_RUN_BEGIN1 = constants1.EVENT_RUN_BEGIN;
  var EVENT_TEST_PENDING1 = constants1.EVENT_TEST_PENDING;
  var EVENT_RUN_END1 = constants1.EVENT_RUN_END;
  var EVENT_TEST_END1 = constants1.EVENT_TEST_END;
  var Date$2 = commonjsGlobal.Date;
  function createStatsCollector(runner) {
    var stats = {
      suites: 0,
      tests: 0,
      passes: 0,
      pending: 0,
      failures: 0
    };
    if (!runner) throw new TypeError("Missing runner argument");
    runner.stats = stats;
    runner.once(EVENT_RUN_BEGIN1, function() {
      stats.start = new Date$2();
    });
    runner.on(EVENT_SUITE_BEGIN1, function(suite) {
      suite.root || stats.suites++;
    });
    runner.on(EVENT_TEST_PASS1, function() {
      stats.passes++;
    });
    runner.on(EVENT_TEST_FAIL1, function() {
      stats.failures++;
    });
    runner.on(EVENT_TEST_PENDING1, function() {
      stats.pending++;
    });
    runner.on(EVENT_TEST_END1, function() {
      stats.tests++;
    });
    runner.once(EVENT_RUN_END1, function() {
      stats.end = new Date$2();
      stats.duration = stats.end - stats.start;
    });
  }
  __name(createStatsCollector, "createStatsCollector");
  var statsCollector = createStatsCollector;
  var createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;
  var isString1 = utils.isString;
  const { MOCHA_ID_PROP_NAME: MOCHA_ID_PROP_NAME1 } = utils.constants;
  var test1 = Test;
  function Test(title, fn) {
    if (!isString1(title)) throw createInvalidArgumentTypeError('Test argument "title" should be a string. Received type "' + typeof title + '"', "title", "string");
    this.type = "test";
    runnable1.call(this, title, fn);
    this.reset();
  }
  __name(Test, "Test");
  utils.inherits(Test, runnable1);
  Test.prototype.reset = function() {
    runnable1.prototype.reset.call(this);
    this.pending = !this.fn;
    delete this.state;
  };
  Test.prototype.retriedTest = function(n2) {
    if (!arguments.length) return this._retriedTest;
    this._retriedTest = n2;
  };
  Test.prototype.markOnly = function() {
    this.parent.appendOnlyTest(this);
  };
  Test.prototype.clone = function() {
    var test2 = new Test(this.title, this.fn);
    test2.timeout(this.timeout());
    test2.slow(this.slow());
    test2.retries(this.retries());
    test2.currentRetry(this.currentRetry());
    test2.retriedTest(this.retriedTest() || this);
    test2.globals(this.globals());
    test2.parent = this.parent;
    test2.file = this.file;
    test2.ctx = this.ctx;
    return test2;
  };
  Test.prototype.serialize = /* @__PURE__ */ __name(function serialize() {
    return {
      $$currentRetry: this._currentRetry,
      $$fullTitle: this.fullTitle(),
      $$isPending: Boolean(this.pending),
      $$retriedTest: this._retriedTest || null,
      $$slow: this._slow,
      $$titlePath: this.titlePath(),
      body: this.body,
      duration: this.duration,
      err: this.err,
      parent: {
        $$fullTitle: this.parent.fullTitle(),
        [MOCHA_ID_PROP_NAME1]: this.parent.id
      },
      speed: this.speed,
      state: this.state,
      title: this.title,
      type: this.type,
      file: this.file,
      [MOCHA_ID_PROP_NAME1]: this.id
    };
  }, "serialize");
  var createMissingArgumentError = errors.createMissingArgumentError;
  var createUnsupportedError1 = errors.createUnsupportedError;
  var createForbiddenExclusivityError = errors.createForbiddenExclusivityError;
  var common = /* @__PURE__ */ __name(function(suites, context2, mocha2) {
    function shouldBeTested(suite) {
      return !mocha2.options.grep || mocha2.options.grep && mocha2.options.grep.test(suite.fullTitle()) && !mocha2.options.invert;
    }
    __name(shouldBeTested, "shouldBeTested");
    return {
      /**
      * This is only present if flag --delay is passed into Mocha. It triggers
      * root suite execution.
      *
      * @param {Suite} suite The root suite.
      * @return {Function} A function which runs the root suite
      */
      runWithSuite: /* @__PURE__ */ __name(function runWithSuite(suite) {
        return /* @__PURE__ */ __name(function run() {
          suite.run();
        }, "run");
      }, "runWithSuite"),
      /**
      * Execute before running tests.
      *
      * @param {string} name
      * @param {Function} fn
      */
      before: /* @__PURE__ */ __name(function(name, fn) {
        suites[0].beforeAll(name, fn);
      }, "before"),
      /**
      * Execute after running tests.
      *
      * @param {string} name
      * @param {Function} fn
      */
      after: /* @__PURE__ */ __name(function(name, fn) {
        suites[0].afterAll(name, fn);
      }, "after"),
      /**
      * Execute before each test case.
      *
      * @param {string} name
      * @param {Function} fn
      */
      beforeEach: /* @__PURE__ */ __name(function(name, fn) {
        suites[0].beforeEach(name, fn);
      }, "beforeEach"),
      /**
      * Execute after each test case.
      *
      * @param {string} name
      * @param {Function} fn
      */
      afterEach: /* @__PURE__ */ __name(function(name, fn) {
        suites[0].afterEach(name, fn);
      }, "afterEach"),
      suite: {
        /**
        * Create an exclusive Suite; convenience function
        * See docstring for create() below.
        *
        * @param {Object} opts
        * @returns {Suite}
        */
        only: /* @__PURE__ */ __name(function only(opts) {
          if (mocha2.options.forbidOnly) throw createForbiddenExclusivityError(mocha2);
          opts.isOnly = true;
          return this.create(opts);
        }, "only"),
        /**
        * Create a Suite, but skip it; convenience function
        * See docstring for create() below.
        *
        * @param {Object} opts
        * @returns {Suite}
        */
        skip: /* @__PURE__ */ __name(function skip(opts) {
          opts.pending = true;
          return this.create(opts);
        }, "skip"),
        /**
        * Creates a suite.
        *
        * @param {Object} opts Options
        * @param {string} opts.title Title of Suite
        * @param {Function} [opts.fn] Suite Function (not always applicable)
        * @param {boolean} [opts.pending] Is Suite pending?
        * @param {string} [opts.file] Filepath where this Suite resides
        * @param {boolean} [opts.isOnly] Is Suite exclusive?
        * @returns {Suite}
        */
        create: /* @__PURE__ */ __name(function create(opts) {
          var suite$1 = suite1.create(suites[0], opts.title);
          suite$1.pending = Boolean(opts.pending);
          suite$1.file = opts.file;
          suites.unshift(suite$1);
          if (opts.isOnly) suite$1.markOnly();
          if (suite$1.pending && mocha2.options.forbidPending && shouldBeTested(suite$1)) throw createUnsupportedError1("Pending test forbidden");
          if (typeof opts.fn === "function") {
            opts.fn.call(suite$1);
            suites.shift();
          } else if (typeof opts.fn === "undefined" && !suite$1.pending) throw createMissingArgumentError('Suite "' + suite$1.fullTitle() + '" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.', "callback", "function");
          else if (!opts.fn && suite$1.pending) suites.shift();
          return suite$1;
        }, "create")
      },
      test: {
        /**
        * Exclusive test-case.
        *
        * @param {Object} mocha
        * @param {Function} test
        * @returns {*}
        */
        only: /* @__PURE__ */ __name(function(mocha, test2) {
          if (mocha.options.forbidOnly) throw createForbiddenExclusivityError(mocha);
          test2.markOnly();
          return test2;
        }, "only"),
        /**
        * Pending test case.
        *
        * @param {string} title
        */
        skip: /* @__PURE__ */ __name(function(title) {
          context2.test(title);
        }, "skip")
      }
    };
  }, "common");
  var EVENT_FILE_PRE_REQUIRE$2 = suite1.constants.EVENT_FILE_PRE_REQUIRE;
  var bdd$1 = /* @__PURE__ */ __name(function bddInterface(suite4) {
    var suites = [
      suite4
    ];
    suite4.on(EVENT_FILE_PRE_REQUIRE$2, function(context2, file, mocha) {
      var common$1 = common(suites, context2, mocha);
      context2.before = common$1.before;
      context2.after = common$1.after;
      context2.beforeEach = common$1.beforeEach;
      context2.afterEach = common$1.afterEach;
      context2.run = mocha.options.delay && common$1.runWithSuite(suite4);
      context2.describe = context2.context = function(title, fn) {
        return common$1.suite.create({
          title,
          file,
          fn
        });
      };
      context2.xdescribe = context2.xcontext = context2.describe.skip = function(title, fn) {
        return common$1.suite.skip({
          title,
          file,
          fn
        });
      };
      context2.describe.only = function(title, fn) {
        return common$1.suite.only({
          title,
          file,
          fn
        });
      };
      context2.it = context2.specify = function(title, fn) {
        var suite = suites[0];
        if (suite.isPending()) fn = null;
        var test$1 = new test1(title, fn);
        test$1.file = file;
        suite.addTest(test$1);
        return test$1;
      };
      context2.it.only = function(title, fn) {
        return common$1.test.only(mocha, context2.it(title, fn));
      };
      context2.xit = context2.xspecify = context2.it.skip = function(title) {
        return context2.it(title);
      };
    });
  }, "bddInterface");
  var description$3 = "BDD or RSpec style [default]";
  bdd$1.description = description$3;
  var EVENT_FILE_PRE_REQUIRE$1 = suite1.constants.EVENT_FILE_PRE_REQUIRE;
  var tdd$1 = /* @__PURE__ */ __name(function(suite5) {
    var suites = [
      suite5
    ];
    suite5.on(EVENT_FILE_PRE_REQUIRE$1, function(context2, file, mocha) {
      var common$1 = common(suites, context2, mocha);
      context2.setup = common$1.beforeEach;
      context2.teardown = common$1.afterEach;
      context2.suiteSetup = common$1.before;
      context2.suiteTeardown = common$1.after;
      context2.run = mocha.options.delay && common$1.runWithSuite(suite5);
      context2.suite = function(title, fn) {
        return common$1.suite.create({
          title,
          file,
          fn
        });
      };
      context2.suite.skip = function(title, fn) {
        return common$1.suite.skip({
          title,
          file,
          fn
        });
      };
      context2.suite.only = function(title, fn) {
        return common$1.suite.only({
          title,
          file,
          fn
        });
      };
      context2.test = function(title, fn) {
        var suite = suites[0];
        if (suite.isPending()) fn = null;
        var test$1 = new test1(title, fn);
        test$1.file = file;
        suite.addTest(test$1);
        return test$1;
      };
      context2.test.only = function(title, fn) {
        return common$1.test.only(mocha, context2.test(title, fn));
      };
      context2.test.skip = common$1.test.skip;
    });
  }, "tdd$1");
  var description$2 = `traditional "suite"/"test" instead of BDD's "describe"/"it"`;
  tdd$1.description = description$2;
  var EVENT_FILE_PRE_REQUIRE1 = suite1.constants.EVENT_FILE_PRE_REQUIRE;
  var qunit$1 = /* @__PURE__ */ __name(function qUnitInterface(suite) {
    var suites = [
      suite
    ];
    suite.on(EVENT_FILE_PRE_REQUIRE1, function(context2, file, mocha) {
      var common$1 = common(suites, context2, mocha);
      context2.before = common$1.before;
      context2.after = common$1.after;
      context2.beforeEach = common$1.beforeEach;
      context2.afterEach = common$1.afterEach;
      context2.run = mocha.options.delay && common$1.runWithSuite(suite);
      context2.suite = function(title) {
        if (suites.length > 1) suites.shift();
        return common$1.suite.create({
          title,
          file,
          fn: false
        });
      };
      context2.suite.only = function(title) {
        if (suites.length > 1) suites.shift();
        return common$1.suite.only({
          title,
          file,
          fn: false
        });
      };
      context2.test = function(title, fn) {
        var test$1 = new test1(title, fn);
        test$1.file = file;
        suites[0].addTest(test$1);
        return test$1;
      };
      context2.test.only = function(title, fn) {
        return common$1.test.only(mocha, context2.test(title, fn));
      };
      context2.test.skip = common$1.test.skip;
    });
  }, "qUnitInterface");
  var description$1 = "QUnit style";
  qunit$1.description = description$1;
  var exports$2 = /* @__PURE__ */ __name(function(suite$11) {
    var suites = [
      suite$11
    ];
    suite$11.on(suite1.constants.EVENT_FILE_REQUIRE, visit);
    function visit(obj, file) {
      var suite$1;
      for (var key in obj) if (typeof obj[key] === "function") {
        var fn = obj[key];
        switch (key) {
          case "before":
            suites[0].beforeAll(fn);
            break;
          case "after":
            suites[0].afterAll(fn);
            break;
          case "beforeEach":
            suites[0].beforeEach(fn);
            break;
          case "afterEach":
            suites[0].afterEach(fn);
            break;
          default:
            var test$1 = new test1(key, fn);
            test$1.file = file;
            suites[0].addTest(test$1);
        }
      } else {
        suite$1 = suite1.create(suites[0], key);
        suites.unshift(suite$1);
        visit(obj[key], file);
        suites.shift();
      }
    }
    __name(visit, "visit");
  }, "exports$2");
  var description = 'Node.js module ("exports") style';
  exports$2.description = description;
  var bdd = bdd$1;
  var tdd = tdd$1;
  var qunit = qunit$1;
  var exports$1 = exports$2;
  var interfaces = {
    bdd,
    tdd,
    qunit,
    exports: exports$1
  };
  var context1 = Context1;
  function Context1() {
  }
  __name(Context1, "Context1");
  Context1.prototype.runnable = function(runnable) {
    if (!arguments.length) return this._runnable;
    this.test = this._runnable = runnable;
    return this;
  };
  Context1.prototype.timeout = function(ms) {
    if (!arguments.length) return this.runnable().timeout();
    this.runnable().timeout(ms);
    return this;
  };
  Context1.prototype.slow = function(ms) {
    if (!arguments.length) return this.runnable().slow();
    this.runnable().slow(ms);
    return this;
  };
  Context1.prototype.skip = function() {
    this.runnable().skip();
  };
  Context1.prototype.retries = function(n2) {
    if (!arguments.length) return this.runnable().retries();
    this.runnable().retries(n2);
    return this;
  };
  var mocharc = getCjsExportFromNamespace(mocharc$2);
  var mocha$1 = createCommonjsModule(function(module, exports) {
    const { warn, createInvalidReporterError, createInvalidInterfaceError, createMochaInstanceAlreadyDisposedError, createMochaInstanceAlreadyRunningError, createUnsupportedError } = errors;
    const { EVENT_FILE_PRE_REQUIRE, EVENT_FILE_POST_REQUIRE, EVENT_FILE_REQUIRE } = suite1.constants;
    var debug = browser("mocha:mocha");
    exports = module.exports = Mocha;
    var mochaStates = utils.defineConstants({
      /**
      * Initial state of the mocha instance
      * @private
      */
      INIT: "init",
      /**
      * Mocha instance is running tests
      * @private
      */
      RUNNING: "running",
      /**
      * Mocha instance is done running tests and references to test functions and hooks are cleaned.
      * You can reset this state by unloading the test files.
      * @private
      */
      REFERENCES_CLEANED: "referencesCleaned",
      /**
      * Mocha instance is disposed and can no longer be used.
      * @private
      */
      DISPOSED: "disposed"
    });
    if (!utils.isBrowser() && typeof module.paths !== "undefined") {
      var cwd = utils.cwd();
      module.paths.push(cwd, path1.join(cwd, "node_modules"));
    }
    exports.utils = utils;
    exports.interfaces = interfaces;
    exports.reporters = reporters;
    exports.Runnable = runnable1;
    exports.Context = context1;
    exports.Runner = runner1;
    exports.Suite = suite1;
    exports.Hook = hook1;
    exports.Test = test1;
    let currentContext;
    exports.afterEach = function(...args) {
      return (currentContext.afterEach || currentContext.teardown).apply(this, args);
    };
    exports.after = function(...args) {
      return (currentContext.after || currentContext.suiteTeardown).apply(this, args);
    };
    exports.beforeEach = function(...args) {
      return (currentContext.beforeEach || currentContext.setup).apply(this, args);
    };
    exports.before = function(...args) {
      return (currentContext.before || currentContext.suiteSetup).apply(this, args);
    };
    exports.describe = function(...args) {
      return (currentContext.describe || currentContext.suite).apply(this, args);
    };
    exports.describe.only = function(...args) {
      return (currentContext.describe || currentContext.suite).only.apply(this, args);
    };
    exports.describe.skip = function(...args) {
      return (currentContext.describe || currentContext.suite).skip.apply(this, args);
    };
    exports.it = function(...args) {
      return (currentContext.it || currentContext.test).apply(this, args);
    };
    exports.it.only = function(...args) {
      return (currentContext.it || currentContext.test).only.apply(this, args);
    };
    exports.it.skip = function(...args) {
      return (currentContext.it || currentContext.test).skip.apply(this, args);
    };
    exports.xdescribe = exports.describe.skip;
    exports.xit = exports.it.skip;
    exports.setup = exports.beforeEach;
    exports.suiteSetup = exports.before;
    exports.suiteTeardown = exports.after;
    exports.suite = exports.describe;
    exports.teardown = exports.afterEach;
    exports.test = exports.it;
    exports.run = function(...args) {
      return currentContext.run.apply(this, args);
    };
    function Mocha(options = {}) {
      options = {
        ...mocharc,
        ...options
      };
      this.files = [];
      this.options = options;
      this.suite = new exports.Suite("", new exports.Context(), true);
      this._cleanReferencesAfterRun = true;
      this._state = mochaStates.INIT;
      this.grep(options.grep).fgrep(options.fgrep).ui(options.ui).reporter(
        options.reporter,
        options.reporterOption || options.reporterOptions
        // for backwards compability
      ).slow(options.slow).global(options.global);
      if (typeof options.timeout !== "undefined") this.timeout(options.timeout === false ? 0 : options.timeout);
      if ("retries" in options) this.retries(options.retries);
      [
        "allowUncaught",
        "asyncOnly",
        "bail",
        "checkLeaks",
        "color",
        "delay",
        "diff",
        "dryRun",
        "failZero",
        "forbidOnly",
        "forbidPending",
        "fullTrace",
        "growl",
        "inlineDiffs",
        "invert"
      ].forEach(function(opt) {
        if (options[opt]) this[opt]();
      }, this);
      if (options.rootHooks) this.rootHooks(options.rootHooks);
      this._runnerClass = exports.Runner;
      this._lazyLoadFiles = false;
      this.isWorker = Boolean(options.isWorker);
      this.globalSetup(options.globalSetup).globalTeardown(options.globalTeardown).enableGlobalSetup(options.enableGlobalSetup).enableGlobalTeardown(options.enableGlobalTeardown);
      if (options.parallel && (typeof options.jobs === "undefined" || options.jobs > 1)) {
        debug("attempting to enable parallel mode");
        this.parallelMode(true);
      }
    }
    __name(Mocha, "Mocha");
    Mocha.prototype.bail = function(bail) {
      this.suite.bail(bail !== false);
      return this;
    };
    Mocha.prototype.addFile = function(file) {
      this.files.push(file);
      return this;
    };
    Mocha.prototype.reporter = function(reporterName, reporterOptions) {
      if (typeof reporterName === "function") this._reporter = reporterName;
      else {
        reporterName = reporterName || "spec";
        var reporter;
        if (reporters[reporterName]) reporter = reporters[reporterName];
        if (!reporter) try {
          reporter = commonjsRequire(reporterName);
        } catch (err) {
          if (err.code === "MODULE_NOT_FOUND")
            try {
              reporter = commonjsRequire(path1.resolve(utils.cwd(), reporterName));
            } catch (_err) {
              _err.code === "MODULE_NOT_FOUND" ? warn(`'${reporterName}' reporter not found`) : warn(`'${reporterName}' reporter blew up with error:
 ${err.stack}`);
            }
          else warn(`'${reporterName}' reporter blew up with error:
 ${err.stack}`);
        }
        if (!reporter) throw createInvalidReporterError(`invalid reporter '${reporterName}'`, reporterName);
        this._reporter = reporter;
      }
      this.options.reporterOption = reporterOptions;
      this.options.reporterOptions = reporterOptions;
      return this;
    };
    Mocha.prototype.ui = function(ui) {
      var bindInterface;
      if (typeof ui === "function") bindInterface = ui;
      else {
        ui = ui || "bdd";
        bindInterface = exports.interfaces[ui];
        if (!bindInterface) try {
          bindInterface = commonjsRequire(ui);
        } catch (err) {
          throw createInvalidInterfaceError(`invalid interface '${ui}'`, ui);
        }
      }
      bindInterface(this.suite);
      this.suite.on(EVENT_FILE_PRE_REQUIRE, function(context2) {
        currentContext = context2;
      });
      return this;
    };
    Mocha.prototype.loadFiles = function(fn) {
      var self2 = this;
      var suite = this.suite;
      this.files.forEach(function(file) {
        file = path1.resolve(file);
        suite.emit(EVENT_FILE_PRE_REQUIRE, commonjsGlobal, file, self2);
        suite.emit(EVENT_FILE_REQUIRE, commonjsRequire(), file, self2);
        suite.emit(EVENT_FILE_POST_REQUIRE, commonjsGlobal, file, self2);
      });
      fn && fn();
    };
    Mocha.prototype.loadFilesAsync = function() {
      var self2 = this;
      var suite = this.suite;
      this.lazyLoadFiles(true);
      return require$$10.loadFilesAsync(this.files, function(file) {
        suite.emit(EVENT_FILE_PRE_REQUIRE, commonjsGlobal, file, self2);
      }, function(file, resultModule) {
        suite.emit(EVENT_FILE_REQUIRE, resultModule, file, self2);
        suite.emit(EVENT_FILE_POST_REQUIRE, commonjsGlobal, file, self2);
      });
    };
    Mocha.unloadFile = function(file) {
      if (utils.isBrowser()) throw createUnsupportedError("unloadFile() is only suported in a Node.js environment");
      return require$$10.unloadFile(file);
    };
    Mocha.prototype.unloadFiles = function() {
      if (this._state === mochaStates.DISPOSED) throw createMochaInstanceAlreadyDisposedError("Mocha instance is already disposed, it cannot be used again.", this._cleanReferencesAfterRun, this);
      this.files.forEach(function(file) {
        Mocha.unloadFile(file);
      });
      this._state = mochaStates.INIT;
      return this;
    };
    Mocha.prototype.fgrep = function(str) {
      if (!str) return this;
      return this.grep(new RegExp(escapeStringRegexp(str)));
    };
    Mocha.prototype.grep = function(re) {
      if (utils.isString(re)) {
        var arg = re.match(/^\/(.*)\/([gimy]{0,4})$|.*/);
        this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);
      } else this.options.grep = re;
      return this;
    };
    Mocha.prototype.invert = function() {
      this.options.invert = true;
      return this;
    };
    Mocha.prototype.checkLeaks = function(checkLeaks) {
      this.options.checkLeaks = checkLeaks !== false;
      return this;
    };
    Mocha.prototype.cleanReferencesAfterRun = function(cleanReferencesAfterRun) {
      this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;
      return this;
    };
    Mocha.prototype.dispose = function() {
      if (this._state === mochaStates.RUNNING) throw createMochaInstanceAlreadyRunningError("Cannot dispose while the mocha instance is still running tests.");
      this.unloadFiles();
      this._previousRunner && this._previousRunner.dispose();
      this.suite.dispose();
      this._state = mochaStates.DISPOSED;
    };
    Mocha.prototype.fullTrace = function(fullTrace) {
      this.options.fullTrace = fullTrace !== false;
      return this;
    };
    Mocha.prototype.growl = function() {
      this.options.growl = this.isGrowlCapable();
      if (!this.options.growl) {
        var detail = utils.isBrowser() ? "notification support not available in this browser..." : "notification support prerequisites not installed...";
        console.error(detail + " cannot enable!");
      }
      return this;
    };
    Mocha.prototype.isGrowlCapable = growl.isCapable;
    Mocha.prototype._growl = growl.notify;
    Mocha.prototype.global = function(global2) {
      this.options.global = (this.options.global || []).concat(global2).filter(Boolean).filter(function(elt, idx, arr) {
        return arr.indexOf(elt) === idx;
      });
      return this;
    };
    Mocha.prototype.globals = Mocha.prototype.global;
    Mocha.prototype.color = function(color) {
      this.options.color = color !== false;
      return this;
    };
    Mocha.prototype.inlineDiffs = function(inlineDiffs) {
      this.options.inlineDiffs = inlineDiffs !== false;
      return this;
    };
    Mocha.prototype.diff = function(diff) {
      this.options.diff = diff !== false;
      return this;
    };
    Mocha.prototype.timeout = function(msecs) {
      this.suite.timeout(msecs);
      return this;
    };
    Mocha.prototype.retries = function(retry) {
      this.suite.retries(retry);
      return this;
    };
    Mocha.prototype.slow = function(msecs) {
      this.suite.slow(msecs);
      return this;
    };
    Mocha.prototype.asyncOnly = function(asyncOnly) {
      this.options.asyncOnly = asyncOnly !== false;
      return this;
    };
    Mocha.prototype.noHighlighting = function() {
      this.options.noHighlighting = true;
      return this;
    };
    Mocha.prototype.allowUncaught = function(allowUncaught) {
      this.options.allowUncaught = allowUncaught !== false;
      return this;
    };
    Mocha.prototype.delay = /* @__PURE__ */ __name(function delay() {
      this.options.delay = true;
      return this;
    }, "delay");
    Mocha.prototype.dryRun = function(dryRun) {
      this.options.dryRun = dryRun !== false;
      return this;
    };
    Mocha.prototype.failZero = function(failZero) {
      this.options.failZero = failZero !== false;
      return this;
    };
    Mocha.prototype.forbidOnly = function(forbidOnly) {
      this.options.forbidOnly = forbidOnly !== false;
      return this;
    };
    Mocha.prototype.forbidPending = function(forbidPending) {
      this.options.forbidPending = forbidPending !== false;
      return this;
    };
    Mocha.prototype._guardRunningStateTransition = function() {
      if (this._state === mochaStates.RUNNING) throw createMochaInstanceAlreadyRunningError("Mocha instance is currently running tests, cannot start a next test run until this one is done", this);
      if (this._state === mochaStates.DISPOSED || this._state === mochaStates.REFERENCES_CLEANED) throw createMochaInstanceAlreadyDisposedError("Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.", this._cleanReferencesAfterRun, this);
    };
    Object.defineProperty(Mocha.prototype, "version", {
      value: require$$9.version,
      configurable: false,
      enumerable: true,
      writable: false
    });
    Mocha.prototype.run = function(fn) {
      this._guardRunningStateTransition();
      this._state = mochaStates.RUNNING;
      if (this._previousRunner) {
        this._previousRunner.dispose();
        this.suite.reset();
      }
      if (this.files.length && !this._lazyLoadFiles) this.loadFiles();
      var suite = this.suite;
      var options = this.options;
      options.files = this.files;
      const runner2 = new this._runnerClass(suite, {
        cleanReferencesAfterRun: this._cleanReferencesAfterRun,
        delay: options.delay,
        dryRun: options.dryRun,
        failZero: options.failZero
      });
      statsCollector(runner2);
      var reporter = new this._reporter(runner2, options);
      runner2.checkLeaks = options.checkLeaks === true;
      runner2.fullStackTrace = options.fullTrace;
      runner2.asyncOnly = options.asyncOnly;
      runner2.allowUncaught = options.allowUncaught;
      runner2.forbidOnly = options.forbidOnly;
      runner2.forbidPending = options.forbidPending;
      if (options.grep) runner2.grep(options.grep, options.invert);
      if (options.global) runner2.globals(options.global);
      if (options.growl) this._growl(runner2);
      if (options.color !== void 0) exports.reporters.Base.useColors = options.color;
      exports.reporters.Base.inlineDiffs = options.inlineDiffs;
      exports.reporters.Base.hideDiff = !options.diff;
      const done = /* @__PURE__ */ __name((failures) => {
        this._previousRunner = runner2;
        this._state = this._cleanReferencesAfterRun ? mochaStates.REFERENCES_CLEANED : mochaStates.INIT;
        fn = fn || utils.noop;
        if (typeof reporter.done === "function") reporter.done(failures, fn);
        else fn(failures);
      }, "done");
      const runAsync = /* @__PURE__ */ __name(async (runner) => {
        const context2 = this.options.enableGlobalSetup && this.hasGlobalSetupFixtures() ? await this.runGlobalSetup(runner) : {};
        const failureCount = await runner.runAsync({
          files: this.files,
          options
        });
        if (this.options.enableGlobalTeardown && this.hasGlobalTeardownFixtures()) await this.runGlobalTeardown(runner, {
          context: context2
        });
        return failureCount;
      }, "runAsync");
      runAsync(runner2).then(done);
      return runner2;
    };
    Mocha.prototype.rootHooks = /* @__PURE__ */ __name(function rootHooks({ beforeAll = [], beforeEach = [], afterAll = [], afterEach = [] } = {}) {
      beforeAll = utils.castArray(beforeAll);
      beforeEach = utils.castArray(beforeEach);
      afterAll = utils.castArray(afterAll);
      afterEach = utils.castArray(afterEach);
      beforeAll.forEach((hook) => {
        this.suite.beforeAll(hook);
      });
      beforeEach.forEach((hook) => {
        this.suite.beforeEach(hook);
      });
      afterAll.forEach((hook) => {
        this.suite.afterAll(hook);
      });
      afterEach.forEach((hook) => {
        this.suite.afterEach(hook);
      });
      return this;
    }, "rootHooks");
    Mocha.prototype.parallelMode = /* @__PURE__ */ __name(function parallelMode(enable = true) {
      if (utils.isBrowser()) throw createUnsupportedError("parallel mode is only supported in Node.js");
      const parallel = Boolean(enable);
      if (parallel === this.options.parallel && this._lazyLoadFiles && this._runnerClass !== exports.Runner) return this;
      if (this._state !== mochaStates.INIT) throw createUnsupportedError("cannot change parallel mode after having called run()");
      this.options.parallel = parallel;
      this._runnerClass = parallel ? require$$10 : exports.Runner;
      return this.lazyLoadFiles(this._lazyLoadFiles || parallel);
    }, "parallelMode");
    Mocha.prototype.lazyLoadFiles = /* @__PURE__ */ __name(function lazyLoadFiles(enable) {
      this._lazyLoadFiles = enable === true;
      debug("set lazy load to %s", enable);
      return this;
    }, "lazyLoadFiles");
    Mocha.prototype.globalSetup = /* @__PURE__ */ __name(function globalSetup(setupFns = []) {
      setupFns = utils.castArray(setupFns);
      this.options.globalSetup = setupFns;
      debug("configured %d global setup functions", setupFns.length);
      return this;
    }, "globalSetup");
    Mocha.prototype.globalTeardown = /* @__PURE__ */ __name(function globalTeardown(teardownFns = []) {
      teardownFns = utils.castArray(teardownFns);
      this.options.globalTeardown = teardownFns;
      debug("configured %d global teardown functions", teardownFns.length);
      return this;
    }, "globalTeardown");
    Mocha.prototype.runGlobalSetup = /* @__PURE__ */ __name(async function runGlobalSetup(context2 = {}) {
      const { globalSetup } = this.options;
      if (globalSetup && globalSetup.length) {
        debug("run(): global setup starting");
        await this._runGlobalFixtures(globalSetup, context2);
        debug("run(): global setup complete");
      }
      return context2;
    }, "runGlobalSetup");
    Mocha.prototype.runGlobalTeardown = /* @__PURE__ */ __name(async function runGlobalTeardown(context2 = {}) {
      const { globalTeardown } = this.options;
      if (globalTeardown && globalTeardown.length) {
        debug("run(): global teardown starting");
        await this._runGlobalFixtures(globalTeardown, context2);
      }
      debug("run(): global teardown complete");
      return context2;
    }, "runGlobalTeardown");
    Mocha.prototype._runGlobalFixtures = /* @__PURE__ */ __name(async function _runGlobalFixtures(fixtureFns = [], context2 = {}) {
      for await (const fixtureFn of fixtureFns) await fixtureFn.call(context2);
      return context2;
    }, "_runGlobalFixtures");
    Mocha.prototype.enableGlobalSetup = /* @__PURE__ */ __name(function enableGlobalSetup(enabled = true) {
      this.options.enableGlobalSetup = Boolean(enabled);
      return this;
    }, "enableGlobalSetup");
    Mocha.prototype.enableGlobalTeardown = /* @__PURE__ */ __name(function enableGlobalTeardown(enabled = true) {
      this.options.enableGlobalTeardown = Boolean(enabled);
      return this;
    }, "enableGlobalTeardown");
    Mocha.prototype.hasGlobalSetupFixtures = /* @__PURE__ */ __name(function hasGlobalSetupFixtures() {
      return Boolean(this.options.globalSetup.length);
    }, "hasGlobalSetupFixtures");
    Mocha.prototype.hasGlobalTeardownFixtures = /* @__PURE__ */ __name(function hasGlobalTeardownFixtures() {
      return Boolean(this.options.globalTeardown.length);
    }, "hasGlobalTeardownFixtures");
  });
  process$1.stdout = browserStdout({
    label: false
  });
  var mocha1 = new mocha$1({
    reporter: "html"
  });
  var Date$1 = commonjsGlobal.Date;
  var setTimeout$1 = commonjsGlobal.setTimeout;
  commonjsGlobal.setInterval;
  commonjsGlobal.clearTimeout;
  commonjsGlobal.clearInterval;
  var uncaughtExceptionHandlers = [];
  var originalOnerrorHandler = commonjsGlobal.onerror;
  process$1.removeListener = function(e2, fn) {
    if (e2 === "uncaughtException") {
      if (originalOnerrorHandler) commonjsGlobal.onerror = originalOnerrorHandler;
      else commonjsGlobal.onerror = function() {
      };
      var i2 = uncaughtExceptionHandlers.indexOf(fn);
      if (i2 !== -1) uncaughtExceptionHandlers.splice(i2, 1);
    }
  };
  process$1.listenerCount = function(name) {
    if (name === "uncaughtException") return uncaughtExceptionHandlers.length;
    return 0;
  };
  process$1.on = function(e2, fn) {
    if (e2 === "uncaughtException") {
      commonjsGlobal.onerror = function(err, url, line) {
        fn(new Error(err + " (" + url + ":" + line + ")"));
        return !mocha1.options.allowUncaught;
      };
      uncaughtExceptionHandlers.push(fn);
    }
  };
  process$1.listeners = function(e2) {
    if (e2 === "uncaughtException") return uncaughtExceptionHandlers;
    return [];
  };
  mocha1.suite.removeAllListeners("pre-require");
  var immediateQueue = [];
  var immediateTimeout;
  function timeslice() {
    var immediateStart = new Date$1().getTime();
    while (immediateQueue.length && new Date$1().getTime() - immediateStart < 100) immediateQueue.shift()();
    if (immediateQueue.length) immediateTimeout = setTimeout$1(timeslice, 0);
    else immediateTimeout = null;
  }
  __name(timeslice, "timeslice");
  mocha$1.Runner.immediately = function(callback) {
    immediateQueue.push(callback);
    if (!immediateTimeout) immediateTimeout = setTimeout$1(timeslice, 0);
  };
  mocha1.throwError = function(err) {
    uncaughtExceptionHandlers.forEach(function(fn) {
      fn(err);
    });
    throw err;
  };
  mocha1.ui = function(ui) {
    mocha$1.prototype.ui.call(this, ui);
    this.suite.emit("pre-require", commonjsGlobal, null, this);
    return this;
  };
  mocha1.setup = function(opts) {
    if (typeof opts === "string") opts = {
      ui: opts
    };
    if (opts.delay === true) this.delay();
    var self2 = this;
    Object.keys(opts).filter(function(opt) {
      return opt !== "delay";
    }).forEach(function(opt) {
      if (Object.prototype.hasOwnProperty.call(opts, opt)) self2[opt](opts[opt]);
    });
    return this;
  };
  mocha1.run = function(fn) {
    var options = mocha1.options;
    mocha1.globals("location");
    var query = parseQuery(commonjsGlobal.location.search || "");
    if (query.grep) mocha1.grep(query.grep);
    if (query.fgrep) mocha1.fgrep(query.fgrep);
    if (query.invert) mocha1.invert();
    return mocha$1.prototype.run.call(mocha1, function(err) {
      var document2 = commonjsGlobal.document;
      if (document2 && document2.getElementById("mocha") && options.noHighlighting !== true) highlightTags("code");
      if (fn) fn(err);
    });
  };
  mocha$1.process = process$1;
  commonjsGlobal.Mocha = mocha$1;
  commonjsGlobal.mocha = mocha1;
  [
    "describe",
    "context",
    "it",
    "specify",
    "xdescribe",
    "xcontext",
    "xit",
    "xspecify",
    "before",
    "beforeEach",
    "afterEach",
    "after"
  ].forEach(function(key) {
    mocha1[key] = commonjsGlobal[key];
  });
  var browserEntry = mocha1;
  return browserEntry;
});
var $3817b02937c60b41$var$commonjsGlobal = typeof window !== "undefined" ? window : typeof $parcel$global !== "undefined" ? $parcel$global : typeof self !== "undefined" ? self : {};
function $3817b02937c60b41$var$commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}
__name($3817b02937c60b41$var$commonjsRequire, "$3817b02937c60b41$var$commonjsRequire");
function $3817b02937c60b41$var$createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}
__name($3817b02937c60b41$var$createCommonjsModule, "$3817b02937c60b41$var$createCommonjsModule");
var $3817b02937c60b41$var$chai = $3817b02937c60b41$var$createCommonjsModule(function(module1, exports1) {
  (function(f2) {
    module1.exports = f2();
  })(function() {
    return (/* @__PURE__ */ (function() {
      function r1(e2, n1, t2) {
        function o2(i2, f2) {
          if (!n1[i2]) {
            if (!e2[i2]) {
              var c2 = "function" == typeof $3817b02937c60b41$var$commonjsRequire && $3817b02937c60b41$var$commonjsRequire;
              if (!f2 && c2) return c2(i2, true);
              if (u) return u(i2, true);
              var a2 = new Error("Cannot find module '" + i2 + "'");
              throw a2.code = "MODULE_NOT_FOUND", a2;
            }
            var p2 = n1[i2] = {
              exports: {}
            };
            e2[i2][0].call(p2.exports, function(r2) {
              var n2 = e2[i2][1][r2];
              return o2(n2 || r2);
            }, p2, p2.exports, r1, e2, n1, t2);
          }
          return n1[i2].exports;
        }
        __name(o2, "o");
        for (var u = "function" == typeof $3817b02937c60b41$var$commonjsRequire && $3817b02937c60b41$var$commonjsRequire, i1 = 0; i1 < t2.length; i1++) o2(t2[i1]);
        return o2;
      }
      __name(r1, "r1");
      return r1;
    })())({
      1: [
        function(require2, module, exports) {
          module.exports = require2("./lib/chai");
        },
        {
          "./lib/chai": 2
        }
      ],
      2: [
        function(require2, module, exports) {
          var used = [];
          exports.version = "4.2.0";
          exports.AssertionError = require2("assertion-error");
          var util = require2("./chai/utils");
          exports.use = function(fn) {
            if (!~used.indexOf(fn)) {
              fn(exports, util);
              used.push(fn);
            }
            return exports;
          };
          exports.util = util;
          var config = require2("./chai/config");
          exports.config = config;
          var assertion = require2("./chai/assertion");
          exports.use(assertion);
          var core = require2("./chai/core/assertions");
          exports.use(core);
          var expect = require2("./chai/interface/expect");
          exports.use(expect);
          var should = require2("./chai/interface/should");
          exports.use(should);
          var assert = require2("./chai/interface/assert");
          exports.use(assert);
        },
        {
          "./chai/assertion": 3,
          "./chai/config": 4,
          "./chai/core/assertions": 5,
          "./chai/interface/assert": 6,
          "./chai/interface/expect": 7,
          "./chai/interface/should": 8,
          "./chai/utils": 22,
          "assertion-error": 33
        }
      ],
      3: [
        function(require2, module, exports) {
          var config = require2("./config");
          module.exports = function(_chai, util) {
            var AssertionError = _chai.AssertionError, flag = util.flag;
            _chai.Assertion = Assertion;
            function Assertion(obj, msg, ssfi, lockSsfi) {
              flag(this, "ssfi", ssfi || Assertion);
              flag(this, "lockSsfi", lockSsfi);
              flag(this, "object", obj);
              flag(this, "message", msg);
              return util.proxify(this);
            }
            __name(Assertion, "Assertion");
            Object.defineProperty(Assertion, "includeStack", {
              get: /* @__PURE__ */ __name(function() {
                console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
                return config.includeStack;
              }, "get"),
              set: /* @__PURE__ */ __name(function(value) {
                console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
                config.includeStack = value;
              }, "set")
            });
            Object.defineProperty(Assertion, "showDiff", {
              get: /* @__PURE__ */ __name(function() {
                console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
                return config.showDiff;
              }, "get"),
              set: /* @__PURE__ */ __name(function(value) {
                console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
                config.showDiff = value;
              }, "set")
            });
            Assertion.addProperty = function(name, fn) {
              util.addProperty(this.prototype, name, fn);
            };
            Assertion.addMethod = function(name, fn) {
              util.addMethod(this.prototype, name, fn);
            };
            Assertion.addChainableMethod = function(name, fn, chainingBehavior) {
              util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
            };
            Assertion.overwriteProperty = function(name, fn) {
              util.overwriteProperty(this.prototype, name, fn);
            };
            Assertion.overwriteMethod = function(name, fn) {
              util.overwriteMethod(this.prototype, name, fn);
            };
            Assertion.overwriteChainableMethod = function(name, fn, chainingBehavior) {
              util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
            };
            Assertion.prototype.assert = function(expr, msg, negateMsg, expected, _actual, showDiff) {
              var ok = util.test(this, arguments);
              if (false !== showDiff) showDiff = true;
              if (void 0 === expected && void 0 === _actual) showDiff = false;
              if (true !== config.showDiff) showDiff = false;
              if (!ok) {
                msg = util.getMessage(this, arguments);
                var actual = util.getActual(this, arguments);
                throw new AssertionError(msg, {
                  actual,
                  expected,
                  showDiff
                }, config.includeStack ? this.assert : flag(this, "ssfi"));
              }
            };
            Object.defineProperty(Assertion.prototype, "_obj", {
              get: /* @__PURE__ */ __name(function() {
                return flag(this, "object");
              }, "get"),
              set: /* @__PURE__ */ __name(function(val) {
                flag(this, "object", val);
              }, "set")
            });
          };
        },
        {
          "./config": 4
        }
      ],
      4: [
        function(require2, module, exports) {
          module.exports = {
            /**
            * ### config.includeStack
            *
            * User configurable property, influences whether stack trace
            * is included in Assertion error message. Default of false
            * suppresses stack trace in the error message.
            *
            *     chai.config.includeStack = true;  // enable stack on error
            *
            * @param {Boolean}
            * @api public
            */
            includeStack: false,
            /**
            * ### config.showDiff
            *
            * User configurable property, influences whether or not
            * the `showDiff` flag should be included in the thrown
            * AssertionErrors. `false` will always be `false`; `true`
            * will be true when the assertion has requested a diff
            * be shown.
            *
            * @param {Boolean}
            * @api public
            */
            showDiff: true,
            /**
            * ### config.truncateThreshold
            *
            * User configurable property, sets length threshold for actual and
            * expected values in assertion errors. If this threshold is exceeded, for
            * example for large data structures, the value is replaced with something
            * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
            *
            * Set it to zero if you want to disable truncating altogether.
            *
            * This is especially userful when doing assertions on arrays: having this
            * set to a reasonable large value makes the failure messages readily
            * inspectable.
            *
            *     chai.config.truncateThreshold = 0;  // disable truncating
            *
            * @param {Number}
            * @api public
            */
            truncateThreshold: 40,
            /**
            * ### config.useProxy
            *
            * User configurable property, defines if chai will use a Proxy to throw
            * an error when a non-existent property is read, which protects users
            * from typos when using property-based assertions.
            *
            * Set it to false if you want to disable this feature.
            *
            *     chai.config.useProxy = false;  // disable use of Proxy
            *
            * This feature is automatically disabled regardless of this config value
            * in environments that don't support proxies.
            *
            * @param {Boolean}
            * @api public
            */
            useProxy: true,
            /**
            * ### config.proxyExcludedKeys
            *
            * User configurable property, defines which properties should be ignored
            * instead of throwing an error if they do not exist on the assertion.
            * This is only applied if the environment Chai is running in supports proxies and
            * if the `useProxy` configuration setting is enabled.
            * By default, `then` and `inspect` will not throw an error if they do not exist on the
            * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
            * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
            *
            *     // By default these keys will not throw an error if they do not exist on the assertion object
            *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
            *
            * @param {Array}
            * @api public
            */
            proxyExcludedKeys: [
              "then",
              "catch",
              "inspect",
              "toJSON"
            ]
          };
        },
        {}
      ],
      5: [
        function(require2, module, exports) {
          module.exports = function(chai, _) {
            var Assertion = chai.Assertion, AssertionError = chai.AssertionError, flag = _.flag;
            [
              "to",
              "be",
              "been",
              "is",
              "and",
              "has",
              "have",
              "with",
              "that",
              "which",
              "at",
              "of",
              "same",
              "but",
              "does",
              "still"
            ].forEach(function(chain) {
              Assertion.addProperty(chain);
            });
            Assertion.addProperty("not", function() {
              flag(this, "negate", true);
            });
            Assertion.addProperty("deep", function() {
              flag(this, "deep", true);
            });
            Assertion.addProperty("nested", function() {
              flag(this, "nested", true);
            });
            Assertion.addProperty("own", function() {
              flag(this, "own", true);
            });
            Assertion.addProperty("ordered", function() {
              flag(this, "ordered", true);
            });
            Assertion.addProperty("any", function() {
              flag(this, "any", true);
              flag(this, "all", false);
            });
            Assertion.addProperty("all", function() {
              flag(this, "all", true);
              flag(this, "any", false);
            });
            function an(type, msg) {
              if (msg) flag(this, "message", msg);
              type = type.toLowerCase();
              var obj = flag(this, "object"), article = ~[
                "a",
                "e",
                "i",
                "o",
                "u"
              ].indexOf(type.charAt(0)) ? "an " : "a ";
              this.assert(type === _.type(obj).toLowerCase(), "expected #{this} to be " + article + type, "expected #{this} not to be " + article + type);
            }
            __name(an, "an");
            Assertion.addChainableMethod("an", an);
            Assertion.addChainableMethod("a", an);
            function SameValueZero(a2, b) {
              return _.isNaN(a2) && _.isNaN(b) || a2 === b;
            }
            __name(SameValueZero, "SameValueZero");
            function includeChainingBehavior() {
              flag(this, "contains", true);
            }
            __name(includeChainingBehavior, "includeChainingBehavior");
            function include(val, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), objType = _.type(obj).toLowerCase(), flagMsg = flag(this, "message"), negate = flag(this, "negate"), ssfi = flag(this, "ssfi"), isDeep = flag(this, "deep"), descriptor = isDeep ? "deep " : "";
              flagMsg = flagMsg ? flagMsg + ": " : "";
              var included = false;
              switch (objType) {
                case "string":
                  included = obj.indexOf(val) !== -1;
                  break;
                case "weakset":
                  if (isDeep) throw new AssertionError(flagMsg + "unable to use .deep.include with WeakSet", void 0, ssfi);
                  included = obj.has(val);
                  break;
                case "map":
                  var isEql = isDeep ? _.eql : SameValueZero;
                  obj.forEach(function(item) {
                    included = included || isEql(item, val);
                  });
                  break;
                case "set":
                  if (isDeep) obj.forEach(function(item) {
                    included = included || _.eql(item, val);
                  });
                  else included = obj.has(val);
                  break;
                case "array":
                  if (isDeep) included = obj.some(function(item) {
                    return _.eql(item, val);
                  });
                  else included = obj.indexOf(val) !== -1;
                  break;
                default:
                  if (val !== Object(val)) throw new AssertionError(flagMsg + "object tested must be an array, a map, an object, a set, a string, or a weakset, but " + objType + " given", void 0, ssfi);
                  var props = Object.keys(val), firstErr = null, numErrs = 0;
                  props.forEach(function(prop) {
                    var propAssertion = new Assertion(obj);
                    _.transferFlags(this, propAssertion, true);
                    flag(propAssertion, "lockSsfi", true);
                    if (!negate || props.length === 1) {
                      propAssertion.property(prop, val[prop]);
                      return;
                    }
                    try {
                      propAssertion.property(prop, val[prop]);
                    } catch (err) {
                      if (!_.checkError.compatibleConstructor(err, AssertionError)) throw err;
                      if (firstErr === null) firstErr = err;
                      numErrs++;
                    }
                  }, this);
                  if (negate && props.length > 1 && numErrs === props.length) throw firstErr;
                  return;
              }
              this.assert(included, "expected #{this} to " + descriptor + "include " + _.inspect(val), "expected #{this} to not " + descriptor + "include " + _.inspect(val));
            }
            __name(include, "include");
            Assertion.addChainableMethod("include", include, includeChainingBehavior);
            Assertion.addChainableMethod("contain", include, includeChainingBehavior);
            Assertion.addChainableMethod("contains", include, includeChainingBehavior);
            Assertion.addChainableMethod("includes", include, includeChainingBehavior);
            Assertion.addProperty("ok", function() {
              this.assert(flag(this, "object"), "expected #{this} to be truthy", "expected #{this} to be falsy");
            });
            Assertion.addProperty("true", function() {
              this.assert(true === flag(this, "object"), "expected #{this} to be true", "expected #{this} to be false", flag(this, "negate") ? false : true);
            });
            Assertion.addProperty("false", function() {
              this.assert(false === flag(this, "object"), "expected #{this} to be false", "expected #{this} to be true", flag(this, "negate") ? true : false);
            });
            Assertion.addProperty("null", function() {
              this.assert(null === flag(this, "object"), "expected #{this} to be null", "expected #{this} not to be null");
            });
            Assertion.addProperty("undefined", function() {
              this.assert(void 0 === flag(this, "object"), "expected #{this} to be undefined", "expected #{this} not to be undefined");
            });
            Assertion.addProperty("NaN", function() {
              this.assert(_.isNaN(flag(this, "object")), "expected #{this} to be NaN", "expected #{this} not to be NaN");
            });
            Assertion.addProperty("exist", function() {
              var val = flag(this, "object");
              this.assert(val !== null && val !== void 0, "expected #{this} to exist", "expected #{this} to not exist");
            });
            Assertion.addProperty("empty", function() {
              var val = flag(this, "object"), ssfi = flag(this, "ssfi"), flagMsg = flag(this, "message"), itemsCount;
              flagMsg = flagMsg ? flagMsg + ": " : "";
              switch (_.type(val).toLowerCase()) {
                case "array":
                case "string":
                  itemsCount = val.length;
                  break;
                case "map":
                case "set":
                  itemsCount = val.size;
                  break;
                case "weakmap":
                case "weakset":
                  throw new AssertionError(flagMsg + ".empty was passed a weak collection", void 0, ssfi);
                case "function":
                  var msg = flagMsg + ".empty was passed a function " + _.getName(val);
                  throw new AssertionError(msg.trim(), void 0, ssfi);
                default:
                  if (val !== Object(val)) throw new AssertionError(flagMsg + ".empty was passed non-string primitive " + _.inspect(val), void 0, ssfi);
                  itemsCount = Object.keys(val).length;
              }
              this.assert(0 === itemsCount, "expected #{this} to be empty", "expected #{this} not to be empty");
            });
            function checkArguments() {
              var obj = flag(this, "object"), type = _.type(obj);
              this.assert("Arguments" === type, "expected #{this} to be arguments but got " + type, "expected #{this} to not be arguments");
            }
            __name(checkArguments, "checkArguments");
            Assertion.addProperty("arguments", checkArguments);
            Assertion.addProperty("Arguments", checkArguments);
            function assertEqual(val, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object");
              if (flag(this, "deep")) {
                var prevLockSsfi = flag(this, "lockSsfi");
                flag(this, "lockSsfi", true);
                this.eql(val);
                flag(this, "lockSsfi", prevLockSsfi);
              } else this.assert(val === obj, "expected #{this} to equal #{exp}", "expected #{this} to not equal #{exp}", val, this._obj, true);
            }
            __name(assertEqual, "assertEqual");
            Assertion.addMethod("equal", assertEqual);
            Assertion.addMethod("equals", assertEqual);
            Assertion.addMethod("eq", assertEqual);
            function assertEql(obj, msg) {
              if (msg) flag(this, "message", msg);
              this.assert(_.eql(obj, flag(this, "object")), "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", obj, this._obj, true);
            }
            __name(assertEql, "assertEql");
            Assertion.addMethod("eql", assertEql);
            Assertion.addMethod("eqls", assertEql);
            function assertAbove(n2, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _.type(obj).toLowerCase(), nType = _.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
              if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
              if (!doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to above must be a date";
              else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to above must be a number";
              else if (!doLength && objType !== "date" && objType !== "number") {
                var printObj = objType === "string" ? "'" + obj + "'" : obj;
                errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
              } else shouldThrow = false;
              if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
              if (doLength) {
                var descriptor = "length", itemsCount;
                if (objType === "map" || objType === "set") {
                  descriptor = "size";
                  itemsCount = obj.size;
                } else itemsCount = obj.length;
                this.assert(itemsCount > n2, "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " above #{exp}", n2, itemsCount);
              } else this.assert(obj > n2, "expected #{this} to be above #{exp}", "expected #{this} to be at most #{exp}", n2);
            }
            __name(assertAbove, "assertAbove");
            Assertion.addMethod("above", assertAbove);
            Assertion.addMethod("gt", assertAbove);
            Assertion.addMethod("greaterThan", assertAbove);
            function assertLeast(n2, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _.type(obj).toLowerCase(), nType = _.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
              if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
              if (!doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to least must be a date";
              else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to least must be a number";
              else if (!doLength && objType !== "date" && objType !== "number") {
                var printObj = objType === "string" ? "'" + obj + "'" : obj;
                errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
              } else shouldThrow = false;
              if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
              if (doLength) {
                var descriptor = "length", itemsCount;
                if (objType === "map" || objType === "set") {
                  descriptor = "size";
                  itemsCount = obj.size;
                } else itemsCount = obj.length;
                this.assert(itemsCount >= n2, "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " below #{exp}", n2, itemsCount);
              } else this.assert(obj >= n2, "expected #{this} to be at least #{exp}", "expected #{this} to be below #{exp}", n2);
            }
            __name(assertLeast, "assertLeast");
            Assertion.addMethod("least", assertLeast);
            Assertion.addMethod("gte", assertLeast);
            function assertBelow(n2, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _.type(obj).toLowerCase(), nType = _.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
              if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
              if (!doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to below must be a date";
              else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to below must be a number";
              else if (!doLength && objType !== "date" && objType !== "number") {
                var printObj = objType === "string" ? "'" + obj + "'" : obj;
                errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
              } else shouldThrow = false;
              if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
              if (doLength) {
                var descriptor = "length", itemsCount;
                if (objType === "map" || objType === "set") {
                  descriptor = "size";
                  itemsCount = obj.size;
                } else itemsCount = obj.length;
                this.assert(itemsCount < n2, "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " below #{exp}", n2, itemsCount);
              } else this.assert(obj < n2, "expected #{this} to be below #{exp}", "expected #{this} to be at least #{exp}", n2);
            }
            __name(assertBelow, "assertBelow");
            Assertion.addMethod("below", assertBelow);
            Assertion.addMethod("lt", assertBelow);
            Assertion.addMethod("lessThan", assertBelow);
            function assertMost(n2, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _.type(obj).toLowerCase(), nType = _.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
              if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
              if (!doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to most must be a date";
              else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to most must be a number";
              else if (!doLength && objType !== "date" && objType !== "number") {
                var printObj = objType === "string" ? "'" + obj + "'" : obj;
                errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
              } else shouldThrow = false;
              if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
              if (doLength) {
                var descriptor = "length", itemsCount;
                if (objType === "map" || objType === "set") {
                  descriptor = "size";
                  itemsCount = obj.size;
                } else itemsCount = obj.length;
                this.assert(itemsCount <= n2, "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " above #{exp}", n2, itemsCount);
              } else this.assert(obj <= n2, "expected #{this} to be at most #{exp}", "expected #{this} to be above #{exp}", n2);
            }
            __name(assertMost, "assertMost");
            Assertion.addMethod("most", assertMost);
            Assertion.addMethod("lte", assertMost);
            Assertion.addMethod("within", function(start, finish, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _.type(obj).toLowerCase(), startType = _.type(start).toLowerCase(), finishType = _.type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toUTCString() + ".." + finish.toUTCString() : start + ".." + finish;
              if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
              if (!doLength && objType === "date" && (startType !== "date" || finishType !== "date")) errorMessage = msgPrefix + "the arguments to within must be dates";
              else if ((startType !== "number" || finishType !== "number") && (doLength || objType === "number")) errorMessage = msgPrefix + "the arguments to within must be numbers";
              else if (!doLength && objType !== "date" && objType !== "number") {
                var printObj = objType === "string" ? "'" + obj + "'" : obj;
                errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
              } else shouldThrow = false;
              if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
              if (doLength) {
                var descriptor = "length", itemsCount;
                if (objType === "map" || objType === "set") {
                  descriptor = "size";
                  itemsCount = obj.size;
                } else itemsCount = obj.length;
                this.assert(itemsCount >= start && itemsCount <= finish, "expected #{this} to have a " + descriptor + " within " + range, "expected #{this} to not have a " + descriptor + " within " + range);
              } else this.assert(obj >= start && obj <= finish, "expected #{this} to be within " + range, "expected #{this} to not be within " + range);
            });
            function assertInstanceOf(constructor, msg) {
              if (msg) flag(this, "message", msg);
              var target = flag(this, "object");
              var ssfi = flag(this, "ssfi");
              var flagMsg = flag(this, "message");
              try {
                var isInstanceOf = target instanceof constructor;
              } catch (err) {
                if (err instanceof TypeError) {
                  flagMsg = flagMsg ? flagMsg + ": " : "";
                  throw new AssertionError(flagMsg + "The instanceof assertion needs a constructor but " + _.type(constructor) + " was given.", void 0, ssfi);
                }
                throw err;
              }
              var name = _.getName(constructor);
              if (name === null) name = "an unnamed constructor";
              this.assert(isInstanceOf, "expected #{this} to be an instance of " + name, "expected #{this} to not be an instance of " + name);
            }
            __name(assertInstanceOf, "assertInstanceOf");
            Assertion.addMethod("instanceof", assertInstanceOf);
            Assertion.addMethod("instanceOf", assertInstanceOf);
            function assertProperty(name, val, msg) {
              if (msg) flag(this, "message", msg);
              var isNested = flag(this, "nested"), isOwn = flag(this, "own"), flagMsg = flag(this, "message"), obj = flag(this, "object"), ssfi = flag(this, "ssfi"), nameType = typeof name;
              flagMsg = flagMsg ? flagMsg + ": " : "";
              if (isNested) {
                if (nameType !== "string") throw new AssertionError(flagMsg + "the argument to property must be a string when using nested syntax", void 0, ssfi);
              } else {
                if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") throw new AssertionError(flagMsg + "the argument to property must be a string, number, or symbol", void 0, ssfi);
              }
              if (isNested && isOwn) throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', void 0, ssfi);
              if (obj === null || obj === void 0) throw new AssertionError(flagMsg + "Target cannot be null or undefined.", void 0, ssfi);
              var isDeep = flag(this, "deep"), negate = flag(this, "negate"), pathInfo = isNested ? _.getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name];
              var descriptor = "";
              if (isDeep) descriptor += "deep ";
              if (isOwn) descriptor += "own ";
              if (isNested) descriptor += "nested ";
              descriptor += "property ";
              var hasProperty;
              if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);
              else if (isNested) hasProperty = pathInfo.exists;
              else hasProperty = _.hasProperty(obj, name);
              if (!negate || arguments.length === 1) this.assert(hasProperty, "expected #{this} to have " + descriptor + _.inspect(name), "expected #{this} to not have " + descriptor + _.inspect(name));
              if (arguments.length > 1) this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), "expected #{this} to have " + descriptor + _.inspect(name) + " of #{exp}, but got #{act}", "expected #{this} to not have " + descriptor + _.inspect(name) + " of #{act}", val, value);
              flag(this, "object", value);
            }
            __name(assertProperty, "assertProperty");
            Assertion.addMethod("property", assertProperty);
            function assertOwnProperty(name, value, msg) {
              flag(this, "own", true);
              assertProperty.apply(this, arguments);
            }
            __name(assertOwnProperty, "assertOwnProperty");
            Assertion.addMethod("ownProperty", assertOwnProperty);
            Assertion.addMethod("haveOwnProperty", assertOwnProperty);
            function assertOwnPropertyDescriptor(name, descriptor, msg) {
              if (typeof descriptor === "string") {
                msg = descriptor;
                descriptor = null;
              }
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object");
              var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
              if (actualDescriptor && descriptor) this.assert(_.eql(descriptor, actualDescriptor), "expected the own property descriptor for " + _.inspect(name) + " on #{this} to match " + _.inspect(descriptor) + ", got " + _.inspect(actualDescriptor), "expected the own property descriptor for " + _.inspect(name) + " on #{this} to not match " + _.inspect(descriptor), descriptor, actualDescriptor, true);
              else this.assert(actualDescriptor, "expected #{this} to have an own property descriptor for " + _.inspect(name), "expected #{this} to not have an own property descriptor for " + _.inspect(name));
              flag(this, "object", actualDescriptor);
            }
            __name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
            Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
            Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
            function assertLengthChain() {
              flag(this, "doLength", true);
            }
            __name(assertLengthChain, "assertLengthChain");
            function assertLength(n2, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), objType = _.type(obj).toLowerCase(), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi"), descriptor = "length", itemsCount;
              switch (objType) {
                case "map":
                case "set":
                  descriptor = "size";
                  itemsCount = obj.size;
                  break;
                default:
                  new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
                  itemsCount = obj.length;
              }
              this.assert(itemsCount == n2, "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " of #{act}", n2, itemsCount);
            }
            __name(assertLength, "assertLength");
            Assertion.addChainableMethod("length", assertLength, assertLengthChain);
            Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
            function assertMatch(re, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object");
              this.assert(re.exec(obj), "expected #{this} to match " + re, "expected #{this} not to match " + re);
            }
            __name(assertMatch, "assertMatch");
            Assertion.addMethod("match", assertMatch);
            Assertion.addMethod("matches", assertMatch);
            Assertion.addMethod("string", function(str, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
              new Assertion(obj, flagMsg, ssfi, true).is.a("string");
              this.assert(~obj.indexOf(str), "expected #{this} to contain " + _.inspect(str), "expected #{this} to not contain " + _.inspect(str));
            });
            function assertKeys(keys) {
              var obj = flag(this, "object"), objType = _.type(obj), keysType = _.type(keys), ssfi = flag(this, "ssfi"), isDeep = flag(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag(this, "message");
              flagMsg = flagMsg ? flagMsg + ": " : "";
              var mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
              if (objType === "Map" || objType === "Set") {
                deepStr = isDeep ? "deeply " : "";
                actual = [];
                obj.forEach(function(val, key) {
                  actual.push(key);
                });
                if (keysType !== "Array") keys = Array.prototype.slice.call(arguments);
              } else {
                actual = _.getOwnEnumerableProperties(obj);
                switch (keysType) {
                  case "Array":
                    if (arguments.length > 1) throw new AssertionError(mixedArgsMsg, void 0, ssfi);
                    break;
                  case "Object":
                    if (arguments.length > 1) throw new AssertionError(mixedArgsMsg, void 0, ssfi);
                    keys = Object.keys(keys);
                    break;
                  default:
                    keys = Array.prototype.slice.call(arguments);
                }
                keys = keys.map(function(val) {
                  return typeof val === "symbol" ? val : String(val);
                });
              }
              if (!keys.length) throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
              var len = keys.length, any = flag(this, "any"), all = flag(this, "all"), expected = keys;
              if (!any && !all) all = true;
              if (any) ok = expected.some(function(expectedKey) {
                return actual.some(function(actualKey) {
                  if (isDeep) return _.eql(expectedKey, actualKey);
                  else return expectedKey === actualKey;
                });
              });
              if (all) {
                ok = expected.every(function(expectedKey) {
                  return actual.some(function(actualKey) {
                    if (isDeep) return _.eql(expectedKey, actualKey);
                    else return expectedKey === actualKey;
                  });
                });
                if (!flag(this, "contains")) ok = ok && keys.length == actual.length;
              }
              if (len > 1) {
                keys = keys.map(function(key) {
                  return _.inspect(key);
                });
                var last = keys.pop();
                if (all) str = keys.join(", ") + ", and " + last;
                if (any) str = keys.join(", ") + ", or " + last;
              } else str = _.inspect(keys[0]);
              str = (len > 1 ? "keys " : "key ") + str;
              str = (flag(this, "contains") ? "contain " : "have ") + str;
              this.assert(ok, "expected #{this} to " + deepStr + str, "expected #{this} to not " + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), true);
            }
            __name(assertKeys, "assertKeys");
            Assertion.addMethod("keys", assertKeys);
            Assertion.addMethod("key", assertKeys);
            function assertThrows(errorLike, errMsgMatcher, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), ssfi = flag(this, "ssfi"), flagMsg = flag(this, "message"), negate = flag(this, "negate") || false;
              new Assertion(obj, flagMsg, ssfi, true).is.a("function");
              if (errorLike instanceof RegExp || typeof errorLike === "string") {
                errMsgMatcher = errorLike;
                errorLike = null;
              }
              var caughtErr;
              try {
                obj();
              } catch (err) {
                caughtErr = err;
              }
              var everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
              var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
              var errorLikeFail = false;
              var errMsgMatcherFail = false;
              if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
                var errorLikeString = "an error";
                if (errorLike instanceof Error) errorLikeString = "#{exp}";
                else if (errorLike) errorLikeString = _.checkError.getConstructorName(errorLike);
                this.assert(caughtErr, "expected #{this} to throw " + errorLikeString, "expected #{this} to not throw an error but #{act} was thrown", errorLike && errorLike.toString(), caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === "string" ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr));
              }
              if (errorLike && caughtErr) {
                if (errorLike instanceof Error) {
                  var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);
                  if (isCompatibleInstance === negate) {
                    if (everyArgIsDefined && negate) errorLikeFail = true;
                    else this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""), errorLike.toString(), caughtErr.toString());
                  }
                }
                var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);
                if (isCompatibleConstructor === negate) {
                  if (everyArgIsDefined && negate) errorLikeFail = true;
                  else this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
                }
              }
              if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
                var placeholder = "including";
                if (errMsgMatcher instanceof RegExp) placeholder = "matching";
                var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);
                if (isCompatibleMessage === negate) {
                  if (everyArgIsDefined && negate) errMsgMatcherFail = true;
                  else this.assert(negate, "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}", "expected #{this} to throw error not " + placeholder + " #{exp}", errMsgMatcher, _.checkError.getMessage(caughtErr));
                }
              }
              if (errorLikeFail && errMsgMatcherFail) this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
              flag(this, "object", caughtErr);
            }
            __name(assertThrows, "assertThrows");
            Assertion.addMethod("throw", assertThrows);
            Assertion.addMethod("throws", assertThrows);
            Assertion.addMethod("Throw", assertThrows);
            function respondTo(method, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), itself = flag(this, "itself"), context2 = "function" === typeof obj && !itself ? obj.prototype[method] : obj[method];
              this.assert("function" === typeof context2, "expected #{this} to respond to " + _.inspect(method), "expected #{this} to not respond to " + _.inspect(method));
            }
            __name(respondTo, "respondTo");
            Assertion.addMethod("respondTo", respondTo);
            Assertion.addMethod("respondsTo", respondTo);
            Assertion.addProperty("itself", function() {
              flag(this, "itself", true);
            });
            function satisfy(matcher, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object");
              var result = matcher(obj);
              this.assert(result, "expected #{this} to satisfy " + _.objDisplay(matcher), "expected #{this} to not satisfy" + _.objDisplay(matcher), flag(this, "negate") ? false : true, result);
            }
            __name(satisfy, "satisfy");
            Assertion.addMethod("satisfy", satisfy);
            Assertion.addMethod("satisfies", satisfy);
            function closeTo(expected, delta, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
              new Assertion(obj, flagMsg, ssfi, true).is.a("number");
              if (typeof expected !== "number" || typeof delta !== "number") {
                flagMsg = flagMsg ? flagMsg + ": " : "";
                throw new AssertionError(flagMsg + "the arguments to closeTo or approximately must be numbers", void 0, ssfi);
              }
              this.assert(Math.abs(obj - expected) <= delta, "expected #{this} to be close to " + expected + " +/- " + delta, "expected #{this} not to be close to " + expected + " +/- " + delta);
            }
            __name(closeTo, "closeTo");
            Assertion.addMethod("closeTo", closeTo);
            Assertion.addMethod("approximately", closeTo);
            function isSubsetOf(subset, superset, cmp, contains, ordered) {
              if (!contains) {
                if (subset.length !== superset.length) return false;
                superset = superset.slice();
              }
              return subset.every(function(elem, idx) {
                if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
                if (!cmp) {
                  var matchIdx = superset.indexOf(elem);
                  if (matchIdx === -1) return false;
                  if (!contains) superset.splice(matchIdx, 1);
                  return true;
                }
                return superset.some(function(elem2, matchIdx2) {
                  if (!cmp(elem, elem2)) return false;
                  if (!contains) superset.splice(matchIdx2, 1);
                  return true;
                });
              });
            }
            __name(isSubsetOf, "isSubsetOf");
            Assertion.addMethod("members", function(subset, msg) {
              if (msg) flag(this, "message", msg);
              var obj = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
              new Assertion(obj, flagMsg, ssfi, true).to.be.an("array");
              new Assertion(subset, flagMsg, ssfi, true).to.be.an("array");
              var contains = flag(this, "contains");
              var ordered = flag(this, "ordered");
              var subject, failMsg, failNegateMsg;
              if (contains) {
                subject = ordered ? "an ordered superset" : "a superset";
                failMsg = "expected #{this} to be " + subject + " of #{exp}";
                failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
              } else {
                subject = ordered ? "ordered members" : "members";
                failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
                failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
              }
              var cmp = flag(this, "deep") ? _.eql : void 0;
              this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
            });
            function oneOf(list, msg) {
              if (msg) flag(this, "message", msg);
              var expected = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
              new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
              this.assert(list.indexOf(expected) > -1, "expected #{this} to be one of #{exp}", "expected #{this} to not be one of #{exp}", list, expected);
            }
            __name(oneOf, "oneOf");
            Assertion.addMethod("oneOf", oneOf);
            function assertChanges(subject, prop, msg) {
              if (msg) flag(this, "message", msg);
              var fn = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
              new Assertion(fn, flagMsg, ssfi, true).is.a("function");
              var initial;
              if (!prop) {
                new Assertion(subject, flagMsg, ssfi, true).is.a("function");
                initial = subject();
              } else {
                new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
                initial = subject[prop];
              }
              fn();
              var final = prop === void 0 || prop === null ? subject() : subject[prop];
              var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
              flag(this, "deltaMsgObj", msgObj);
              flag(this, "initialDeltaValue", initial);
              flag(this, "finalDeltaValue", final);
              flag(this, "deltaBehavior", "change");
              flag(this, "realDelta", final !== initial);
              this.assert(initial !== final, "expected " + msgObj + " to change", "expected " + msgObj + " to not change");
            }
            __name(assertChanges, "assertChanges");
            Assertion.addMethod("change", assertChanges);
            Assertion.addMethod("changes", assertChanges);
            function assertIncreases(subject, prop, msg) {
              if (msg) flag(this, "message", msg);
              var fn = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
              new Assertion(fn, flagMsg, ssfi, true).is.a("function");
              var initial;
              if (!prop) {
                new Assertion(subject, flagMsg, ssfi, true).is.a("function");
                initial = subject();
              } else {
                new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
                initial = subject[prop];
              }
              new Assertion(initial, flagMsg, ssfi, true).is.a("number");
              fn();
              var final = prop === void 0 || prop === null ? subject() : subject[prop];
              var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
              flag(this, "deltaMsgObj", msgObj);
              flag(this, "initialDeltaValue", initial);
              flag(this, "finalDeltaValue", final);
              flag(this, "deltaBehavior", "increase");
              flag(this, "realDelta", final - initial);
              this.assert(final - initial > 0, "expected " + msgObj + " to increase", "expected " + msgObj + " to not increase");
            }
            __name(assertIncreases, "assertIncreases");
            Assertion.addMethod("increase", assertIncreases);
            Assertion.addMethod("increases", assertIncreases);
            function assertDecreases(subject, prop, msg) {
              if (msg) flag(this, "message", msg);
              var fn = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
              new Assertion(fn, flagMsg, ssfi, true).is.a("function");
              var initial;
              if (!prop) {
                new Assertion(subject, flagMsg, ssfi, true).is.a("function");
                initial = subject();
              } else {
                new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
                initial = subject[prop];
              }
              new Assertion(initial, flagMsg, ssfi, true).is.a("number");
              fn();
              var final = prop === void 0 || prop === null ? subject() : subject[prop];
              var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
              flag(this, "deltaMsgObj", msgObj);
              flag(this, "initialDeltaValue", initial);
              flag(this, "finalDeltaValue", final);
              flag(this, "deltaBehavior", "decrease");
              flag(this, "realDelta", initial - final);
              this.assert(final - initial < 0, "expected " + msgObj + " to decrease", "expected " + msgObj + " to not decrease");
            }
            __name(assertDecreases, "assertDecreases");
            Assertion.addMethod("decrease", assertDecreases);
            Assertion.addMethod("decreases", assertDecreases);
            function assertDelta(delta, msg) {
              if (msg) flag(this, "message", msg);
              var msgObj = flag(this, "deltaMsgObj");
              var initial = flag(this, "initialDeltaValue");
              var final = flag(this, "finalDeltaValue");
              var behavior = flag(this, "deltaBehavior");
              var realDelta = flag(this, "realDelta");
              var expression;
              if (behavior === "change") expression = Math.abs(final - initial) === Math.abs(delta);
              else expression = realDelta === Math.abs(delta);
              this.assert(expression, "expected " + msgObj + " to " + behavior + " by " + delta, "expected " + msgObj + " to not " + behavior + " by " + delta);
            }
            __name(assertDelta, "assertDelta");
            Assertion.addMethod("by", assertDelta);
            Assertion.addProperty("extensible", function() {
              var obj = flag(this, "object");
              var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
              this.assert(isExtensible, "expected #{this} to be extensible", "expected #{this} to not be extensible");
            });
            Assertion.addProperty("sealed", function() {
              var obj = flag(this, "object");
              var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
              this.assert(isSealed, "expected #{this} to be sealed", "expected #{this} to not be sealed");
            });
            Assertion.addProperty("frozen", function() {
              var obj = flag(this, "object");
              var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
              this.assert(isFrozen, "expected #{this} to be frozen", "expected #{this} to not be frozen");
            });
            Assertion.addProperty("finite", function(msg) {
              var obj = flag(this, "object");
              this.assert(typeof obj === "number" && isFinite(obj), "expected #{this} to be a finite number", "expected #{this} to not be a finite number");
            });
          };
        },
        {}
      ],
      6: [
        function(require2, module, exports) {
          module.exports = function(chai, util) {
            var Assertion = chai.Assertion, flag = util.flag;
            var assert = chai.assert = function(express, errmsg) {
              var test2 = new Assertion(null, null, chai.assert, true);
              test2.assert(express, errmsg, "[ negation message unavailable ]");
            };
            assert.fail = function(actual, expected, message, operator) {
              if (arguments.length < 2) {
                message = actual;
                actual = void 0;
              }
              message = message || "assert.fail()";
              throw new chai.AssertionError(message, {
                actual,
                expected,
                operator
              }, assert.fail);
            };
            assert.isOk = function(val, msg) {
              new Assertion(val, msg, assert.isOk, true).is.ok;
            };
            assert.isNotOk = function(val, msg) {
              new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
            };
            assert.equal = function(act, exp, msg) {
              var test2 = new Assertion(act, msg, assert.equal, true);
              test2.assert(exp == flag(test2, "object"), "expected #{this} to equal #{exp}", "expected #{this} to not equal #{act}", exp, act, true);
            };
            assert.notEqual = function(act, exp, msg) {
              var test2 = new Assertion(act, msg, assert.notEqual, true);
              test2.assert(exp != flag(test2, "object"), "expected #{this} to not equal #{exp}", "expected #{this} to equal #{act}", exp, act, true);
            };
            assert.strictEqual = function(act, exp, msg) {
              new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
            };
            assert.notStrictEqual = function(act, exp, msg) {
              new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
            };
            assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
              new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
            };
            assert.notDeepEqual = function(act, exp, msg) {
              new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
            };
            assert.isAbove = function(val, abv, msg) {
              new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
            };
            assert.isAtLeast = function(val, atlst, msg) {
              new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
            };
            assert.isBelow = function(val, blw, msg) {
              new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
            };
            assert.isAtMost = function(val, atmst, msg) {
              new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
            };
            assert.isTrue = function(val, msg) {
              new Assertion(val, msg, assert.isTrue, true).is["true"];
            };
            assert.isNotTrue = function(val, msg) {
              new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
            };
            assert.isFalse = function(val, msg) {
              new Assertion(val, msg, assert.isFalse, true).is["false"];
            };
            assert.isNotFalse = function(val, msg) {
              new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
            };
            assert.isNull = function(val, msg) {
              new Assertion(val, msg, assert.isNull, true).to.equal(null);
            };
            assert.isNotNull = function(val, msg) {
              new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
            };
            assert.isNaN = function(val, msg) {
              new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
            };
            assert.isNotNaN = function(val, msg) {
              new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
            };
            assert.exists = function(val, msg) {
              new Assertion(val, msg, assert.exists, true).to.exist;
            };
            assert.notExists = function(val, msg) {
              new Assertion(val, msg, assert.notExists, true).to.not.exist;
            };
            assert.isUndefined = function(val, msg) {
              new Assertion(val, msg, assert.isUndefined, true).to.equal(void 0);
            };
            assert.isDefined = function(val, msg) {
              new Assertion(val, msg, assert.isDefined, true).to.not.equal(void 0);
            };
            assert.isFunction = function(val, msg) {
              new Assertion(val, msg, assert.isFunction, true).to.be.a("function");
            };
            assert.isNotFunction = function(val, msg) {
              new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a("function");
            };
            assert.isObject = function(val, msg) {
              new Assertion(val, msg, assert.isObject, true).to.be.a("object");
            };
            assert.isNotObject = function(val, msg) {
              new Assertion(val, msg, assert.isNotObject, true).to.not.be.a("object");
            };
            assert.isArray = function(val, msg) {
              new Assertion(val, msg, assert.isArray, true).to.be.an("array");
            };
            assert.isNotArray = function(val, msg) {
              new Assertion(val, msg, assert.isNotArray, true).to.not.be.an("array");
            };
            assert.isString = function(val, msg) {
              new Assertion(val, msg, assert.isString, true).to.be.a("string");
            };
            assert.isNotString = function(val, msg) {
              new Assertion(val, msg, assert.isNotString, true).to.not.be.a("string");
            };
            assert.isNumber = function(val, msg) {
              new Assertion(val, msg, assert.isNumber, true).to.be.a("number");
            };
            assert.isNotNumber = function(val, msg) {
              new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a("number");
            };
            assert.isFinite = function(val, msg) {
              new Assertion(val, msg, assert.isFinite, true).to.be.finite;
            };
            assert.isBoolean = function(val, msg) {
              new Assertion(val, msg, assert.isBoolean, true).to.be.a("boolean");
            };
            assert.isNotBoolean = function(val, msg) {
              new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a("boolean");
            };
            assert.typeOf = function(val, type, msg) {
              new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
            };
            assert.notTypeOf = function(val, type, msg) {
              new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
            };
            assert.instanceOf = function(val, type, msg) {
              new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
            };
            assert.notInstanceOf = function(val, type, msg) {
              new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type);
            };
            assert.include = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.include, true).include(inc);
            };
            assert.notInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
            };
            assert.deepInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
            };
            assert.notDeepInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
            };
            assert.nestedInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
            };
            assert.notNestedInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
            };
            assert.deepNestedInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
            };
            assert.notDeepNestedInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
            };
            assert.ownInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
            };
            assert.notOwnInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
            };
            assert.deepOwnInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
            };
            assert.notDeepOwnInclude = function(exp, inc, msg) {
              new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
            };
            assert.match = function(exp, re, msg) {
              new Assertion(exp, msg, assert.match, true).to.match(re);
            };
            assert.notMatch = function(exp, re, msg) {
              new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
            };
            assert.property = function(obj, prop, msg) {
              new Assertion(obj, msg, assert.property, true).to.have.property(prop);
            };
            assert.notProperty = function(obj, prop, msg) {
              new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
            };
            assert.propertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
            };
            assert.notPropertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
            };
            assert.deepPropertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
            };
            assert.notDeepPropertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
            };
            assert.ownProperty = function(obj, prop, msg) {
              new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
            };
            assert.notOwnProperty = function(obj, prop, msg) {
              new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
            };
            assert.ownPropertyVal = function(obj, prop, value, msg) {
              new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value);
            };
            assert.notOwnPropertyVal = function(obj, prop, value, msg) {
              new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
            };
            assert.deepOwnPropertyVal = function(obj, prop, value, msg) {
              new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
            };
            assert.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
              new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
            };
            assert.nestedProperty = function(obj, prop, msg) {
              new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
            };
            assert.notNestedProperty = function(obj, prop, msg) {
              new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
            };
            assert.nestedPropertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
            };
            assert.notNestedPropertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
            };
            assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
            };
            assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
              new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
            };
            assert.lengthOf = function(exp, len, msg) {
              new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
            };
            assert.hasAnyKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
            };
            assert.hasAllKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
            };
            assert.containsAllKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
            };
            assert.doesNotHaveAnyKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
            };
            assert.doesNotHaveAllKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
            };
            assert.hasAnyDeepKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
            };
            assert.hasAllDeepKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
            };
            assert.containsAllDeepKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
            };
            assert.doesNotHaveAnyDeepKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
            };
            assert.doesNotHaveAllDeepKeys = function(obj, keys, msg) {
              new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
            };
            assert.throws = function(fn, errorLike, errMsgMatcher, msg) {
              if ("string" === typeof errorLike || errorLike instanceof RegExp) {
                errMsgMatcher = errorLike;
                errorLike = null;
              }
              var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
              return flag(assertErr, "object");
            };
            assert.doesNotThrow = function(fn, errorLike, errMsgMatcher, msg) {
              if ("string" === typeof errorLike || errorLike instanceof RegExp) {
                errMsgMatcher = errorLike;
                errorLike = null;
              }
              new Assertion(fn, msg, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
            };
            assert.operator = function(val, operator, val2, msg) {
              var ok;
              switch (operator) {
                case "==":
                  ok = val == val2;
                  break;
                case "===":
                  ok = val === val2;
                  break;
                case ">":
                  ok = val > val2;
                  break;
                case ">=":
                  ok = val >= val2;
                  break;
                case "<":
                  ok = val < val2;
                  break;
                case "<=":
                  ok = val <= val2;
                  break;
                case "!=":
                  ok = val != val2;
                  break;
                case "!==":
                  ok = val !== val2;
                  break;
                default:
                  msg = msg ? msg + ": " : msg;
                  throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', void 0, assert.operator);
              }
              var test2 = new Assertion(ok, msg, assert.operator, true);
              test2.assert(true === flag(test2, "object"), "expected " + util.inspect(val) + " to be " + operator + " " + util.inspect(val2), "expected " + util.inspect(val) + " to not be " + operator + " " + util.inspect(val2));
            };
            assert.closeTo = function(act, exp, delta, msg) {
              new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
            };
            assert.approximately = function(act, exp, delta, msg) {
              new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
            };
            assert.sameMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
            };
            assert.notSameMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
            };
            assert.sameDeepMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
            };
            assert.notSameDeepMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
            };
            assert.sameOrderedMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
            };
            assert.notSameOrderedMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
            };
            assert.sameDeepOrderedMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
            };
            assert.notSameDeepOrderedMembers = function(set1, set2, msg) {
              new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
            };
            assert.includeMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
            };
            assert.notIncludeMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
            };
            assert.includeDeepMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
            };
            assert.notIncludeDeepMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
            };
            assert.includeOrderedMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
            };
            assert.notIncludeOrderedMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
            };
            assert.includeDeepOrderedMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
            };
            assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
              new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
            };
            assert.oneOf = function(inList, list, msg) {
              new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
            };
            assert.changes = function(fn, obj, prop, msg) {
              if (arguments.length === 3 && typeof obj === "function") {
                msg = prop;
                prop = null;
              }
              new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
            };
            assert.changesBy = function(fn, obj, prop, delta, msg) {
              if (arguments.length === 4 && typeof obj === "function") {
                var tmpMsg = delta;
                delta = prop;
                msg = tmpMsg;
              } else if (arguments.length === 3) {
                delta = prop;
                prop = null;
              }
              new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
            };
            assert.doesNotChange = function(fn, obj, prop, msg) {
              if (arguments.length === 3 && typeof obj === "function") {
                msg = prop;
                prop = null;
              }
              return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
            };
            assert.changesButNotBy = function(fn, obj, prop, delta, msg) {
              if (arguments.length === 4 && typeof obj === "function") {
                var tmpMsg = delta;
                delta = prop;
                msg = tmpMsg;
              } else if (arguments.length === 3) {
                delta = prop;
                prop = null;
              }
              new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
            };
            assert.increases = function(fn, obj, prop, msg) {
              if (arguments.length === 3 && typeof obj === "function") {
                msg = prop;
                prop = null;
              }
              return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
            };
            assert.increasesBy = function(fn, obj, prop, delta, msg) {
              if (arguments.length === 4 && typeof obj === "function") {
                var tmpMsg = delta;
                delta = prop;
                msg = tmpMsg;
              } else if (arguments.length === 3) {
                delta = prop;
                prop = null;
              }
              new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
            };
            assert.doesNotIncrease = function(fn, obj, prop, msg) {
              if (arguments.length === 3 && typeof obj === "function") {
                msg = prop;
                prop = null;
              }
              return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
            };
            assert.increasesButNotBy = function(fn, obj, prop, delta, msg) {
              if (arguments.length === 4 && typeof obj === "function") {
                var tmpMsg = delta;
                delta = prop;
                msg = tmpMsg;
              } else if (arguments.length === 3) {
                delta = prop;
                prop = null;
              }
              new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
            };
            assert.decreases = function(fn, obj, prop, msg) {
              if (arguments.length === 3 && typeof obj === "function") {
                msg = prop;
                prop = null;
              }
              return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
            };
            assert.decreasesBy = function(fn, obj, prop, delta, msg) {
              if (arguments.length === 4 && typeof obj === "function") {
                var tmpMsg = delta;
                delta = prop;
                msg = tmpMsg;
              } else if (arguments.length === 3) {
                delta = prop;
                prop = null;
              }
              new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
            };
            assert.doesNotDecrease = function(fn, obj, prop, msg) {
              if (arguments.length === 3 && typeof obj === "function") {
                msg = prop;
                prop = null;
              }
              return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
            };
            assert.doesNotDecreaseBy = function(fn, obj, prop, delta, msg) {
              if (arguments.length === 4 && typeof obj === "function") {
                var tmpMsg = delta;
                delta = prop;
                msg = tmpMsg;
              } else if (arguments.length === 3) {
                delta = prop;
                prop = null;
              }
              return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
            };
            assert.decreasesButNotBy = function(fn, obj, prop, delta, msg) {
              if (arguments.length === 4 && typeof obj === "function") {
                var tmpMsg = delta;
                delta = prop;
                msg = tmpMsg;
              } else if (arguments.length === 3) {
                delta = prop;
                prop = null;
              }
              new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
            };
            assert.ifError = function(val) {
              if (val) throw val;
            };
            assert.isExtensible = function(obj, msg) {
              new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
            };
            assert.isNotExtensible = function(obj, msg) {
              new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
            };
            assert.isSealed = function(obj, msg) {
              new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
            };
            assert.isNotSealed = function(obj, msg) {
              new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
            };
            assert.isFrozen = function(obj, msg) {
              new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
            };
            assert.isNotFrozen = function(obj, msg) {
              new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
            };
            assert.isEmpty = function(val, msg) {
              new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
            };
            assert.isNotEmpty = function(val, msg) {
              new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
            };
            (/* @__PURE__ */ __name((function alias(name, as) {
              assert[as] = assert[name];
              return alias;
            }), "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty");
          };
        },
        {}
      ],
      7: [
        function(require2, module, exports) {
          module.exports = function(chai, util) {
            chai.expect = function(val, message) {
              return new chai.Assertion(val, message);
            };
            chai.expect.fail = function(actual, expected, message, operator) {
              if (arguments.length < 2) {
                message = actual;
                actual = void 0;
              }
              message = message || "expect.fail()";
              throw new chai.AssertionError(message, {
                actual,
                expected,
                operator
              }, chai.expect.fail);
            };
          };
        },
        {}
      ],
      8: [
        function(require2, module, exports) {
          module.exports = function(chai, util) {
            var Assertion = chai.Assertion;
            function loadShould() {
              function shouldGetter() {
                if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol) return new Assertion(this.valueOf(), null, shouldGetter);
                return new Assertion(this, null, shouldGetter);
              }
              __name(shouldGetter, "shouldGetter");
              function shouldSetter(value) {
                Object.defineProperty(this, "should", {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              }
              __name(shouldSetter, "shouldSetter");
              Object.defineProperty(Object.prototype, "should", {
                set: shouldSetter,
                get: shouldGetter,
                configurable: true
              });
              var should = {};
              should.fail = function(actual, expected, message, operator) {
                if (arguments.length < 2) {
                  message = actual;
                  actual = void 0;
                }
                message = message || "should.fail()";
                throw new chai.AssertionError(message, {
                  actual,
                  expected,
                  operator
                }, should.fail);
              };
              should.equal = function(val1, val2, msg) {
                new Assertion(val1, msg).to.equal(val2);
              };
              should.Throw = function(fn, errt, errs, msg) {
                new Assertion(fn, msg).to.Throw(errt, errs);
              };
              should.exist = function(val, msg) {
                new Assertion(val, msg).to.exist;
              };
              should.not = {};
              should.not.equal = function(val1, val2, msg) {
                new Assertion(val1, msg).to.not.equal(val2);
              };
              should.not.Throw = function(fn, errt, errs, msg) {
                new Assertion(fn, msg).to.not.Throw(errt, errs);
              };
              should.not.exist = function(val, msg) {
                new Assertion(val, msg).to.not.exist;
              };
              should["throw"] = should["Throw"];
              should.not["throw"] = should.not["Throw"];
              return should;
            }
            __name(loadShould, "loadShould");
            chai.should = loadShould;
            chai.Should = loadShould;
          };
        },
        {}
      ],
      9: [
        function(require2, module, exports) {
          var addLengthGuard = require2("./addLengthGuard");
          var chai = require2("../../chai");
          var flag = require2("./flag");
          var proxify = require2("./proxify");
          var transferFlags = require2("./transferFlags");
          var canSetPrototype = typeof Object.setPrototypeOf === "function";
          var testFn = /* @__PURE__ */ __name(function() {
          }, "testFn");
          var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
            var propDesc = Object.getOwnPropertyDescriptor(testFn, name);
            if (typeof propDesc !== "object") return true;
            return !propDesc.configurable;
          });
          var call = Function.prototype.call, apply = Function.prototype.apply;
          module.exports = /* @__PURE__ */ __name(function addChainableMethod(ctx, name, method, chainingBehavior) {
            if (typeof chainingBehavior !== "function") chainingBehavior = /* @__PURE__ */ __name(function() {
            }, "chainingBehavior");
            var chainableBehavior = {
              method,
              chainingBehavior
            };
            if (!ctx.__methods) ctx.__methods = {};
            ctx.__methods[name] = chainableBehavior;
            Object.defineProperty(ctx, name, {
              get: /* @__PURE__ */ __name(function chainableMethodGetter() {
                chainableBehavior.chainingBehavior.call(this);
                var chainableMethodWrapper = /* @__PURE__ */ __name(function() {
                  if (!flag(this, "lockSsfi")) flag(this, "ssfi", chainableMethodWrapper);
                  var result = chainableBehavior.method.apply(this, arguments);
                  if (result !== void 0) return result;
                  var newAssertion = new chai.Assertion();
                  transferFlags(this, newAssertion);
                  return newAssertion;
                }, "chainableMethodWrapper");
                addLengthGuard(chainableMethodWrapper, name, true);
                if (canSetPrototype) {
                  var prototype = Object.create(this);
                  prototype.call = call;
                  prototype.apply = apply;
                  Object.setPrototypeOf(chainableMethodWrapper, prototype);
                } else {
                  var asserterNames = Object.getOwnPropertyNames(ctx);
                  asserterNames.forEach(function(asserterName) {
                    if (excludeNames.indexOf(asserterName) !== -1) return;
                    var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
                    Object.defineProperty(chainableMethodWrapper, asserterName, pd);
                  });
                }
                transferFlags(this, chainableMethodWrapper);
                return proxify(chainableMethodWrapper);
              }, "chainableMethodGetter"),
              configurable: true
            });
          }, "addChainableMethod");
        },
        {
          "../../chai": 2,
          "./addLengthGuard": 10,
          "./flag": 15,
          "./proxify": 30,
          "./transferFlags": 32
        }
      ],
      10: [
        function(require2, module, exports) {
          var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
          }, "length");
          module.exports = /* @__PURE__ */ __name(function addLengthGuard(fn, assertionName, isChainable) {
            if (!fnLengthDesc.configurable) return fn;
            Object.defineProperty(fn, "length", {
              get: /* @__PURE__ */ __name(function() {
                if (isChainable) throw Error("Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
                throw Error("Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".');
              }, "get")
            });
            return fn;
          }, "addLengthGuard");
        },
        {}
      ],
      11: [
        function(require2, module, exports) {
          var addLengthGuard = require2("./addLengthGuard");
          var chai = require2("../../chai");
          var flag = require2("./flag");
          var proxify = require2("./proxify");
          var transferFlags = require2("./transferFlags");
          module.exports = /* @__PURE__ */ __name(function addMethod(ctx, name, method) {
            var methodWrapper = /* @__PURE__ */ __name(function() {
              if (!flag(this, "lockSsfi")) flag(this, "ssfi", methodWrapper);
              var result = method.apply(this, arguments);
              if (result !== void 0) return result;
              var newAssertion = new chai.Assertion();
              transferFlags(this, newAssertion);
              return newAssertion;
            }, "methodWrapper");
            addLengthGuard(methodWrapper, name, false);
            ctx[name] = proxify(methodWrapper, name);
          }, "addMethod");
        },
        {
          "../../chai": 2,
          "./addLengthGuard": 10,
          "./flag": 15,
          "./proxify": 30,
          "./transferFlags": 32
        }
      ],
      12: [
        function(require2, module, exports) {
          var chai = require2("../../chai");
          var flag = require2("./flag");
          var isProxyEnabled = require2("./isProxyEnabled");
          var transferFlags = require2("./transferFlags");
          module.exports = /* @__PURE__ */ __name(function addProperty(ctx, name, getter) {
            getter = getter === void 0 ? function() {
            } : getter;
            Object.defineProperty(ctx, name, {
              get: /* @__PURE__ */ __name(function propertyGetter() {
                if (!isProxyEnabled() && !flag(this, "lockSsfi")) flag(this, "ssfi", propertyGetter);
                var result = getter.call(this);
                if (result !== void 0) return result;
                var newAssertion = new chai.Assertion();
                transferFlags(this, newAssertion);
                return newAssertion;
              }, "propertyGetter"),
              configurable: true
            });
          }, "addProperty");
        },
        {
          "../../chai": 2,
          "./flag": 15,
          "./isProxyEnabled": 25,
          "./transferFlags": 32
        }
      ],
      13: [
        function(require2, module, exports) {
          var inspect = require2("./inspect");
          module.exports = /* @__PURE__ */ __name(function compareByInspect(a2, b) {
            return inspect(a2) < inspect(b) ? -1 : 1;
          }, "compareByInspect");
        },
        {
          "./inspect": 23
        }
      ],
      14: [
        function(require2, module, exports) {
          var AssertionError = require2("assertion-error");
          var flag = require2("./flag");
          var type = require2("type-detect");
          module.exports = /* @__PURE__ */ __name(function expectTypes(obj, types) {
            var flagMsg = flag(obj, "message");
            var ssfi = flag(obj, "ssfi");
            flagMsg = flagMsg ? flagMsg + ": " : "";
            obj = flag(obj, "object");
            types = types.map(function(t2) {
              return t2.toLowerCase();
            });
            types.sort();
            var str = types.map(function(t2, index) {
              var art = ~[
                "a",
                "e",
                "i",
                "o",
                "u"
              ].indexOf(t2.charAt(0)) ? "an" : "a";
              var or2 = types.length > 1 && index === types.length - 1 ? "or " : "";
              return or2 + art + " " + t2;
            }).join(", ");
            var objType = type(obj).toLowerCase();
            if (!types.some(function(expected) {
              return objType === expected;
            })) throw new AssertionError(flagMsg + "object tested must be " + str + ", but " + objType + " given", void 0, ssfi);
          }, "expectTypes");
        },
        {
          "./flag": 15,
          "assertion-error": 33,
          "type-detect": 38
        }
      ],
      15: [
        function(require2, module, exports) {
          module.exports = /* @__PURE__ */ __name(function flag(obj, key, value) {
            var flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
            if (arguments.length === 3) flags[key] = value;
            else return flags[key];
          }, "flag");
        },
        {}
      ],
      16: [
        function(require2, module, exports) {
          module.exports = /* @__PURE__ */ __name(function getActual(obj, args) {
            return args.length > 4 ? args[4] : obj._obj;
          }, "getActual");
        },
        {}
      ],
      17: [
        function(require2, module, exports) {
          module.exports = /* @__PURE__ */ __name(function getEnumerableProperties(object) {
            var result = [];
            for (var name in object) result.push(name);
            return result;
          }, "getEnumerableProperties");
        },
        {}
      ],
      18: [
        function(require2, module, exports) {
          var flag = require2("./flag"), getActual = require2("./getActual"), objDisplay = require2("./objDisplay");
          module.exports = /* @__PURE__ */ __name(function getMessage(obj, args) {
            var negate = flag(obj, "negate"), val = flag(obj, "object"), expected = args[3], actual = getActual(obj, args), msg = negate ? args[2] : args[1], flagMsg = flag(obj, "message");
            if (typeof msg === "function") msg = msg();
            msg = msg || "";
            msg = msg.replace(/#\{this\}/g, function() {
              return objDisplay(val);
            }).replace(/#\{act\}/g, function() {
              return objDisplay(actual);
            }).replace(/#\{exp\}/g, function() {
              return objDisplay(expected);
            });
            return flagMsg ? flagMsg + ": " + msg : msg;
          }, "getMessage");
        },
        {
          "./flag": 15,
          "./getActual": 16,
          "./objDisplay": 26
        }
      ],
      19: [
        function(require2, module, exports) {
          var getOwnEnumerablePropertySymbols = require2("./getOwnEnumerablePropertySymbols");
          module.exports = /* @__PURE__ */ __name(function getOwnEnumerableProperties(obj) {
            return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
          }, "getOwnEnumerableProperties");
        },
        {
          "./getOwnEnumerablePropertySymbols": 20
        }
      ],
      20: [
        function(require2, module, exports) {
          module.exports = /* @__PURE__ */ __name(function getOwnEnumerablePropertySymbols(obj) {
            if (typeof Object.getOwnPropertySymbols !== "function") return [];
            return Object.getOwnPropertySymbols(obj).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
            });
          }, "getOwnEnumerablePropertySymbols");
        },
        {}
      ],
      21: [
        function(require2, module, exports) {
          module.exports = /* @__PURE__ */ __name(function getProperties(object) {
            var result = Object.getOwnPropertyNames(object);
            function addProperty(property) {
              if (result.indexOf(property) === -1) result.push(property);
            }
            __name(addProperty, "addProperty");
            var proto = Object.getPrototypeOf(object);
            while (proto !== null) {
              Object.getOwnPropertyNames(proto).forEach(addProperty);
              proto = Object.getPrototypeOf(proto);
            }
            return result;
          }, "getProperties");
        },
        {}
      ],
      22: [
        function(require2, module, exports) {
          var pathval = require2("pathval");
          exports.test = require2("./test");
          exports.type = require2("type-detect");
          exports.expectTypes = require2("./expectTypes");
          exports.getMessage = require2("./getMessage");
          exports.getActual = require2("./getActual");
          exports.inspect = require2("./inspect");
          exports.objDisplay = require2("./objDisplay");
          exports.flag = require2("./flag");
          exports.transferFlags = require2("./transferFlags");
          exports.eql = require2("deep-eql");
          exports.getPathInfo = pathval.getPathInfo;
          exports.hasProperty = pathval.hasProperty;
          exports.getName = require2("get-func-name");
          exports.addProperty = require2("./addProperty");
          exports.addMethod = require2("./addMethod");
          exports.overwriteProperty = require2("./overwriteProperty");
          exports.overwriteMethod = require2("./overwriteMethod");
          exports.addChainableMethod = require2("./addChainableMethod");
          exports.overwriteChainableMethod = require2("./overwriteChainableMethod");
          exports.compareByInspect = require2("./compareByInspect");
          exports.getOwnEnumerablePropertySymbols = require2("./getOwnEnumerablePropertySymbols");
          exports.getOwnEnumerableProperties = require2("./getOwnEnumerableProperties");
          exports.checkError = require2("check-error");
          exports.proxify = require2("./proxify");
          exports.addLengthGuard = require2("./addLengthGuard");
          exports.isProxyEnabled = require2("./isProxyEnabled");
          exports.isNaN = require2("./isNaN");
        },
        {
          "./addChainableMethod": 9,
          "./addLengthGuard": 10,
          "./addMethod": 11,
          "./addProperty": 12,
          "./compareByInspect": 13,
          "./expectTypes": 14,
          "./flag": 15,
          "./getActual": 16,
          "./getMessage": 18,
          "./getOwnEnumerableProperties": 19,
          "./getOwnEnumerablePropertySymbols": 20,
          "./inspect": 23,
          "./isNaN": 24,
          "./isProxyEnabled": 25,
          "./objDisplay": 26,
          "./overwriteChainableMethod": 27,
          "./overwriteMethod": 28,
          "./overwriteProperty": 29,
          "./proxify": 30,
          "./test": 31,
          "./transferFlags": 32,
          "check-error": 34,
          "deep-eql": 35,
          "get-func-name": 36,
          "pathval": 37,
          "type-detect": 38
        }
      ],
      23: [
        function(require2, module, exports) {
          var getName = require2("get-func-name");
          var getProperties = require2("./getProperties");
          var getEnumerableProperties = require2("./getEnumerableProperties");
          var config = require2("../config");
          module.exports = inspect;
          function inspect(obj, showHidden, depth, colors2) {
            var ctx = {
              showHidden,
              seen: [],
              stylize: /* @__PURE__ */ __name(function(str) {
                return str;
              }, "stylize")
            };
            return formatValue(ctx, obj, typeof depth === "undefined" ? 2 : depth);
          }
          __name(inspect, "inspect");
          var isDOMElement = /* @__PURE__ */ __name(function(object) {
            if (typeof HTMLElement === "object") return object instanceof HTMLElement;
            else return object && typeof object === "object" && "nodeType" in object && object.nodeType === 1 && typeof object.nodeName === "string";
          }, "isDOMElement");
          function formatValue(ctx, value, recurseTimes) {
            if (value && typeof value.inspect === "function" && // Filter out the util module, it's inspect function is special
            value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (typeof ret !== "string") ret = formatValue(ctx, ret, recurseTimes);
              return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) return primitive;
            if (isDOMElement(value)) {
              if ("outerHTML" in value) return value.outerHTML;
              else
                try {
                  if (document.xmlVersion) {
                    var xmlSerializer = new XMLSerializer();
                    return xmlSerializer.serializeToString(value);
                  } else {
                    var ns = "http://www.w3.org/1999/xhtml";
                    var container = document.createElementNS(ns, "_");
                    container.appendChild(value.cloneNode(false));
                    var html = container.innerHTML.replace("><", ">" + value.innerHTML + "<");
                    container.innerHTML = "";
                    return html;
                  }
                } catch (err) {
                }
            }
            var visibleKeys = getEnumerableProperties(value);
            var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
            var name, nameSuffix;
            if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === "stack" || keys.length === 2 && keys[0] === "description" && keys[1] === "stack")) {
              if (typeof value === "function") {
                name = getName(value);
                nameSuffix = name ? ": " + name : "";
                return ctx.stylize("[Function" + nameSuffix + "]", "special");
              }
              if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              if (isDate(value)) return ctx.stylize(Date.prototype.toUTCString.call(value), "date");
              if (isError(value)) return formatError2(value);
            }
            var base2 = "", array = false, typedArray = false, braces = [
              "{",
              "}"
            ];
            if (isTypedArray(value)) {
              typedArray = true;
              braces = [
                "[",
                "]"
              ];
            }
            if (isArray(value)) {
              array = true;
              braces = [
                "[",
                "]"
              ];
            }
            if (typeof value === "function") {
              name = getName(value);
              nameSuffix = name ? ": " + name : "";
              base2 = " [Function" + nameSuffix + "]";
            }
            if (isRegExp(value)) base2 = " " + RegExp.prototype.toString.call(value);
            if (isDate(value)) base2 = " " + Date.prototype.toUTCString.call(value);
            if (isError(value)) return formatError2(value);
            if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base2 + braces[1];
            if (recurseTimes < 0) {
              if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              else return ctx.stylize("[Object]", "special");
            }
            ctx.seen.push(value);
            var output;
            if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            else if (typedArray) return formatTypedArray(value);
            else output = keys.map(function(key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
            ctx.seen.pop();
            return reduceToSingleString(output, base2, braces);
          }
          __name(formatValue, "formatValue");
          function formatPrimitive(ctx, value) {
            switch (typeof value) {
              case "undefined":
                return ctx.stylize("undefined", "undefined");
              case "string":
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              case "number":
                if (value === 0 && 1 / value === -Infinity) return ctx.stylize("-0", "number");
                return ctx.stylize("" + value, "number");
              case "boolean":
                return ctx.stylize("" + value, "boolean");
              case "symbol":
                return ctx.stylize(value.toString(), "symbol");
            }
            if (value === null) return ctx.stylize("null", "null");
          }
          __name(formatPrimitive, "formatPrimitive");
          function formatError2(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
          }
          __name(formatError2, "formatError");
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) if (Object.prototype.hasOwnProperty.call(value, String(i2))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i2), true));
            else output.push("");
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
            });
            return output;
          }
          __name(formatArray, "formatArray");
          function formatTypedArray(value) {
            var str = "[ ";
            for (var i2 = 0; i2 < value.length; ++i2) {
              if (str.length >= config.truncateThreshold - 7) {
                str += "...";
                break;
              }
              str += value[i2] + ", ";
            }
            str += " ]";
            if (str.indexOf(",  ]") !== -1) str = str.replace(",  ]", " ]");
            return str;
          }
          __name(formatTypedArray, "formatTypedArray");
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name;
            var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
            var str;
            if (propDescriptor) {
              if (propDescriptor.get) {
                if (propDescriptor.set) str = ctx.stylize("[Getter/Setter]", "special");
                else str = ctx.stylize("[Getter]", "special");
              } else if (propDescriptor.set) str = ctx.stylize("[Setter]", "special");
            }
            if (visibleKeys.indexOf(key) < 0) name = "[" + key + "]";
            if (!str) {
              if (ctx.seen.indexOf(value[key]) < 0) {
                if (recurseTimes === null) str = formatValue(ctx, value[key], null);
                else str = formatValue(ctx, value[key], recurseTimes - 1);
                if (str.indexOf("\n") > -1) {
                  if (array) str = str.split("\n").map(function(line) {
                    return "  " + line;
                  }).join("\n").substr(2);
                  else str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                  }).join("\n");
                }
              } else str = ctx.stylize("[Circular]", "special");
            }
            if (typeof name === "undefined") {
              if (array && key.match(/^\d+$/)) return str;
              name = JSON.stringify("" + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, "name");
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, "string");
              }
            }
            return name + ": " + str;
          }
          __name(formatProperty, "formatProperty");
          function reduceToSingleString(output, base2, braces) {
            var length = output.reduce(function(prev, cur) {
              return prev + cur.length + 1;
            }, 0);
            if (length > 60) return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
            return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
          }
          __name(reduceToSingleString, "reduceToSingleString");
          function isTypedArray(ar) {
            return typeof ar === "object" && /\w+Array]$/.test(objectToString(ar));
          }
          __name(isTypedArray, "isTypedArray");
          function isArray(ar) {
            return Array.isArray(ar) || typeof ar === "object" && objectToString(ar) === "[object Array]";
          }
          __name(isArray, "isArray");
          function isRegExp(re) {
            return typeof re === "object" && objectToString(re) === "[object RegExp]";
          }
          __name(isRegExp, "isRegExp");
          function isDate(d2) {
            return typeof d2 === "object" && objectToString(d2) === "[object Date]";
          }
          __name(isDate, "isDate");
          function isError(e2) {
            return typeof e2 === "object" && objectToString(e2) === "[object Error]";
          }
          __name(isError, "isError");
          function objectToString(o2) {
            return Object.prototype.toString.call(o2);
          }
          __name(objectToString, "objectToString");
        },
        {
          "../config": 4,
          "./getEnumerableProperties": 17,
          "./getProperties": 21,
          "get-func-name": 36
        }
      ],
      24: [
        function(require2, module, exports) {
          function isNaN2(value) {
            return value !== value;
          }
          __name(isNaN2, "isNaN");
          module.exports = Number.isNaN || isNaN2;
        },
        {}
      ],
      25: [
        function(require2, module, exports) {
          var config = require2("../config");
          module.exports = /* @__PURE__ */ __name(function isProxyEnabled() {
            return config.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
          }, "isProxyEnabled");
        },
        {
          "../config": 4
        }
      ],
      26: [
        function(require2, module, exports) {
          var inspect = require2("./inspect");
          var config = require2("../config");
          module.exports = /* @__PURE__ */ __name(function objDisplay(obj) {
            var str = inspect(obj), type = Object.prototype.toString.call(obj);
            if (config.truncateThreshold && str.length >= config.truncateThreshold) {
              if (type === "[object Function]") return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
              else if (type === "[object Array]") return "[ Array(" + obj.length + ") ]";
              else if (type === "[object Object]") {
                var keys = Object.keys(obj), kstr = keys.length > 2 ? keys.splice(0, 2).join(", ") + ", ..." : keys.join(", ");
                return "{ Object (" + kstr + ") }";
              } else return str;
            } else return str;
          }, "objDisplay");
        },
        {
          "../config": 4,
          "./inspect": 23
        }
      ],
      27: [
        function(require2, module, exports) {
          var chai = require2("../../chai");
          var transferFlags = require2("./transferFlags");
          module.exports = /* @__PURE__ */ __name(function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
            var chainableBehavior = ctx.__methods[name];
            var _chainingBehavior = chainableBehavior.chainingBehavior;
            chainableBehavior.chainingBehavior = /* @__PURE__ */ __name(function overwritingChainableMethodGetter() {
              var result = chainingBehavior(_chainingBehavior).call(this);
              if (result !== void 0) return result;
              var newAssertion = new chai.Assertion();
              transferFlags(this, newAssertion);
              return newAssertion;
            }, "overwritingChainableMethodGetter");
            var _method = chainableBehavior.method;
            chainableBehavior.method = /* @__PURE__ */ __name(function overwritingChainableMethodWrapper() {
              var result = method(_method).apply(this, arguments);
              if (result !== void 0) return result;
              var newAssertion = new chai.Assertion();
              transferFlags(this, newAssertion);
              return newAssertion;
            }, "overwritingChainableMethodWrapper");
          }, "overwriteChainableMethod");
        },
        {
          "../../chai": 2,
          "./transferFlags": 32
        }
      ],
      28: [
        function(require2, module, exports) {
          var addLengthGuard = require2("./addLengthGuard");
          var chai = require2("../../chai");
          var flag = require2("./flag");
          var proxify = require2("./proxify");
          var transferFlags = require2("./transferFlags");
          module.exports = /* @__PURE__ */ __name(function overwriteMethod(ctx, name, method) {
            var _method = ctx[name], _super = /* @__PURE__ */ __name(function() {
              throw new Error(name + " is not a function");
            }, "_super");
            if (_method && "function" === typeof _method) _super = _method;
            var overwritingMethodWrapper = /* @__PURE__ */ __name(function() {
              if (!flag(this, "lockSsfi")) flag(this, "ssfi", overwritingMethodWrapper);
              var origLockSsfi = flag(this, "lockSsfi");
              flag(this, "lockSsfi", true);
              var result = method(_super).apply(this, arguments);
              flag(this, "lockSsfi", origLockSsfi);
              if (result !== void 0) return result;
              var newAssertion = new chai.Assertion();
              transferFlags(this, newAssertion);
              return newAssertion;
            }, "overwritingMethodWrapper");
            addLengthGuard(overwritingMethodWrapper, name, false);
            ctx[name] = proxify(overwritingMethodWrapper, name);
          }, "overwriteMethod");
        },
        {
          "../../chai": 2,
          "./addLengthGuard": 10,
          "./flag": 15,
          "./proxify": 30,
          "./transferFlags": 32
        }
      ],
      29: [
        function(require2, module, exports) {
          var chai = require2("../../chai");
          var flag = require2("./flag");
          var isProxyEnabled = require2("./isProxyEnabled");
          var transferFlags = require2("./transferFlags");
          module.exports = /* @__PURE__ */ __name(function overwriteProperty(ctx, name, getter) {
            var _get = Object.getOwnPropertyDescriptor(ctx, name), _super = /* @__PURE__ */ __name(function() {
            }, "_super");
            if (_get && "function" === typeof _get.get) _super = _get.get;
            Object.defineProperty(ctx, name, {
              get: /* @__PURE__ */ __name(function overwritingPropertyGetter() {
                if (!isProxyEnabled() && !flag(this, "lockSsfi")) flag(this, "ssfi", overwritingPropertyGetter);
                var origLockSsfi = flag(this, "lockSsfi");
                flag(this, "lockSsfi", true);
                var result = getter(_super).call(this);
                flag(this, "lockSsfi", origLockSsfi);
                if (result !== void 0) return result;
                var newAssertion = new chai.Assertion();
                transferFlags(this, newAssertion);
                return newAssertion;
              }, "overwritingPropertyGetter"),
              configurable: true
            });
          }, "overwriteProperty");
        },
        {
          "../../chai": 2,
          "./flag": 15,
          "./isProxyEnabled": 25,
          "./transferFlags": 32
        }
      ],
      30: [
        function(require2, module, exports) {
          var config = require2("../config");
          var flag = require2("./flag");
          var getProperties = require2("./getProperties");
          var isProxyEnabled = require2("./isProxyEnabled");
          var builtins = [
            "__flags",
            "__methods",
            "_obj",
            "assert"
          ];
          module.exports = /* @__PURE__ */ __name(function proxify(obj, nonChainableMethodName) {
            if (!isProxyEnabled()) return obj;
            return new Proxy(obj, {
              get: /* @__PURE__ */ __name(function proxyGetter(target, property) {
                if (typeof property === "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
                  if (nonChainableMethodName) throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
                  var suggestion = null;
                  var suggestionDistance = 4;
                  getProperties(target).forEach(function(prop) {
                    if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
                      var dist = stringDistanceCapped(property, prop, suggestionDistance);
                      if (dist < suggestionDistance) {
                        suggestion = prop;
                        suggestionDistance = dist;
                      }
                    }
                  });
                  if (suggestion !== null) throw Error("Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?');
                  else throw Error("Invalid Chai property: " + property);
                }
                if (builtins.indexOf(property) === -1 && !flag(target, "lockSsfi")) flag(target, "ssfi", proxyGetter);
                return Reflect.get(target, property);
              }, "proxyGetter")
            });
          }, "proxify");
          function stringDistanceCapped(strA, strB, cap) {
            if (Math.abs(strA.length - strB.length) >= cap) return cap;
            var memo = [];
            for (var i2 = 0; i2 <= strA.length; i2++) {
              memo[i2] = Array(strB.length + 1).fill(0);
              memo[i2][0] = i2;
            }
            for (var j = 0; j < strB.length; j++) memo[0][j] = j;
            for (var i2 = 1; i2 <= strA.length; i2++) {
              var ch = strA.charCodeAt(i2 - 1);
              for (var j = 1; j <= strB.length; j++) {
                if (Math.abs(i2 - j) >= cap) {
                  memo[i2][j] = cap;
                  continue;
                }
                memo[i2][j] = Math.min(memo[i2 - 1][j] + 1, memo[i2][j - 1] + 1, memo[i2 - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1));
              }
            }
            return memo[strA.length][strB.length];
          }
          __name(stringDistanceCapped, "stringDistanceCapped");
        },
        {
          "../config": 4,
          "./flag": 15,
          "./getProperties": 21,
          "./isProxyEnabled": 25
        }
      ],
      31: [
        function(require2, module, exports) {
          var flag = require2("./flag");
          module.exports = /* @__PURE__ */ __name(function test2(obj, args) {
            var negate = flag(obj, "negate"), expr = args[0];
            return negate ? !expr : expr;
          }, "test");
        },
        {
          "./flag": 15
        }
      ],
      32: [
        function(require2, module, exports) {
          module.exports = /* @__PURE__ */ __name(function transferFlags(assertion, object, includeAll) {
            var flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
            if (!object.__flags) object.__flags = /* @__PURE__ */ Object.create(null);
            includeAll = arguments.length === 3 ? includeAll : true;
            for (var flag in flags) if (includeAll || flag !== "object" && flag !== "ssfi" && flag !== "lockSsfi" && flag != "message") object.__flags[flag] = flags[flag];
          }, "transferFlags");
        },
        {}
      ],
      33: [
        function(require2, module, exports) {
          function exclude() {
            var excludes = [].slice.call(arguments);
            function excludeProps(res, obj) {
              Object.keys(obj).forEach(function(key) {
                if (!~excludes.indexOf(key)) res[key] = obj[key];
              });
            }
            __name(excludeProps, "excludeProps");
            return /* @__PURE__ */ __name(function extendExclude() {
              var args = [].slice.call(arguments), i2 = 0, res = {};
              for (; i2 < args.length; i2++) excludeProps(res, args[i2]);
              return res;
            }, "extendExclude");
          }
          __name(exclude, "exclude");
          module.exports = AssertionError;
          function AssertionError(message, _props, ssf) {
            var extend = exclude("name", "message", "stack", "constructor", "toJSON"), props = extend(_props || {});
            this.message = message || "Unspecified AssertionError";
            this.showDiff = false;
            for (var key in props) this[key] = props[key];
            ssf = ssf || AssertionError;
            if (Error.captureStackTrace) Error.captureStackTrace(this, ssf);
            else try {
              throw new Error();
            } catch (e2) {
              this.stack = e2.stack;
            }
          }
          __name(AssertionError, "AssertionError");
          AssertionError.prototype = Object.create(Error.prototype);
          AssertionError.prototype.name = "AssertionError";
          AssertionError.prototype.constructor = AssertionError;
          AssertionError.prototype.toJSON = function(stack) {
            var extend = exclude("constructor", "toJSON", "stack"), props = extend({
              name: this.name
            }, this);
            if (false !== stack && this.stack) props.stack = this.stack;
            return props;
          };
        },
        {}
      ],
      34: [
        function(require2, module, exports) {
          function compatibleInstance(thrown, errorLike) {
            return errorLike instanceof Error && thrown === errorLike;
          }
          __name(compatibleInstance, "compatibleInstance");
          function compatibleConstructor(thrown, errorLike) {
            if (errorLike instanceof Error)
              return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
            else if (errorLike.prototype instanceof Error || errorLike === Error)
              return thrown.constructor === errorLike || thrown instanceof errorLike;
            return false;
          }
          __name(compatibleConstructor, "compatibleConstructor");
          function compatibleMessage(thrown, errMatcher) {
            var comparisonString = typeof thrown === "string" ? thrown : thrown.message;
            if (errMatcher instanceof RegExp) return errMatcher.test(comparisonString);
            else if (typeof errMatcher === "string") return comparisonString.indexOf(errMatcher) !== -1;
            return false;
          }
          __name(compatibleMessage, "compatibleMessage");
          var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;
          function getFunctionName(constructorFn) {
            var name = "";
            if (typeof constructorFn.name === "undefined") {
              var match = String(constructorFn).match(functionNameMatch);
              if (match) name = match[1];
            } else name = constructorFn.name;
            return name;
          }
          __name(getFunctionName, "getFunctionName");
          function getConstructorName(errorLike) {
            var constructorName = errorLike;
            if (errorLike instanceof Error) constructorName = getFunctionName(errorLike.constructor);
            else if (typeof errorLike === "function")
              constructorName = getFunctionName(errorLike).trim() || getFunctionName(new errorLike());
            return constructorName;
          }
          __name(getConstructorName, "getConstructorName");
          function getMessage(errorLike) {
            var msg = "";
            if (errorLike && errorLike.message) msg = errorLike.message;
            else if (typeof errorLike === "string") msg = errorLike;
            return msg;
          }
          __name(getMessage, "getMessage");
          module.exports = {
            compatibleInstance,
            compatibleConstructor,
            compatibleMessage,
            getMessage,
            getConstructorName
          };
        },
        {}
      ],
      35: [
        function(require2, module, exports) {
          var type = require2("type-detect");
          function FakeMap() {
            this._key = "chai/deep-eql__" + Math.random() + Date.now();
          }
          __name(FakeMap, "FakeMap");
          FakeMap.prototype = {
            get: /* @__PURE__ */ __name(function getMap(key) {
              return key[this._key];
            }, "getMap"),
            set: /* @__PURE__ */ __name(function setMap(key, value) {
              if (Object.isExtensible(key)) Object.defineProperty(key, this._key, {
                value,
                configurable: true
              });
            }, "setMap")
          };
          var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
          function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
            if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) return null;
            var leftHandMap = memoizeMap.get(leftHandOperand);
            if (leftHandMap) {
              var result = leftHandMap.get(rightHandOperand);
              if (typeof result === "boolean") return result;
            }
            return null;
          }
          __name(memoizeCompare, "memoizeCompare");
          function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
            if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) return;
            var leftHandMap = memoizeMap.get(leftHandOperand);
            if (leftHandMap) leftHandMap.set(rightHandOperand, result);
            else {
              leftHandMap = new MemoizeMap();
              leftHandMap.set(rightHandOperand, result);
              memoizeMap.set(leftHandOperand, leftHandMap);
            }
          }
          __name(memoizeSet, "memoizeSet");
          module.exports = deepEqual;
          module.exports.MemoizeMap = MemoizeMap;
          function deepEqual(leftHandOperand, rightHandOperand, options) {
            if (options && options.comparator) return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
            var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
            if (simpleResult !== null) return simpleResult;
            return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
          }
          __name(deepEqual, "deepEqual");
          function simpleEqual(leftHandOperand, rightHandOperand) {
            if (leftHandOperand === rightHandOperand)
              return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
            if (leftHandOperand !== leftHandOperand && rightHandOperand !== rightHandOperand) return true;
            if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand))
              return false;
            return null;
          }
          __name(simpleEqual, "simpleEqual");
          function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
            options = options || {};
            options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
            var comparator = options && options.comparator;
            var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
            if (memoizeResultLeft !== null) return memoizeResultLeft;
            var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
            if (memoizeResultRight !== null) return memoizeResultRight;
            if (comparator) {
              var comparatorResult = comparator(leftHandOperand, rightHandOperand);
              if (comparatorResult === false || comparatorResult === true) {
                memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
                return comparatorResult;
              }
              var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
              if (simpleResult !== null)
                return simpleResult;
            }
            var leftHandType = type(leftHandOperand);
            if (leftHandType !== type(rightHandOperand)) {
              memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
              return false;
            }
            memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
            var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
            memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
            return result;
          }
          __name(extensiveDeepEqual, "extensiveDeepEqual");
          function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
            switch (leftHandType) {
              case "String":
              case "Number":
              case "Boolean":
              case "Date":
                return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
              case "Promise":
              case "Symbol":
              case "function":
              case "WeakMap":
              case "WeakSet":
              case "Error":
                return leftHandOperand === rightHandOperand;
              case "Arguments":
              case "Int8Array":
              case "Uint8Array":
              case "Uint8ClampedArray":
              case "Int16Array":
              case "Uint16Array":
              case "Int32Array":
              case "Uint32Array":
              case "Float32Array":
              case "Float64Array":
              case "Array":
                return iterableEqual(leftHandOperand, rightHandOperand, options);
              case "RegExp":
                return regexpEqual(leftHandOperand, rightHandOperand);
              case "Generator":
                return generatorEqual(leftHandOperand, rightHandOperand, options);
              case "DataView":
                return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
              case "ArrayBuffer":
                return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
              case "Set":
                return entriesEqual(leftHandOperand, rightHandOperand, options);
              case "Map":
                return entriesEqual(leftHandOperand, rightHandOperand, options);
              default:
                return objectEqual(leftHandOperand, rightHandOperand, options);
            }
          }
          __name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
          function regexpEqual(leftHandOperand, rightHandOperand) {
            return leftHandOperand.toString() === rightHandOperand.toString();
          }
          __name(regexpEqual, "regexpEqual");
          function entriesEqual(leftHandOperand, rightHandOperand, options) {
            if (leftHandOperand.size !== rightHandOperand.size) return false;
            if (leftHandOperand.size === 0) return true;
            var leftHandItems = [];
            var rightHandItems = [];
            leftHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
              leftHandItems.push([
                key,
                value
              ]);
            }, "gatherEntries"));
            rightHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
              rightHandItems.push([
                key,
                value
              ]);
            }, "gatherEntries"));
            return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
          }
          __name(entriesEqual, "entriesEqual");
          function iterableEqual(leftHandOperand, rightHandOperand, options) {
            var length = leftHandOperand.length;
            if (length !== rightHandOperand.length) return false;
            if (length === 0) return true;
            var index = -1;
            while (++index < length) {
              if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) return false;
            }
            return true;
          }
          __name(iterableEqual, "iterableEqual");
          function generatorEqual(leftHandOperand, rightHandOperand, options) {
            return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
          }
          __name(generatorEqual, "generatorEqual");
          function hasIteratorFunction(target) {
            return typeof Symbol !== "undefined" && typeof target === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
          }
          __name(hasIteratorFunction, "hasIteratorFunction");
          function getIteratorEntries(target) {
            if (hasIteratorFunction(target)) try {
              return getGeneratorEntries(target[Symbol.iterator]());
            } catch (iteratorError) {
              return [];
            }
            return [];
          }
          __name(getIteratorEntries, "getIteratorEntries");
          function getGeneratorEntries(generator) {
            var generatorResult = generator.next();
            var accumulator = [
              generatorResult.value
            ];
            while (generatorResult.done === false) {
              generatorResult = generator.next();
              accumulator.push(generatorResult.value);
            }
            return accumulator;
          }
          __name(getGeneratorEntries, "getGeneratorEntries");
          function getEnumerableKeys(target) {
            var keys = [];
            for (var key in target) keys.push(key);
            return keys;
          }
          __name(getEnumerableKeys, "getEnumerableKeys");
          function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
            var length = keys.length;
            if (length === 0) return true;
            for (var i2 = 0; i2 < length; i2 += 1) {
              if (deepEqual(leftHandOperand[keys[i2]], rightHandOperand[keys[i2]], options) === false) return false;
            }
            return true;
          }
          __name(keysEqual, "keysEqual");
          function objectEqual(leftHandOperand, rightHandOperand, options) {
            var leftHandKeys = getEnumerableKeys(leftHandOperand);
            var rightHandKeys = getEnumerableKeys(rightHandOperand);
            if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
              leftHandKeys.sort();
              rightHandKeys.sort();
              if (iterableEqual(leftHandKeys, rightHandKeys) === false) return false;
              return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
            }
            var leftHandEntries = getIteratorEntries(leftHandOperand);
            var rightHandEntries = getIteratorEntries(rightHandOperand);
            if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
              leftHandEntries.sort();
              rightHandEntries.sort();
              return iterableEqual(leftHandEntries, rightHandEntries, options);
            }
            if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) return true;
            return false;
          }
          __name(objectEqual, "objectEqual");
          function isPrimitive(value) {
            return value === null || typeof value !== "object";
          }
          __name(isPrimitive, "isPrimitive");
        },
        {
          "type-detect": 38
        }
      ],
      36: [
        function(require2, module, exports) {
          var toString2 = Function.prototype.toString;
          var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
          function getFuncName(aFunc) {
            if (typeof aFunc !== "function") return null;
            var name = "";
            if (typeof Function.prototype.name === "undefined" && typeof aFunc.name === "undefined") {
              var match = toString2.call(aFunc).match(functionNameMatch);
              if (match) name = match[1];
            } else
              name = aFunc.name;
            return name;
          }
          __name(getFuncName, "getFuncName");
          module.exports = getFuncName;
        },
        {}
      ],
      37: [
        function(require2, module, exports) {
          function hasProperty(obj, name) {
            if (typeof obj === "undefined" || obj === null) return false;
            return name in Object(obj);
          }
          __name(hasProperty, "hasProperty");
          function parsePath(path) {
            var str = path.replace(/([^\\])\[/g, "$1.[");
            var parts = str.match(/(\\\.|[^.]+?)+/g);
            return parts.map(/* @__PURE__ */ __name(function mapMatches(value) {
              var regexp = /^\[(\d+)\]$/;
              var mArr = regexp.exec(value);
              var parsed = null;
              if (mArr) parsed = {
                i: parseFloat(mArr[1])
              };
              else parsed = {
                p: value.replace(/\\([.\[\]])/g, "$1")
              };
              return parsed;
            }, "mapMatches"));
          }
          __name(parsePath, "parsePath");
          function internalGetPathValue(obj, parsed, pathDepth) {
            var temporaryValue = obj;
            var res = null;
            pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
            for (var i2 = 0; i2 < pathDepth; i2++) {
              var part = parsed[i2];
              if (temporaryValue) {
                if (typeof part.p === "undefined") temporaryValue = temporaryValue[part.i];
                else temporaryValue = temporaryValue[part.p];
                if (i2 === pathDepth - 1) res = temporaryValue;
              }
            }
            return res;
          }
          __name(internalGetPathValue, "internalGetPathValue");
          function internalSetPathValue(obj, val, parsed) {
            var tempObj = obj;
            var pathDepth = parsed.length;
            var part = null;
            for (var i2 = 0; i2 < pathDepth; i2++) {
              var propName = null;
              var propVal = null;
              part = parsed[i2];
              if (i2 === pathDepth - 1) {
                propName = typeof part.p === "undefined" ? part.i : part.p;
                tempObj[propName] = val;
              } else if (typeof part.p !== "undefined" && tempObj[part.p]) tempObj = tempObj[part.p];
              else if (typeof part.i !== "undefined" && tempObj[part.i]) tempObj = tempObj[part.i];
              else {
                var next = parsed[i2 + 1];
                propName = typeof part.p === "undefined" ? part.i : part.p;
                propVal = typeof next.p === "undefined" ? [] : {};
                tempObj[propName] = propVal;
                tempObj = tempObj[propName];
              }
            }
          }
          __name(internalSetPathValue, "internalSetPathValue");
          function getPathInfo(obj, path) {
            var parsed = parsePath(path);
            var last = parsed[parsed.length - 1];
            var info = {
              parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
              name: last.p || last.i,
              value: internalGetPathValue(obj, parsed)
            };
            info.exists = hasProperty(info.parent, info.name);
            return info;
          }
          __name(getPathInfo, "getPathInfo");
          function getPathValue(obj, path) {
            var info = getPathInfo(obj, path);
            return info.value;
          }
          __name(getPathValue, "getPathValue");
          function setPathValue(obj, path, val) {
            var parsed = parsePath(path);
            internalSetPathValue(obj, val, parsed);
            return obj;
          }
          __name(setPathValue, "setPathValue");
          module.exports = {
            hasProperty,
            getPathInfo,
            getPathValue,
            setPathValue
          };
        },
        {}
      ],
      38: [
        function(require2, module, exports) {
          (function(global2, factory) {
            typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : global2.typeDetect = factory();
          })(this, function() {
            var promiseExists = typeof Promise === "function";
            var globalObject = typeof self === "object" ? self : $3817b02937c60b41$var$commonjsGlobal;
            var symbolExists = typeof Symbol !== "undefined";
            var mapExists = typeof Map !== "undefined";
            var setExists = typeof Set !== "undefined";
            var weakMapExists = typeof WeakMap !== "undefined";
            var weakSetExists = typeof WeakSet !== "undefined";
            var dataViewExists = typeof DataView !== "undefined";
            var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
            var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
            var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
            var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
            var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
            var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
            var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
            var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
            var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
            var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
            var toStringLeftSliceLength = 8;
            var toStringRightSliceLength = -1;
            function typeDetect(obj) {
              var typeofObj = typeof obj;
              if (typeofObj !== "object") return typeofObj;
              if (obj === null) return "null";
              if (obj === globalObject) return "global";
              if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) return "Array";
              if (typeof window === "object" && window !== null) {
                if (typeof window.location === "object" && obj === window.location) return "Location";
                if (typeof window.document === "object" && obj === window.document) return "Document";
                if (typeof window.navigator === "object") {
                  if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) return "MimeTypeArray";
                  if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) return "PluginArray";
                }
                if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
                  if (obj.tagName === "BLOCKQUOTE") return "HTMLQuoteElement";
                  if (obj.tagName === "TD") return "HTMLTableDataCellElement";
                  if (obj.tagName === "TH") return "HTMLTableHeaderCellElement";
                }
              }
              var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
              if (typeof stringTag === "string") return stringTag;
              var objPrototype = Object.getPrototypeOf(obj);
              if (objPrototype === RegExp.prototype) return "RegExp";
              if (objPrototype === Date.prototype) return "Date";
              if (promiseExists && objPrototype === Promise.prototype) return "Promise";
              if (setExists && objPrototype === Set.prototype) return "Set";
              if (mapExists && objPrototype === Map.prototype) return "Map";
              if (weakSetExists && objPrototype === WeakSet.prototype) return "WeakSet";
              if (weakMapExists && objPrototype === WeakMap.prototype) return "WeakMap";
              if (dataViewExists && objPrototype === DataView.prototype) return "DataView";
              if (mapExists && objPrototype === mapIteratorPrototype) return "Map Iterator";
              if (setExists && objPrototype === setIteratorPrototype) return "Set Iterator";
              if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) return "Array Iterator";
              if (stringIteratorExists && objPrototype === stringIteratorPrototype) return "String Iterator";
              if (objPrototype === null) return "Object";
              return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
            }
            __name(typeDetect, "typeDetect");
            return typeDetect;
          });
        },
        {}
      ]
    }, {}, [
      1
    ])(1);
  });
});
var $3817b02937c60b41$export$2e2bcd8739ae039 = $3817b02937c60b41$var$chai;
var $86d96475937d075f$export$3570f33b1a1f3329 = $3817b02937c60b41$export$2e2bcd8739ae039.expect;
var $86d96475937d075f$export$3f1553d94a1f489a = $3817b02937c60b41$export$2e2bcd8739ae039.should;
var $86d96475937d075f$export$a7a9523472993e97 = $3817b02937c60b41$export$2e2bcd8739ae039.assert;
var $7fbb3ce8a9213934$export$586098b0b3d55044 = /* @__PURE__ */ $parcel$interopDefault($947d894b4a2680e5$exports);
var $7fbb3ce8a9213934$export$3570f33b1a1f3329 = $86d96475937d075f$export$3570f33b1a1f3329;
var $7fbb3ce8a9213934$export$3f1553d94a1f489a = $86d96475937d075f$export$3f1553d94a1f489a;
var $7fbb3ce8a9213934$export$a7a9523472993e97 = $86d96475937d075f$export$a7a9523472993e97;

// packages/frontend/src/components/tests/src/modules/test/index.mjs
var tests = Symbol.for("tests");
var test_default = /* @__PURE__ */ __name((url = false) => {
  return new Promise(async (resolve, reject) => {
    try {
      let namespace = index_test_default;
      if (url) {
        let request = await fetch(url);
        namespace = await request.text();
      }
      const defaultTests = new Function("assert", "expect", "should", "isEmpty", namespace);
      defaultTests($7fbb3ce8a9213934$export$a7a9523472993e97, $7fbb3ce8a9213934$export$3570f33b1a1f3329, $7fbb3ce8a9213934$export$3f1553d94a1f489a, isEmpty_default, namespace);
      resolve({
        success: true,
        status: "true",
        message: ""
      });
    } catch (e2) {
      console.error(e2);
      resolve({
        success: false,
        status: "not ok",
        message: e2
      });
    }
  });
}, "default");

// packages/frontend/src/components/tests/src/modules/mocha/mocha.min.css.mjs
var mocha_min_css_default = `
@charset "utf-8";body{margin:0}#mocha{padding: 0; font:20px/1.5 "Helvetica Neue",Helvetica,Arial,sans-serif;margin:60px 50px}#mocha li,#mocha ul{margin:0;padding:0}#mocha ul{list-style:none}#mocha h1,#mocha h2{margin:0}#mocha h1{margin-top:15px;font-size:1em;font-weight:200}#mocha h1 a{text-decoration:none;color:inherit}#mocha h1 a:hover{text-decoration:underline}#mocha .suite .suite h1{margin-top:0;font-size:.8em}#mocha .hidden{display:none}#mocha h2{font-size:12px;font-weight:400;cursor:pointer}#mocha .suite{margin-left:15px}#mocha .test{margin-left:15px;overflow:hidden}#mocha .test.pending:hover h2::after{content:'(pending)';font-family:arial,sans-serif}#mocha .test.pass.medium .duration{background:#c09853}#mocha .test.pass.slow .duration{background:#b94a48}#mocha .test.pass::before{content:'\u2713';font-size:12px;display:block;float:left;margin-right:5px;color:#00d6b2}#mocha .test.pass .duration{font-size:9px;margin-left:5px;padding:2px 5px;color:#fff;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.2);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,.2);box-shadow:inset 0 1px 1px rgba(0,0,0,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}#mocha .test.pass.fast .duration{display:none}#mocha .test.pending{color:#0b97c4}#mocha .test.pending::before{content:'\u25E6';color:#0b97c4}#mocha .test.fail{color:#c00}#mocha .test.fail pre{color:#000}#mocha .test.fail::before{content:'\u2716';font-size:12px;display:block;float:left;margin-right:5px;color:#c00}#mocha .test pre.error{color:#c00;max-height:300px;overflow:auto}#mocha .test .html-error{overflow:auto;color:#000;display:block;float:left;clear:left;font:12px/1.5 monaco,monospace;margin:5px;padding:15px;border:1px solid #eee;max-width:85%;max-width:-webkit-calc(100% - 42px);max-width:-moz-calc(100% - 42px);max-width:calc(100% - 42px);max-height:300px;word-wrap:break-word;border-bottom-color:#ddd;-webkit-box-shadow:0 1px 3px #eee;-moz-box-shadow:0 1px 3px #eee;box-shadow:0 1px 3px #eee;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}#mocha .test .html-error pre.error{border:none;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;-webkit-box-shadow:0;-moz-box-shadow:0;box-shadow:0;padding:0;margin:0;margin-top:18px;max-height:none}#mocha .test pre{display:block;float:left;clear:left;font:12px/1.5 monaco,monospace;margin:5px;padding:15px;border:1px solid #eee;max-width:85%;max-width:-webkit-calc(100% - 42px);max-width:-moz-calc(100% - 42px);max-width:calc(100% - 42px);word-wrap:break-word;border-bottom-color:#ddd;-webkit-box-shadow:0 1px 3px #eee;-moz-box-shadow:0 1px 3px #eee;box-shadow:0 1px 3px #eee;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}#mocha .test h2{position:relative}#mocha .test a.replay{position:absolute;top:3px;right:0;text-decoration:none;vertical-align:middle;display:block;width:15px;height:15px;line-height:15px;text-align:center;background:#eee;font-size:15px;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;-o-transition:opacity .2s;transition:opacity .2s;opacity:.3;color:#888}#mocha .test:hover a.replay{opacity:1}#mocha-report.pass .test.fail{display:none}#mocha-report.fail .test.pass{display:none}#mocha-report.pending .test.fail,#mocha-report.pending .test.pass{display:none}#mocha-report.pending .test.pass.pending{display:block}#mocha-error{color:#c00;font-size:1.5em;font-weight:100;letter-spacing:1px}#mocha-stats{position:absolute;top:0;right:10px;font-size:12px;margin:0;color:#888;z-index:1}#mocha-stats .progress{float:right;padding-top:0;height:auto;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;background-color:initial}#mocha-stats em{color:#000}#mocha-stats a{text-decoration:none;color:inherit}#mocha-stats a:hover{border-bottom:1px solid #eee}#mocha-stats li{display:inline-block;margin:0 5px;list-style:none;padding-top:11px}#mocha-stats canvas{width:40px;height:40px}#mocha code .comment{color:#ddd}#mocha code .init{color:#2f6fad}#mocha code .string{color:#5890ad}#mocha code .keyword{color:#8a6343}#mocha code .number{color:#2f6fad}@media screen and (max-device-width:480px){#mocha{margin:60px 0}#mocha #stats{position:absolute}}
`;

// packages/frontend/src/components/tests/src/index.mjs
var mochaHtml = `<div id="tests" style="position: relative; display: none"><ul id="mocha"></ul></div><style>${mocha_min_css_default}</style>`;
var test = /* @__PURE__ */ __name((state = {}) => {
  const root2 = state.root || document.body;
  const path = state.path || false;
  const checkLeaks = state.checkLeaks || true;
  return new Promise(async (resolve, reject) => {
    try {
      $7fbb3ce8a9213934$export$586098b0b3d55044.setup("bdd");
      path ? await test_default(path) : await test_default();
      root2.insertAdjacentHTML("beforeend", mochaHtml);
      checkLeaks ? $7fbb3ce8a9213934$export$586098b0b3d55044.checkLeaks() : "";
      $7fbb3ce8a9213934$export$586098b0b3d55044.run();
      resolve(true);
    } catch (e2) {
      reject({
        success: false,
        status: "false",
        message: e2
      });
    }
  });
}, "test");

// packages/frontend/modules/index.mjs
var COLORS2 = {
  WARN: "\x1B[33m",
  // -
  INFO: "\x1B[36m",
  // 
  DEBUG: "\x1B[90m",
  // 
  ERROR: "\x1B[31m",
  // 
  RESET: "\x1B[0m"
  // 
};
function createLogger2(prefix) {
  const baseLogger = logger(prefix);
  const enhancedLogger = /* @__PURE__ */ __name((...args) => baseLogger(...args), "enhancedLogger");
  enhancedLogger.trace = baseLogger.trace;
  enhancedLogger.warn = (...args) => {
    baseLogger(`${COLORS2.WARN}\u26A0\uFE0F WARN:${COLORS2.RESET}`, ...args);
  };
  enhancedLogger.info = (...args) => {
    baseLogger(`${COLORS2.INFO}\u2139\uFE0F INFO:${COLORS2.RESET}`, ...args);
  };
  enhancedLogger.debug = (...args) => {
    baseLogger(`${COLORS2.DEBUG}\u{1F50D} DEBUG:${COLORS2.RESET}`, ...args);
  };
  enhancedLogger.error = (...args) => {
    baseLogger(`${COLORS2.ERROR}\u274C ERROR:${COLORS2.RESET}`, ...args);
  };
  return enhancedLogger;
}
__name(createLogger2, "createLogger");

// packages/frontend/src/scroll.mjs
var ScrollManager = class {
  static {
    __name(this, "ScrollManager");
  }
  constructor() {
    this.scrollTimeout = null;
    this.isScrolling = false;
    this.debounceDelay = 200;
    this.init();
  }
  init() {
    document.addEventListener("scroll", () => {
      this.handleScrollStart();
    }, { passive: false });
    this.checkScrollNecessity();
  }
  handleScrollStart() {
    if (!this.isScrolling) {
      this.isScrolling = true;
      document.documentElement.classList.add("scrolling");
    }
    this.clearTimeout();
    this.scrollTimeout = setTimeout(() => {
      this.handleScrollEnd();
    }, this.debounceDelay);
  }
  handleScrollEnd() {
    this.isScrolling = false;
    document.documentElement.classList.remove("scrolling");
  }
  clearTimeout() {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
  }
  checkScrollNecessity() {
    const hasScrollbar = document.documentElement.scrollHeight > window.innerHeight;
    if (!hasScrollbar) {
      document.documentElement.style.setProperty("--scrollbar-visibility", "hidden");
      document.documentElement.style.setProperty("--scrollbar-opacity", "0");
    }
  }
  //    /
  showScrollbar() {
    document.documentElement.classList.add("scrolling");
  }
  hideScrollbar() {
    document.documentElement.classList.remove("scrolling");
  }
  //  
  updateSettings(delay = 1500) {
    this.debounceDelay = delay;
  }
};

// packages/frontend/src/index.mjs
init_virtual_css();
var log4 = createLogger2("incoming_message");
var app = {};
var isTests = false;
var root;
var context = {};
app = window.onload = (async () => {
  injectCSS();
  function loadTemplateBasedOnPath() {
    const container = document.getElementById("main-container");
    const path = window.location.pathname;
    let templateId;
    if (path.includes("/youtube/receiver")) {
      templateId = "receiver-template";
    } else if (path.includes("/youtube/sender")) {
      templateId = "sender-template";
    } else if (path.includes("/youtube/")) {
      templateId = "main-template";
    } else {
      if (path.includes("/receiver")) {
        templateId = "receiver-template";
      } else if (path.includes("/sender")) {
        templateId = "sender-template";
      } else {
        templateId = "main-template";
      }
    }
    const template = document.getElementById(templateId);
    if (template) {
      container.innerHTML = "";
      const content = template.content.cloneNode(true);
      container.appendChild(content);
      updateActiveNavLinks(path);
    }
  }
  __name(loadTemplateBasedOnPath, "loadTemplateBasedOnPath");
  app.startTime = Date.now();
  app.NODE_PORT = 6832;
  const html = document.body.querySelector(".container");
  const components = [];
  for (let item of components) {
    const isAttribute = item.hasOwnProperty("attributes");
    context[`${item.component}`] = [];
    const element = document.createElement(`${item.component}`);
    element.setAttribute("id", `${item.id}`);
    element.setAttribute("slot", `${item.slot}`);
    if (isAttribute) {
      for (let key in item.attributes) {
        element.setAttribute(key, `${item.attributes[key]}`);
      }
    }
    context[`${item.component}`].push({
      element
    });
    if (!components[`${item.component}`]) {
      components[`${item.component}`] = {
        id: {
          [`${item.id}`]: element
        }
      };
      root = root ? root : element;
    } else if (!components[`${item.component}`].id[item.id]) {
      components[`${item.component}`].id[item.id] = element;
      root = root ? root : element;
    } else {
      console.log("item", item);
      console.error("\u043D\u0435 \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C");
    }
    html.appendChild(element);
  }
  setTimeout(async () => {
    document.documentElement.classList.add("visible");
  }, 1500);
  if (isTests) {
    test({
      path: "/tests/index.mjs"
    }).catch((e2) => {
      console.log("error devtool", e2);
    });
  }
  return components;
})();
if (document.readyState === "loading") {
  console.log("------------------- loading -------------------");
  document.addEventListener("DOMContentLoaded", () => {
    window.scrollManager = new ScrollManager();
  });
} else {
  window.scrollManager = new ScrollManager();
}
export {
  app,
  createLogger2 as createLogger
};
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
* @license  MIT
*/
/*!
* mocha
* Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
* MIT Licensed
*/
/*!
* chai
* Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai version
*/
/*!
* Assertion Error
*/
/*!
* Utils for plugins (not exported)
*/
/*!
* Utility Functions
*/
/*!
* Configuration
*/
/*!
* Primary `Assertion` prototype
*/
/*!
* Core Assertions
*/
/*!
* Expect interface
*/
/*!
* Should interface
*/
/*!
* Assert interface
*/
/*!
* chai
* http://chaijs.com
* Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Module dependencies.
*/
/*!
* Module export.
*/
/*!
* Assertion Constructor
*
* Creates object for chaining.
*
* `Assertion` objects contain metadata in the form of flags. Three flags can
* be assigned during instantiation by passing arguments to this constructor:
*
* - `object`: This flag contains the target of the assertion. For example, in
*   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
*   contain `numKittens` so that the `equal` assertion can reference it when
*   needed.
*
* - `message`: This flag contains an optional custom error message to be
*   prepended to the error message that's generated by the assertion when it
*   fails.
*
* - `ssfi`: This flag stands for "start stack function indicator". It
*   contains a function reference that serves as the starting point for
*   removing frames from the stack trace of the error that's created by the
*   assertion when it fails. The goal is to provide a cleaner stack trace to
*   end users by removing Chai's internal functions. Note that it only works
*   in environments that support `Error.captureStackTrace`, and only when
*   `Chai.config.includeStack` hasn't been set to `false`.
*
* - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
*   should retain its current value, even as assertions are chained off of
*   this object. This is usually set to `true` when creating a new assertion
*   from within another assertion. It's also temporarily set to `true` before
*   an overwritten assertion gets called by the overwriting assertion.
*
* @param {Mixed} obj target of the assertion
* @param {String} msg (optional) custom error message
* @param {Function} ssfi (optional) starting point for removing stack frames
* @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
* @api private
*/
/*!
* ### ._obj
*
* Quick reference to stored `actual` value for plugin developers.
*
* @api private
*/
/*!
* Chai dependencies.
*/
/*!
* ### .ifError(object)
*
* Asserts if value is not a false value, and throws if it is a true value.
* This is added to allow for chai to be a drop-in replacement for Node's
* assert class.
*
*     var err = new Error('I am a custom error');
*     assert.ifError(err); // Rethrows err!
*
* @name ifError
* @param {Object} object
* @namespace Assert
* @api public
*/
/*!
* Aliases.
*/
/*!
* Chai - addChainingMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Module dependencies
*/
/*!
* Module variables
*/
/*!
* Chai - addLengthGuard utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - addMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - addProperty utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - compareByInspect utility
* Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - expectTypes utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - flag utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getActual utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getEnumerableProperties utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - message composition utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getOwnEnumerableProperties utility
* Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getOwnEnumerablePropertySymbols utility
* Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getProperties utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* chai
* Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Dependencies that are used for multiple exports are required here only once
*/
/*!
* test utility
*/
/*!
* type utility
*/
/*!
* expectTypes utility
*/
/*!
* message utility
*/
/*!
* actual utility
*/
/*!
* Inspect util
*/
/*!
* Object Display util
*/
/*!
* Flag utility
*/
/*!
* Flag transferring utility
*/
/*!
* Deep equal utility
*/
/*!
* Deep path info
*/
/*!
* Check if a property exists
*/
/*!
* Function name
*/
/*!
* add Property
*/
/*!
* add Method
*/
/*!
* overwrite Property
*/
/*!
* overwrite Method
*/
/*!
* Add a chainable method
*/
/*!
* Overwrite chainable method
*/
/*!
* Compare by inspect method
*/
/*!
* Get own enumerable property symbols method
*/
/*!
* Get own enumerable properties method
*/
/*!
* Checks error against a given set of criteria
*/
/*!
* Proxify util
*/
/*!
* addLengthGuard util
*/
/*!
* isProxyEnabled helper
*/
/*!
* isNaN method
*/
/*!
* Chai - isNaN utility
* Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
* MIT Licensed
*/
/*!
* Chai - isProxyEnabled helper
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - overwriteChainableMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - overwriteMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - overwriteProperty utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - proxify utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - test utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - transferFlags utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* assertion-error
* Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
* MIT Licensed
*/
/*!
* Return a function that will copy properties from
* one object to another excluding any originally
* listed. Returned function will create a new `{}`.
*
* @param {String} excluded properties ...
* @return {Function}
*/
/*!
* Primary Exports
*/
/*!
* Inherit from Error.prototype
*/
/*!
* Statically set name
*/
/*!
* Ensure correct constructor
*/
/*!
* deep-eql
* Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/
/*!
* Primary Export
*/
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/
/*!
* Compare two Regular Expressions for equality.
*
* @param {RegExp} leftHandOperand
* @param {RegExp} rightHandOperand
* @return {Boolean} result
*/
/*!
* Compare two Sets/Maps for equality. Faster than other equality functions.
*
* @param {Set} leftHandOperand
* @param {Set} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*/
/*!
* Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
*
* @param {Iterable} leftHandOperand
* @param {Iterable} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*/
/*!
* Simple equality for generator objects such as those returned by generator functions.
*
* @param {Iterable} leftHandOperand
* @param {Iterable} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*/
/*!
* Determine if the given object has an @@iterator function.
*
* @param {Object} target
* @return {Boolean} `true` if the object has an @@iterator function.
*/
/*!
* Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
* This will consume the iterator - which could have side effects depending on the @@iterator implementation.
*
* @param {Object} target
* @returns {Array} an array of entries from the @@iterator function
*/
/*!
* Gets all entries from a Generator. This will consume the generator - which could have side effects.
*
* @param {Generator} target
* @returns {Array} an array of entries from the Generator.
*/
/*!
* Gets all own and inherited enumerable keys from a target.
*
* @param {Object} target
* @returns {Array} an array of own and inherited enumerable keys from the target.
*/
/*!
* Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
* each key. If any value of the given key is not equal, the function will return false (early).
*
* @param {Mixed} leftHandOperand
* @param {Mixed} rightHandOperand
* @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
* @param {Object} [options] (Optional)
* @return {Boolean} result
*/
/*!
* Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
* for each enumerable key in the object.
*
* @param {Mixed} leftHandOperand
* @param {Mixed} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*/
/*!
* Returns true if the argument is a primitive.
*
* This intentionally returns true for all objects that can be compared by reference,
* including functions and symbols.
*
* @param {Mixed} value
* @return {Boolean} result
*/
//# sourceMappingURL=index.bundle.mjs.map
